/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap

pin Democap.Behaviors

pin Dragengine.CameraDirectors
pin Dragengine.Gui
pin Dragengine.Preloading
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils



/**
 * Start game loader class.
 */
class StartGame extends WindowGameWorld.Loader
	var Project pProject
	var Scene pScene
	var Array pRestoreObjects
	
	
	
	/** Create start game loader. */
	func new(WindowGameWorld window, Project project, Scene scene, Array restoreObjects) super(window)
		pProject = project
		pScene = scene
		pRestoreObjects = restoreObjects
		
		setPathWorld(File.absolutePath(scene.getPathWorld(), project.getDataDirectory().toString()).getPath())
		
		// load initial data from save state
		if scene.getSaveState() != null
			var Persistency persistency = GameApp.getGameApp().getLoaders().getPersistency()
			var FileReader reader = scene.getSaveState().getReader()
			var PersistencyEnvironment env = PersistencyEnvironment.new(persistency, reader.readByte())
			
			setPersistency(env, reader)
			
			select env.getVersion()
			case 0
				getIDGenerator().readFromFile(reader)
				
			else
				throw EInvalidParam.new("Unsupported version")
			end
			
			setIgnorePersistableElements(true)
			
		else
			getIDGenerator().setFrom(UniqueID.new(1))
		end
		
		pScene.getFileUsage().setLocked(true)
	end
	
	
	
	/** Scene. */
	func Scene getScene()
		return pScene
	end
	
	
	
	/** Create loading window. */
	protected func void createLoadingWindow()
		super.createLoadingWindow()
		
		// the base class implementation activates the desktop input processor.
		// revert back to our split input processor
		GameApp.getGameApp().setSplitInputProcessor()
	end
	
	/** Create game world. */
	protected func GameWorld createGameWorld()
		return MoCapGameWorld.new(pProject, pScene)
	end
	
	/** Extend base class implementation to remap path. */
	protected func void worldStoreNextIDAndRemapEntry()
		super.worldStoreNextIDAndRemapEntry()
		remapPropertyPath()
	end
	
	/** Remap properties with path inside. */
	protected func void remapPropertyPath()
		var String remapPath = getStubWorld().getPropertyValueFor("democap.remapPropertyPath", "")
		if remapPath.empty()
			return
		end
		
		var File basePath = File.new(getPathWorld()).getParent()
		var int remapPathCut = remapPath.getLength()
		var String value
		
		getStubWorld().forEachElement(block StubElement stub
			stub.getPropertyKeys().forEach(block String key
				value = stub.getPropertyValueFor(key, null)
				
				if value.startsWith(remapPath)
					stub.setPropertyValueFor(key, (basePath + value.substring(remapPathCut)).toString())
				end
			end)
		end)
	end
	
	/** Create content from stub. */
	protected func void createContentFromStub()
		super.createContentFromStub()
		
		// restore objects is put aside and cleared to avoid dead-loop
		// if recreating objects fails for whatever reason
		var Array restoreObjects = pRestoreObjects
		pRestoreObjects = null
		
		if restoreObjects != null
			var GameWorld gameWorld = getStubWorld().getGameWorld()
			restoreObjects.forEach(block ECBCopyObject.ObjectCopyData each
				each.createCopy(gameWorld, null, DVector.new())
			end)
		end
	end
	
	/** Loading world finished successfully. */
	func void onLoadWorldFinished()
		var GameApp app = BaseGameApp.getApp() cast GameApp
		
		pScene.getFileUsage().setLocked(false)
		
		// assign camera director attaching the camera to the player controlled actor
		getWindow().setCameraDirector(app.getVRCameraDirector())
		
		// apply settings
		var GameWorld gameWorld = getStubWorld().getGameWorld()
		gameWorld.getWorld().setDisableLights(SessionSettings.get().getModelFullBright().getToggled())
		
		// finish loading world. super.onLoadWorldFinished() sets the game world and
		// disposes of the previous one. this can lead to problems since certain code
		// expects the game world and objects inside to be valid (not disposed) until
		// game world changed notification has been send. so set the game world without
		// disposing of it and dispose after finishLoadGameWorld
		//super.onLoadWorldFinished()
		var GameWorld oldGameWorld = getWindow().getGameWorld()
		getWindow().setGameWorld(gameWorld, false)
		
		try
			// activate vr camera if required
			if SessionSettings.get().getModelShowVRCamera().getToggled()
				getWindow().getWorldRenderer().setCamera(app.getVRCamera())
			end
			
			// finish loading
			app.finishLoadGameWorld()
			
		catch Exception e
			if oldGameWorld != null
				oldGameWorld.dispose()
			end
			throw
		end
		
		if oldGameWorld != null
			oldGameWorld.dispose()
		end
	end
	
	/** Loading world failed. */
	func void onLoadWorldFailed()
		var Project project = pProject
		var Scene scene = pScene
		
		super.onLoadWorldFailed()
		
		scene.getFileUsage().setLocked(false)
		BaseGameApp.getApp().cancelLoadGameWorld()
		
		// this triggers another StartGame so it has to come last
		//
		// two main reasons can lead to this function to be called.
		//
		// 1) a custom *.deworld is broken and can not be loaded.
		//    in this case pRestoreObjects is potentially an Array holding objects
		//    to be restored. by switching back to the default world and restoring
		//    the objects we should be back to a working condition.
		//
		// 2) an object fails to load.
		//    this should never happen. in case this still happens pRestoreObjects
		//    will be always null (no matter if case 1 fired or not). in this case
		//    world will be also set back to default but no objects will be
		//    restored. this way the scene resets to default state. this is
		//    the ultimate fallback if something goes horribly wrong.
		//
		// the possible sequence of actions can be 1->2 or 2
		scene.revertWorldToDefault(project, pRestoreObjects)
	end
end
