/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Characters

pin Democap.Actors
pin Democap.Behaviors
pin Democap.MotionTransferSystem

pin Dragengine.Animators
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.Preloading


/**
 * Character configuration. Stores tracker configuration and information about how tracker
 * data affects the character rig.
 */
class CharacterConfiguration
	private var CharacterProfile pProfile
	private var String pName
	
	private var float pShoulderLevel
	
	private var CharacterTrackerSlots pTrackerSlots
	private var MotionTransfers pMotionTransfers
	
	private var BaseVRActorClass pElementClass
	private var BaseVRActorClass pOldElementClass
	private var PreloadCounter pPreloadCounter
	
	
	
	/** Create character configuration. */
	public func new(CharacterProfile profile, String name)
		if profile == null
			throw ENullPointer.new("profile")
		end
		
		pProfile = profile
		setName(name)
		
		pShoulderLevel = 1.6
		
		pTrackerSlots = CharacterTrackerSlots.new()
		pMotionTransfers = MotionTransfers.new()
	end
	
	/** Create copy of character configuration. */
	public func new(CharacterConfiguration configuration)
		pName = configuration.pName
		pShoulderLevel = configuration.pShoulderLevel
		
		pTrackerSlots = CharacterTrackerSlots.new()
		configuration.pTrackerSlots.forEach(block CharacterTrackerSlot each
			pTrackerSlots.add(CharacterTrackerSlot.new(each))
		end)
		
		pMotionTransfers = MotionTransfers.new()
		configuration.pMotionTransfers.forEach(block MotionTransfer each
			pMotionTransfers.add(each.createCopy())
		end)
	end
	
	/** Dispose of character profile. */
	public func void dispose()
		dropElementClass()
		disposeOldElementClass()
		pProfile = null
	end
	
	
	
	/** Character profile owning this configuration. */
	public func CharacterProfile getProfile()
		return pProfile
	end
	
	/** Name of character profile. */
	public func String getName()
		return pName
	end
	
	/** Set name of character profile. */
	public func void setName(String name)
		if name == null
			throw ENullPointer.new("name")
		end
		if name.empty()
			throw EInvalidParam.new("name is empty string")
		end
		
		pName = name
	end
	
	/** Shoulder level in meters. */
	public func float getShoulderLevel()
		return pShoulderLevel
	end
	
	/** Set shoulder level in meters. */
	public func void setShoulderLevel(float level)
		this.pShoulderLevel = DEMath.max(level, 0.1)
	end
	
	/** Tracker slots. */
	public func CharacterTrackerSlots getTrackerSlots()
		return pTrackerSlots
	end
	
	/** Motion transfers. */
	public func MotionTransfers getMotionTransfers()
		return pMotionTransfers
	end
	
	
	
	/**
	 * Element class creating and preloading it if required. Returned element class can be
	 * still preloading so check isElementClassPreloading() to check if it is ready to be used.
	 */
	public func BaseVRActorClass getElementClass()
		if pElementClass == null
			pElementClass = createElementClass()
			pPreloadCounter = PreloadCounter.new()
			pElementClass.preloadResources(pPreloadCounter)
		end
		return pElementClass
	end
	
	/** Element class is preloading. Always false until getElementClass() is called. */
	public func bool isElementClassPreloading()
		if pPreloadCounter != null and pPreloadCounter.isNotZero()
			return true
		end
		pPreloadCounter = null
		return false
	end
	
	/** Drop element class. */
	public func void dropElementClass()
		if pElementClass == null
			return
		end
		
		disposeOldElementClass()
		pOldElementClass = pElementClass
		pElementClass = null
		pPreloadCounter = null
	end
	
	
	
	/** Reset calibration. */
	public func void resetCalibration()
	end
	
	/** Calibrate character. */
	public func void calibrate(BaseVRActor actor, ActorProfile actorProfile)
		var Matrix rightHand, leftHand
		
		if actor.getVRRightHand().isAttached()
			rightHand = actor.getVRRightHand().getMatrixPlayspace()
		end
		if actor.getVRLeftHand().isAttached()
			leftHand = actor.getVRLeftHand().getMatrixPlayspace()
		end
		
		// for calibration we need these three for the time being
		if rightHand == null or leftHand == null
			resetCalibration()
			return
		end
		
		// calculate calibration matrix transforming tracked positions into calibration
		// coordinate system. hmd looks forwards, hands are aligned along the X axis and
		// body is centered along X and Z direction. also apply scaling from actor
		// shoulder level to character shoulder level
		var Vector posRightHand = rightHand.getPosition()
		var Vector posLeftHand = leftHand.getPosition()
		
		var Vector centerHands = (posRightHand + posLeftHand) * 0.5
		
		var Vector dirHands = (posRightHand - posLeftHand).normalize()
		var float rotHands = -DEMath.atan2(dirHands.getX(), dirHands.getZ())
		
		var float scale = pShoulderLevel / actorProfile.getShoulderLevel()
		
		var Matrix matrix = Matrix.newTranslation(-centerHands.compSelect(true, false, true)) \
			* Matrix.newRotationY(-90.0 - rotHands) * Matrix.newScaling(scale, scale, scale)
		
		GameApp.getGameApp().getConsole().addMessage("CharacterConfiguration.calibrate: centerHands=" \
			+ centerHands + " rotHands=" + rotHands + " scale=" + scale)
		
		// calibrate tracker slots using the calibration matrix
		pTrackerSlots.forEach(block CharacterTrackerSlot each
			each.calibrate(actor, matrix)
		end)
		
		// calibrate motion transfers using the calibrated trackers slots
	end
	
	
	
	/** Create element class. Caller has to start preloading to use it. */
	public func BaseVRActorClass createElementClass()
		var BaseVRActorClass eclass = BaseVRActorClass.new(\
			"Character" + GameApp.getGameApp().getNextElementClassID().nextID())
		
		eclass.getAIAction().setActionFactory(Actions.AADefault.Factory.new())
		
		var AnimatorDefinition adef = AnimatorDefinition.new("")
		
		try
			ECBCharacterConfiguration.new(eclass, this)
			var ECBMoCapAnimator mocapAnimator = ECBMoCapAnimator.new(eclass)
			
			pProfile.getAppearance().initElementClass(eclass)
			
			// add tracker slots. each slot adds two controllers (position, rotation)
			pTrackerSlots.forEach(block CharacterTrackerSlot each
				var ECBTrackerSlot behavior = ECBTrackerSlot.new(eclass, each)
				
				var ADController adcontroller = ADController.new()
				adcontroller.setName(behavior.getControllerNamePosition())
				adef.addController(adcontroller)
				
				adcontroller = ADController.new()
				adcontroller.setName(behavior.getControllerNameRotation())
				adef.addController(adcontroller)
			end)
			
			// add motion capture behaviors
			pMotionTransfers.forEach(block MotionTransfer each
				each.initElementClass(eclass)
			end)
			
			// finalize motion capture animator
			var Animator animator = Animator.new()
			adef.buildAnimator(animator)
			mocapAnimator.setAnimator(animator)
			
		catch Exception e
			eclass.dispose()
			throw
		end
		
		return eclass
	end
	
	/**
	 * Create stub element. If no element class is present or it is still preloading
	 * null is returned.
	 */
	public func StubElement createStubElement()
		var StubElement stub
		if pElementClass != null and not isElementClassPreloading()
			stub = StubElement.new(getElementClass(), GameApp.getGameApp().getIDGenerator().nextID())
			// sometimes it can be required to set stub properties
		end
		return stub
	end
	
	
	
	/** Dispose old element class kept to avoid reloading resources. */
	protected func void disposeOldElementClass()
		if pOldElementClass != null
			pOldElementClass.dispose()
			pOldElementClass = null
		end
	end
end
