/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Characters

pin Democap.Actors
pin Democap.Behaviors
pin Democap.MotionTransferSystem

pin Dragengine.Animators
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.Preloading


/**
 * Character configuration. Stores tracker configuration and information about how tracker
 * data affects the character rig.
 */
class CharacterConfiguration
	private var CharacterProfile pProfile
	private var String pName
	
	private var float pShoulderLevel
	private var String pMoveCalibrate
	
	private var bool pIsCalibrated
	private var float pCalibrateScale
	private var Vector pCalibrateCenter
	private var float pCalibrateTurn
	private var Matrix pCalibrateMatrix
	private var Matrix pCalibrateMatrixInverse
	
	private var CharacterTrackerSlots pTrackerSlots
	private var MotionTransfers pMotionTransfers
	
	private var BaseVRActorClass pElementClass
	private var BaseVRActorClass pOldElementClass
	private var PreloadCounter pPreloadCounter
	private var AnimatorDefinition pAnimatorDefinition
	
	
	
	/** Create character configuration. */
	public func new(CharacterProfile profile, String name)
		if profile == null
			throw ENullPointer.new("profile")
		end
		
		pProfile = profile
		setName(name)
		
		pShoulderLevel = 1.6
		pMoveCalibrate = ""
		
		pIsCalibrated = false
		pCalibrateScale = 1
		pCalibrateCenter = Vector.new()
		pCalibrateTurn = 0
		pCalibrateMatrix = Matrix.new()
		pCalibrateMatrixInverse = Matrix.new()
		
		pTrackerSlots = CharacterTrackerSlots.new()
		pMotionTransfers = MotionTransfers.new()
	end
	
	/** Create copy of character configuration. */
	public func new(CharacterConfiguration configuration)
		pName = configuration.pName
		pShoulderLevel = configuration.pShoulderLevel
		pMoveCalibrate = configuration.pMoveCalibrate
		
		pIsCalibrated = configuration.pIsCalibrated
		pCalibrateScale = configuration.pCalibrateScale
		pCalibrateCenter = configuration.pCalibrateCenter
		pCalibrateTurn = configuration.pCalibrateTurn
		pCalibrateMatrix = configuration.pCalibrateMatrix
		pCalibrateMatrixInverse = configuration.pCalibrateMatrixInverse
		
		pTrackerSlots = CharacterTrackerSlots.new()
		configuration.pTrackerSlots.forEach(block CharacterTrackerSlot each
			pTrackerSlots.add(CharacterTrackerSlot.new(each))
		end)
		
		pMotionTransfers = MotionTransfers.new()
		configuration.pMotionTransfers.forEach(block MotionTransfer each
			pMotionTransfers.add(each.createCopy())
		end)
	end
	
	/** Dispose of character profile. */
	public func void dispose()
		dropElementClass()
		disposeOldElementClass()
		pProfile = null
	end
	
	
	
	/** Character profile owning this configuration. */
	public func CharacterProfile getProfile()
		return pProfile
	end
	
	/** Name of character profile. */
	public func String getName()
		return pName
	end
	
	/** Set name of character profile. */
	public func void setName(String name)
		if name == null
			throw ENullPointer.new("name")
		end
		if name.empty()
			throw EInvalidParam.new("name is empty string")
		end
		
		pName = name
	end
	
	/** Shoulder level in meters. */
	public func float getShoulderLevel()
		return pShoulderLevel
	end
	
	/** Set shoulder level in meters. */
	public func void setShoulderLevel(float level)
		pShoulderLevel = DEMath.max(level, 0.1)
	end
	
	/** Name of animation move to use for calibration or empty string to use none. */
	public func String getMoveCalibrate()
		return pMoveCalibrate
	end
	
	/** Set name of animation move to use for calibration or empty string to use none. */
	public func void setMoveCalibrate(String animation)
		if animation == null
			throw ENullPointer.new("animation")
		end
		
		pMoveCalibrate = animation
	end
	
	
	
	/** Tracker slots. */
	public func CharacterTrackerSlots getTrackerSlots()
		return pTrackerSlots
	end
	
	/** Motion transfers. */
	public func MotionTransfers getMotionTransfers()
		return pMotionTransfers
	end
	
	
	
	/**
	 * Element class creating and preloading it if required. Returned element class can be
	 * still preloading so check isElementClassPreloading() to check if it is ready to be used.
	 */
	public func BaseVRActorClass getElementClass()
		if pElementClass == null
			pElementClass = createElementClass()
			pPreloadCounter = PreloadCounter.new()
			pElementClass.preloadResources(pPreloadCounter)
		end
		return pElementClass
	end
	
	/** Element class is preloading. Always false until getElementClass() is called. */
	public func bool isElementClassPreloading()
		if pPreloadCounter != null and pPreloadCounter.isNotZero()
			return true
		end
		pPreloadCounter = null
		return false
	end
	
	/** Drop element class. */
	public func void dropElementClass()
		if pElementClass == null
			return
		end
		
		disposeOldElementClass()
		pOldElementClass = pElementClass
		pElementClass = null
		pPreloadCounter = null
	end
	
	/** Animator definition used while creating element class or null. */
	public func AnimatorDefinition getAnimatorDefinition()
		return pAnimatorDefinition
	end
	
	
	
	/** Character is calibrated. */
	public func bool isCalibrated()
		return pIsCalibrated
	end
	
	/** Calibrated scale between actor and character. */
	public func float getCalibrateScale()
		return pCalibrateScale
	end
	
	/** Set calibrated scale between actor and character. */
	public func void setCalibrateScale(float scale)
		pCalibrateScale = scale
		updateCalibrateMatrix()
	end
	
	/** Calibrated center. */
	public func Vector getCalibrateCenter()
		return pCalibrateCenter
	end
	
	/** Set calibrated center. */
	public func void setCalibrateCenter(Vector center)
		if center == null
			throw ENullPointer.new("center")
		end
		pCalibrateCenter = center
		updateCalibrateMatrix()
	end
	
	/** Calibrated turn. */
	public func float getCalibrateTurn()
		return pCalibrateTurn
	end
	
	/** Set calibrated turn. */
	public func void setCalibrateTurn(float turn)
		pCalibrateTurn = turn
		updateCalibrateMatrix()
	end
	
	/** Calibrate matrix. */
	public func Matrix getCalibrateMatrix()
		return pCalibrateMatrix
	end
	
	/** Inverse calibrate matrix. */
	public func Matrix getCalibrateMatrixInverse()
		return pCalibrateMatrixInverse
	end
	
	/** Update calibrate matrix. */
	public func void updateCalibrateMatrix()
		pCalibrateMatrix = Matrix.newTranslation(pCalibrateCenter) \
			* Matrix.newRotationY(pCalibrateTurn) \
			* Matrix.newScaling(pCalibrateScale, pCalibrateScale, pCalibrateScale)
		pCalibrateMatrixInverse = pCalibrateMatrix.getInverse()
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pIsCalibrated = false
		pCalibrateScale = 1
		pCalibrateCenter = Vector.new()
		pCalibrateTurn = 0
		pCalibrateMatrix = Matrix.new()
		pCalibrateMatrixInverse = Matrix.new()
		
		pTrackerSlots.forEach(block CharacterTrackerSlot each
			each.resetCalibration()
		end)
		
		pMotionTransfers.forEach(block MotionTransfer each
			each.resetCalibration()
		end)
	end
	
	/** Calibrate character. */
	public func void calibrate(BaseVRActor actor, ActorProfile actorProfile)
		// drop element class. we need to create a new one
		dropElementClass()
		
		// get hand positions to align calibration space
		var Matrix hmd, rightHand, leftHand
		if actor.getVRHMD().isAttached()
			hmd = actor.getVRHMD().getMatrixPlayspace()
		end
		if actor.getVRRightHand().isAttached()
			rightHand = actor.getVRRightHand().getMatrixPlayspace()
		end
		if actor.getVRLeftHand().isAttached()
			leftHand = actor.getVRLeftHand().getMatrixPlayspace()
		end
		
		// for calibration we need these three for the time being
		if hmd == null or rightHand == null or leftHand == null
			resetCalibration()
			return
		end
		
		// hand controller devices have their pose beyond the controller tip which is
		// the wrong location to use for calibration. to fix this find the tracker slots
		// matching the hand controllers. there the user stored the offset required to
		// moved the calibration point to a sane location
		var String deviceID = actor.getVRRightHand().getInputDevice().getID()
		var CharacterTrackerSlot slot = pTrackerSlots.find(block CharacterTrackerSlot each
			return each.getInputDeviceID().equals(deviceID)
		end)
		if slot != null
			rightHand = slot.getOffsetMatrix() * rightHand
		end
		
		deviceID = actor.getVRLeftHand().getInputDevice().getID()
		slot = pTrackerSlots.find(block CharacterTrackerSlot each
			return each.getInputDeviceID().equals(deviceID)
		end)
		if slot != null
			leftHand = slot.getOffsetMatrix() * leftHand
		end
		
		// calculate calibration matrix transforming tracked positions into calibration
		// coordinate system. hmd looks forwards, hands are aligned along the X axis and
		// body is centered along X and Z direction. also apply scaling from actor
		// shoulder level to character shoulder level
		var Vector posRightHand = rightHand.getPosition()
		var Vector posLeftHand = leftHand.getPosition()
		
		var Vector centerHands = (posRightHand + posLeftHand) * 0.5
		
		var Vector dirHands = (posRightHand - posLeftHand).compSelect(true, false, true).normalize()
		var float rotHands = -DEMath.atan2(dirHands.getX(), dirHands.getZ())
		
		var Vector posHMD = hmd.getPosition()
		var float turnHMD = hmd.getEulerAngles().getY()
		var Matrix hmdNorm = Matrix.newRT(Vector.new(0, turnHMD, 0), posHMD)
		
// 		var Vector posNeck = hmdNorm * Vector.new(0, -0.2, -0.1)
		var Vector posNeck = hmdNorm * Vector.new(0, -0.15, -0.1)
		
		var Vector centerBody = posNeck.compSelect(true, false, true)
		var float turnBody = turnHMD
		
		if false
			centerBody = centerHands.compSelect(true, false, true)
			turnBody = rotHands + 90
		end
		
		//pCalibrateScale = pShoulderLevel / actorProfile.getShoulderLevel()
		pCalibrateScale = pShoulderLevel / centerHands.getY()
		pCalibrateCenter = -centerBody
		pCalibrateTurn = -turnBody
		updateCalibrateMatrix()
		
		GameApp.getGameApp().getConsole().addMessage("CharacterConfiguration.calibrate: posHMD=" \
			+ posHMD + " posRightHand=" + posRightHand + " posLeftHand=" + posLeftHand)
		GameApp.getGameApp().getConsole().addMessage("CharacterConfiguration.calibrate: turnHMD=" \
			+ turnHMD + " posNeck=" + posNeck)
		GameApp.getGameApp().getConsole().addMessage("CharacterConfiguration.calibrate: centerHands=" \
			+ centerHands + " rotHands=" + rotHands + " scale=" + pCalibrateScale \
			+ " turnBody=" + turnBody + " centerBody=" + centerBody)
		
		// calibrate tracker slots using the calibration matrix
		pTrackerSlots.forEach(block CharacterTrackerSlot each
			each.calibrate(actor, pCalibrateMatrix)
		end)
		
		// calibrate motion transfers using the calibrated trackers slots
		var Component component = createCalibrationComponent()
		
		pMotionTransfers.forEach(block MotionTransfer each
			each.calibrate(this, actorProfile, actor, component)
		end)
		
		// save calibration
		pIsCalibrated = true
		
		// calibration finished
		pProfile.notifyCalibrated(this)
	end
	
	
	
	/** Create element class. Caller has to start preloading to use it. */
	public func BaseVRActorClass createElementClass()
		var BaseVRActorClass eclass = BaseVRActorClass.new(\
			"Character" + GameApp.getGameApp().getNextElementClassID().nextID())
		
		eclass.getAIAction().setActionFactory(Actions.AADefault.Factory.new())
		
		try
// 			eclass.getVRRightHand().getShowHand().setValue(false)
// 			eclass.getVRLeftHand().getShowHand().setValue(false)
			
			ECBCharacterConfiguration.new(eclass, this)
			
			var ECBMoCapAnimator mocapAnimator = ECBMoCapAnimator.new(eclass)
			mocapAnimator.getAnimation().setPath(pProfile.getAppearance().getPathAnimation())
			mocapAnimator.getAnimation().setAnimation(pProfile.getAppearance().getAnimation())
			
			ECBRecordAnimation.new(eclass)
			
			pAnimatorDefinition = AnimatorDefinition.new("")
			
			if pMoveCalibrate.empty()
				var ADRuleStateManipulator rule = ADRuleStateManipulator.new()
				rule.setName("Reset State")
				rule.setEnablePosition(true)
				rule.setEnableSize(true)
				pAnimatorDefinition.addRule(rule)
				
			else
				var ADRuleAnimation rule = ADRuleAnimation.new()
				rule.setName("Reset State")
				rule.setMoveName(pMoveCalibrate)
				pAnimatorDefinition.addRule(rule)
			end
			
			pProfile.getAppearance().initElementClass(eclass)
			
			// add tracker slots. each slot adds two controllers (position, rotation)
			pTrackerSlots.forEach(block CharacterTrackerSlot each
				each.initElementClass(eclass, pAnimatorDefinition)
			end)
			
			// add motion capture behaviors
			pMotionTransfers.forEach(block MotionTransfer each
				each.initElementClass(this, eclass)
			end)
			
			// finalize motion capture animator
			var Animator animator = Animator.new()
			pAnimatorDefinition.buildAnimator(animator)
			pAnimatorDefinition.debug(GameApp.getGameApp().getConsole())
			mocapAnimator.setAnimator(animator)
			
		catch Exception e
			eclass.dispose()
			throw
		end
		
		return eclass
	end
	
	/**
	 * Create stub element. If no element class is present or it is still preloading
	 * null is returned.
	 */
	public func StubElement createStubElement()
		var StubElement stub
		if pElementClass != null and not isElementClassPreloading()
			stub = StubElement.new(getElementClass(), GameApp.getGameApp().getIDGenerator().nextID())
			// sometimes it can be required to set stub properties
		end
		return stub
	end
	
	
	
	/** Dispose old element class kept to avoid reloading resources. */
	protected func void disposeOldElementClass()
		if pOldElementClass != null
			pOldElementClass.dispose()
			pOldElementClass = null
		end
	end
	
	/** Create calibration component. */
	protected func Component createCalibrationComponent()
		var CharacterAppearance appearance = pProfile.getAppearance()
		
		var Animator animator = Animator.new()
		animator.setRig(appearance.getRig())
		animator.setAnimation(appearance.getAnimation())
		
		if pMoveCalibrate.empty()
			var ARStateManipulator rule = ARStateManipulator.new()
			rule.setEnablePosition(true)
			rule.setEnableSize(true)
			animator.addRule(rule)
			
		else
			var ARAnimation rule = ARAnimation.new()
			rule.setMoveName(pMoveCalibrate)
			animator.addRule(rule)
		end
		
		var AnimatorInstance ainst = AnimatorInstance.new()
		ainst.setAnimator(animator)
		
		var Component component = Component.new(null, null)
		component.setRig(appearance.getRig())
		ainst.setComponent(component)
		
		ainst.applyDirect()
		component.updateBones()
		
		return component
	end
end
