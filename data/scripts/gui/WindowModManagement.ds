/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Gui
pin Dragengine.Gui
pin Dragengine.Gui.Layouts
pin Dragengine.Services.Mods
pin Dragengine.Gui.Events
pin Dragengine.Gui.Designers
pin Dragengine.Utils

/**
 * \brief Window managing modifications.
 */
class WindowModManagement extends WindowDialog
	/**
	 * \brief View category.
	 */
	enum ViewCategory
		/**
		 * \brief Browse mods.
		 */
		browseMods
		
		/**
		 * \brief Subscribed mods.
		 */
		subscribedMods
		
		/**
		 * \brief Mod transfer.
		 */
		transfer
	end
	
	/**
	 * \brief View category changed listener.
	 */
	class ViewCategoryChanged extends DefaultListModelListener
		var WindowModManagement pWindow
		
		func new(WindowModManagement window)
			pWindow = window
		end
		
		func void selectionChanged(ListModel listModel)
			pWindow.onViewCategoryChanged()
		end
	end
	
	/**
	 * \brief Entry in a mod listing.
	 * 
	 * Stores ServiceModInfo, ServiceModStatus and cached resources.
	 */
	class ModListEntry
		/**
		 * \brief Gallery image.
		 */
		class GalleryImage
			/**
			 * \brief Modification gallery image.
			 */
			public var ServiceImage info
			
			/**
			 * \brief Cached original image or null.
			 */
			public var Image imageOriginal
			
			/**
			 * \brief Thumbnail.
			 */
			public var ServiceImage.Thumbnail thumbnail
			
			/**
			 * \brief Cached thumbnail or null.
			 */
			public var Image imageThumbnail
			
			/**
			 * \brief Create new instance of class GalleryImage.
			 */
			func new(ServiceImage info)
				this.info = info
			end
		end
		
		
		/**
		 * \brief Modification information.
		 */
		public var ServiceModInfo info
		
		/**
		 * \brief Modification status or null.
		 */
		public var ServiceModStatus status
		
		/**
		 * \brief Cached logo image or null.
		 */
		public var Image logo
		
		/**
		 * \brief Gallery images as Array of GalleryImage or null if not loaded.
		 */
		public var Array galleryImages
		
		
		/**
		 * \brief Create new instance of class ModListEntry.
		 */
		func new(ServiceModInfo info, ServiceModStatus status)
			this.info = info
			this.status = status
		end
	end
	
	/**
	 * \brief List model renderer for modification entries in the browse list.
	 */
	class ModListElementRenderer implements ListElementRenderer
		/**
		 * \brief Widget displaying modification information in the list.
		 */
		class ModWidget extends Panel
			/**
			 * \brief Listener updating logo image once loaded.
			 */
			class LoadLogoListener extends DefaultServiceModsListener
				var ModWidget pWidget
				var ModListEntry pEntry
				
				func new(ModWidget widget, ModListEntry entry)
					pWidget = widget
					pEntry = entry
				end
				
				func void onLoadResource(ServiceMods service, String url, Object resource, Exception exception)
					if exception != null
						GameApp.getApp().getConsole().addError("Load logo failed: " + url, exception)
						return
					end
					
					pEntry.logo = resource cast Image
					
					if pWidget.getEntry() == pEntry
						pWidget.update()
					end
				end
			end
			
			
			var TextModel pModelName, pModelDownloads, pModelSize, pModelRating, pModelSubscribed
			var DisplayImage pImageLogo
			var Panel pPanelInfo
			var DisplayIcon pIconDownloads, pIconSize, pIconRating
			var Label pLabelName, pLabelDownloads, pLabelSize, pLabelRating, pLabelSubscribed
			var String pDesignerSelectorBase, pDesignerSelectorSuffix
			var ModListEntry pEntry
			
			
			/**
			 * \brief Create widget displaying modification information in the list.
			 */
			func new(String designerSelector) super(FlowLayout.new(LayoutAxis.y))
				pModelName = DefaultTextModel.new()
				pModelDownloads = DefaultTextModel.new()
				pModelSize = DefaultTextModel.new()
				pModelRating = DefaultTextModel.new()
				pModelSubscribed = DefaultTextModel.new()
				
				runWhileBlockingLayout(block
					createContent()
					setAllDesignerSelectors(designerSelector, "")
				end)
			end
			
			/**
			 * \brief Dispose of widget.
			 */
			func void dispose()
				pModelName = null
				pModelDownloads = null
				pModelSize = null
				pModelRating = null
				pModelSubscribed = null
				pImageLogo = null
				pPanelInfo = null
				pIconDownloads = null
				pIconSize = null
				pIconRating = null
				pLabelName = null
				pLabelDownloads = null
				pLabelSize = null
				pLabelRating = null
				pLabelSubscribed = null
				super.dispose()
			end
			
			
			/**
			 * \brief Modification list entry shown in the widget.
			 */
			func ModListEntry getEntry()
				return pEntry
			end
			
			/**
			 * \brief Set all designer selectors.
			 */
			func void setAllDesignerSelectors(String selector, String suffix)
				pDesignerSelectorBase = selector
				pDesignerSelectorSuffix = suffix
				
				runWhileBlockingLayout(block
					setDesignerSelector("Panel." + selector + suffix)
					
					pImageLogo.setDesignerSelector("Image." + selector + suffix)
					pPanelInfo.setDesignerSelector("Panel." + selector + ".Info" + suffix)
					
					var String dslab = "Label." + selector
					var String dsico = "Icon." + selector
					pLabelName.setDesignerSelector(dslab + ".Name" + suffix)
					pIconDownloads.setDesignerSelector(dsico + ".Downloads" + suffix)
					pLabelDownloads.setDesignerSelector(dslab + ".Downloads" + suffix)
					pIconSize.setDesignerSelector(dsico + ".Size" + suffix)
					pLabelSize.setDesignerSelector(dslab + ".Size" + suffix)
					pIconRating.setDesignerSelector(dsico + ".Rating" + suffix)
					pLabelRating.setDesignerSelector(dslab + ".Rating" + suffix)
					
					pLabelSubscribed.setDesignerSelector(dslab + \
						(pEntry != null and pEntry.status != null if ".Subscribed" else ".Unsubscribed") + suffix)
				end)
				doLayoutIfBlocked()
			end
			
			/**
			 * \brief Set modification entry to show.
			 */
			func void setEntry(ServiceMods service, ModListEntry entry)
				if entry == pEntry
					update()
					return
				end
				
				pEntry = entry
				
				var ServiceModInfo info = entry.info
				
				if entry.logo == null and info.logo != null
					entry.logo = info.logo.image
					
					if entry.logo == null and service != null
						var String url = findLoadLogoImage(info.logo)
						if url != null
							service.loadResource(url, LoadLogoListener.new(this, entry))
						end
					end
				end
				
				update()
			end
			
			/**
			 * \brief Update content from current modification entry.
			 */
			func void update()
				var FormattingHelper fh = FormattingHelper.new()
				var ServiceModInfo info = pEntry.info
				runWhileBlockingLayout(block
					pImageLogo.setImage(pEntry.logo)
					pModelName.setText(info.name != null if info.name else "?")
					pModelDownloads.setText(fh.formatCount(info.stats != null if info.stats.downloadCount else 0))
					pModelSize.setText(fh.formatSize(info.latestRelease != null if info.latestRelease.filesize else 0))
					pModelRating.setText(fh.formatRating(info.stats != null if info.stats.ratingAverage else 0))
					updateStatusInfo()
				end)
				doLayoutIfBlocked()
			end
			
			/**
			 * \brief Update modification status information.
			 */
			func void updateStatusInfo()
				var bool subscribed = pEntry.status != null
				
				runWhileBlockingLayout(block
					pModelSubscribed.setText(subscribed if "Subscribed" else "Not Subscribed")
					pLabelSubscribed.setDesignerSelector("Label." + pDesignerSelectorBase\
						+ (subscribed if ".Subscribed" else ".Unsubscribed")\
						+ pDesignerSelectorSuffix)
				end)
				doLayoutIfBlocked()
			end
			
			/**
			 * \brief Find URL of best matching logo image to load.
			 */
			func String findLoadLogoImage(ServiceImage image)
				var Point reqSize = pImageLogo.getMinimumSize()
				
				if image.thumbnails != null
					var Array found = image.thumbnails.collect(block ServiceImage.Thumbnail each
						return each.size >= reqSize
					end).sorted(block ServiceImage.Thumbnail a, ServiceImage.Thumbnail b
						return a.size.compare(b)
					end)
					if found.getCount() > 0
						return (found.getAt(0) cast ServiceImage.Thumbnail).url
					end
				end
				
				return image.url
			end
			
			/**
			 * \brief Create content.
			 */
			protected func void createContent()
				pImageLogo = DisplayImage.new(null, RepeatMode.stretchRatio)
				addWidget(pImageLogo)
				
				pPanelInfo = Panel.new(FlowLayout.new(LayoutAxis.y, 10), block Panel p
					pLabelName = Label.new(pModelName)
					p.addWidget(pLabelName)
					
					p.addWidget(Panel.new(FlowLayout.new(LayoutAxis.x, 15), block Panel p2
						p2.addWidget(Panel.new(FlowLayout.new(LayoutAxis.x), block Panel p3
							pIconDownloads = DisplayIcon.new(Image.new("/shareddata/guithemes/modern/icons/16/download.webp"))
							p3.addWidget(pIconDownloads)
							
							pLabelDownloads = Label.new(pModelDownloads)
							p3.addWidget(pLabelDownloads)
						end))
						
						p2.addWidget(Panel.new(FlowLayout.new(LayoutAxis.x), block Panel p3
							pIconSize = DisplayIcon.new(Image.new("/shareddata/guithemes/modern/icons/16/filesize.webp"))
							p3.addWidget(pIconSize)
							
							pLabelSize = Label.new(pModelSize)
							p3.addWidget(pLabelSize)
						end))
						
						p2.addWidget(Panel.new(FlowLayout.new(LayoutAxis.x), block Panel p3
							pIconRating = DisplayIcon.new(Image.new("/shareddata/guithemes/modern/icons/16/rating.webp"))
							p3.addWidget(pIconRating)
							
							pLabelRating = Label.new(pModelRating)
							p3.addWidget(pLabelRating)
						end))
					end))
					
					pLabelSubscribed = Label.new(pModelSubscribed)
					p.addWidget(pLabelSubscribed)
				end)
				addWidget(pPanelInfo)
			end
		end
		
		
		var ServiceMods pServiceMods
		var String pDesignerSelector
		var ModListEntry pDefaultModEntry
		var Point pDefaultMinimumSize
		
		
		/**
		 * \brief Create modification list model renderer.
		 * 
		 * Uses designer selector "ListRenderer.WindowModManagement.Mod".
		 */
		func new(ServiceMods serviceMods) this(serviceMods, "ListRenderer.WindowModManagement.Mod")
		end
		
		/**
		 * \brief Create modification list model renderer.
		 */
		func new(ServiceMods serviceMods, String designerSelector)
			pServiceMods = serviceMods
			pDesignerSelector = designerSelector
			pDefaultMinimumSize = Point.new()
			
			pDefaultModEntry = ModListEntry.new(ServiceModInfo.new(), null)
			pDefaultModEntry.info.descriptionText = "X"
			pDefaultModEntry.info.id = ""
			pDefaultModEntry.info.name = "X"
			pDefaultModEntry.info.stats = ServiceModStats.new()
			pDefaultModEntry.info.stats.downloadCount = 0
			pDefaultModEntry.info.stats.ratingWeighted = 1
			pDefaultModEntry.info.latestRelease = ServiceModRelease.new()
			pDefaultModEntry.info.latestRelease.filesize = 1
		end
		
		
		
		/**
		 * \brief Designer selector.
		 */
		func String getDesignerSelector()
			return pDesignerSelector
		end
		
		/**
		 * \brief Default modification entry to use to measure default size.
		 */
		func ModListEntry getDefaultModEntry()
			return pDefaultModEntry
		end
		
		/**
		 * \brief Minimum size to use unless default element is larger.
		 */
		public func Point getDefaultMinimumSize()
			return pDefaultMinimumSize
		end
		
		/**
		 * \brief Set minimum size to use unless default element is larger.
		 */
		public func void setDefaultMinimumSize(Point size)
			if size == null
				throw ENullPointer.new("size")
			end
			pDefaultMinimumSize = Point.new().largest(size)
		end
		
		
		
		/**
		 * \brief Create widget representing modification in the list box.
		 */
		func Widget createRenderer(ListBox listBox)
			return ModWidget.new(pDesignerSelector)
		end
		
		/**
		 * Update widget representing modification in the list box.
		 */
		func void updateRenderer(ListBox listBox, Widget renderer, Object element, bool selected, bool focused)
			var ModListEntry entry = element cast ModListEntry
			if entry == null
				entry = pDefaultModEntry
			end
			
			var String selector = pDesignerSelector, suffix = ""
			if selected
				suffix = ".Selected"
			end
			
			var ModWidget widget = renderer cast ModWidget
			widget.setEntry(pServiceMods, entry)
			widget.setAllDesignerSelectors(selector, suffix)
		end
		
		/**
		 * Default size of widget representing modification in the list box.
		 */
		func Point getDefaultSize(ListBox listBox)
			// to properly measure the size a Container instance is created with the gui theme
			// from the listBox. if the gui theme would be assigned directly to the renderer
			// potentially use of gui theme selectors are skipped causing strange to find
			// errors. the empty widget designer ensures the container has no padding nor any
			// other unwanted designer parameters applied
			var Container container = Container.new(BoxLayout.new(LayoutAxis.y), block Container c
				c.setDesigner(DefaultWidgetDesigner.new())
				c.setGuiTheme(listBox.getGuiTheme())
				
				var Widget renderer = createRenderer(listBox)
				c.addWidget(renderer)
				updateRenderer(listBox, renderer, pDefaultModEntry, false, false)
			end)
			container.doLayout()
			
			var Point size = container.getMinimumSize()
			container.dispose()
			return size.largest(pDefaultMinimumSize)
		end
	end
	
	/**
	 * \brief Mod management event listener.
	 */
	class ModEventListener extends DefaultServiceModsListener
		var WindowModManagement pWindow
		
		func new(WindowModManagement window)
			pWindow = window
		end
		
		func void onGetTags(ServiceMods service, Array categories, Exception exception)
			if exception == null
				pWindow.updateSearchTagCategories(categories)
			end
		end
		
		func void onGetModInfo(ServiceMods service, String modId, ServiceModInfo info, Exception exception)
			if info != null
				pWindow.updateModEntry(modId, info)
			end
		end
		
		func void onSubscribeMod(ServiceMods service, String modId, Exception exception)
			if exception == null
				pWindow.updateModEntry(modId, null)
			end
		end
		
		func void onUnsubscribeMod(ServiceMods service, String modId, Exception exception)
			if exception == null
				pWindow.updateModEntry(modId, null)
			end
		end
		
		func void onModManagement(ServiceMods service, ServiceMods.ManagementEvent event,\
		String modId, ServiceModProgress progress, Exception exception)
			if progress != null
				pWindow.updateModEntryProgress(modId, progress)
			end
		end
	end
	
	/**
	 * \brief Search mods listener.
	 */
	class SearchModsListener extends DefaultServiceModsListener
		var WindowModManagement pWindow
		
		func new(WindowModManagement window)
			pWindow = window
		end
		
		func void onListMods(ServiceMods service, Array mods, Exception exception)
			pWindow.onSearchResult(this, mods, exception)
		end
	end
	
	/**
	 * \brief Show mod details when clicking on a list item.
	 */
	class ClickedModDetails extends ClickedActionListener
		var WindowModManagement pWindow
		var ListBox pListBox
		
		func new(WindowModManagement window, ListBox listBox)
			pWindow = window
			pListBox = listBox
		end
		
		func void onAction()
			var int index = pListBox.getElementAt(pListBox.getLocalMouseLocation())
			if index != -1
				pWindow.showModInfo(pListBox.getModel().getAt(index) cast ModListEntry)
			end
		end
	end
	
	/**
	 * \brief Start searching if selection changed.
	 */
	class SearchSelectionChanged extends DefaultListModelListener
		var WindowModManagement pWindow
		
		func new(WindowModManagement window)
			pWindow = window
		end
		
		func void selectionChanged(ListModel listModel)
			pWindow.searchMods()
		end
	end
	
	/**
	 * \brief Start searching if toggle changed.
	 */
	class SearchToggleChanged extends DefaultToggleModelListener
		var WindowModManagement pWindow
		
		func new(WindowModManagement window)
			pWindow = window
		end
		
		func void toggledChanged(ToggleModel model)
			pWindow.searchMods()
		end
	end
	
	/**
	 * \brief Interface for search tag categories.
	 */
	interface SearchTagCategory
		/**
		 * \brief Create and add widgets to container.
		 */
		func void createWidgets(Panel container)
		
		/**
		 * \brief Update filter with current category tag state.
		 */
		func void updateFilter(ServiceModFilter filter)
		
		/**
		 * \brief Reset tag category to initial state.
		 */
		func void reset()
	end
	
	/**
	 * \brief Single selection search category using a ComboBox.
	 */
	class SearchCategoryComboBox implements SearchTagCategory
		var WindowModManagement pWindow
		var ServiceModTagCategory pCategory
		var DefaultListModel pModel
		
		func new(WindowModManagement window, ServiceModTagCategory category)
			pWindow = window
			pCategory = category
			
			var String lang = TranslationManager.get().getActive().getIdentifier()
			var String text
			
			pModel = DefaultListModel.new()
			pModel.add(window.translateEntry("UI.ModManagement.Value.NoTagSelected").toUTF8())
			category.tags.forEach(block ServiceModTagCategory.Tag each
				text = each.name
				if each.nameTranslations != null
					text = each.nameTranslations.getAt(lang, text) cast String
				end
				pModel.add(text)
			end)
			
			pModel.addListener(SearchSelectionChanged.new(window))
		end
		
		func void createWidgets(Panel container)
			var String lang = TranslationManager.get().getActive().getIdentifier()
			var String text = pCategory.name
			if pCategory.nameTranslations != null
				text = pCategory.nameTranslations.getAt(lang, text) cast String
			end
			
			container.addWidget(Panel.new(FlowLayout.new(LayoutAxis.y), block Panel p
				p.setDesignerSelector("Panel.WindowModManagement.Group.Search.TagCategory.Single")
				p.setTitle(text + ":")
				
				var ComboBox comboBox = pWindow.createComboBox(pModel, DefaultListElementRenderer.new(), ".Tags")
				comboBox.setToolTip("@UI.ModManagement.Tags.ToolTip")
				p.addWidget(comboBox)
			end))
		end
		
		func void updateFilter(ServiceModFilter filter)
			var int selection = pModel.getSelected()
			if selection > 0
				filter.withTags.add((pCategory.tags.getAt(DEMath.max(selection - 1, 0)) cast ServiceModTagCategory.Tag).id)
			end
		end
		
		func void reset()
			pModel.setSelected(0)
		end
	end
	
	/**
	 * \brief Multiple selection search category using a CheckBox.
	 */
	class SearchCategoryCheckBox implements SearchTagCategory
		var WindowModManagement pWindow
		var ServiceModTagCategory pCategory
		var Array pModels
		
		func new(WindowModManagement window, ServiceModTagCategory category)
			pWindow = window
			pCategory = category
			
			var DefaultToggleModel model
			pModels = Array.new(category.tags.map(block ServiceModTagCategory.Tag each
				model = DefaultToggleModel.new()
				model.addListener(SearchToggleChanged.new(window))
				return model
			end))
		end
		
		func void createWidgets(Panel container)
			var String lang = TranslationManager.get().getActive().getIdentifier()
			var String text = pCategory.name
			if pCategory.nameTranslations != null
				text = pCategory.nameTranslations.getAt(lang, text) cast String
			end
			
			var CheckBox checkBox
			
			container.addWidget(Panel.new(FlowLayout.new(LayoutAxis.y), block Panel p
				p.setDesignerSelector("Panel.WindowModManagement.Group.Search.TagCategory.Multiple")
				p.setTitle(text + ":")
				
				pCategory.tags.forEach(block int index, ServiceModTagCategory.Tag each
					text = each.name
					if each.nameTranslations != null
						text = each.nameTranslations.getAt(lang, text) cast String
					end
					
					checkBox = pWindow.createCheckBox(text, pModels.getAt(index) cast ToggleModel, ".Tags")
					checkBox.setToolTip("@UI.ModManagement.Tags.ToolTip")
					p.addWidget(checkBox)
				end)
			end))
		end
		
		func void updateFilter(ServiceModFilter filter)
			pCategory.tags.forEach(block int index, ServiceModTagCategory.Tag each
				if (pModels.getAt(index) cast ToggleModel).getToggled()
					filter.withTags.add(each.id)
				end
			end)
		end
		
		func void reset()
			pModels.forEach(block ToggleModel each
				each.setToggled(false)
			end)
		end
	end
	
	
	
	var DefaultListModel pModelViewCategory
	var DefaultListModel pModelMods
	var ListBox pListMods
	var Button pButtonSearchMore
	var DefaultTextModel pModelSearchName
	var DefaultListModel pModelSortBy
	var Panel pPanelTags, pPanelSearchName, pPanelSearchSort
	var ServiceMods pServiceMods
	var ServiceModsFeatures pServiceModFeatures
	var SearchModsListener pSearchModsListener
	var Dictionary pSubscribedMods, pOrgSubscribedMods, pSystemMods
	var ServiceModFilter pSearchFilter
	var CodecPropertyString pCodecPropertyString
	var Array pSearchTagCategories
	var bool pPreventSearch
	var ModEventListener pModEventListener
	
	
	/**
	 * Create window managing modifications
	 */
	func new(Window window, ServiceMods serviceMods)
		pServiceMods = serviceMods
		pServiceModFeatures = serviceMods.getModsFeatures()
		pCodecPropertyString = CodecPropertyString.new()
		pSearchTagCategories = Array.new()
		
		pModelViewCategory = DefaultListModel.new()
		pModelViewCategory.add(ViewCategory.browseMods)
		pModelViewCategory.add(ViewCategory.subscribedMods)
		pModelViewCategory.add(ViewCategory.transfer)
		pModelViewCategory.setSelectedElement(ViewCategory.browseMods)
		
		pModelMods = DefaultListModel.new()
		pModelSearchName = DefaultTextModel.new()
		pSubscribedMods = Dictionary.new()
		pSystemMods = Dictionary.new()
		
		pModelSortBy = DefaultListModel.new()
		pModelSortBy.add(ServiceModFilter.SortField.nameAscending)
		pModelSortBy.add(ServiceModFilter.SortField.nameDescending)
		pModelSortBy.add(ServiceModFilter.SortField.rating)
		pModelSortBy.add(ServiceModFilter.SortField.subscriberCount)
		pModelSortBy.add(ServiceModFilter.SortField.downloadsTotal)
		pModelSortBy.add(ServiceModFilter.SortField.downloadsToday)
		pModelSortBy.add(ServiceModFilter.SortField.dateUpdated)
		pModelSortBy.add(ServiceModFilter.SortField.dateMarkedLive)
		pModelSortBy.setSelectedElement(ServiceModFilter.SortField.rating)
		
		runWhileBlockingLayout(block
			setGuiTheme(window.getGuiTheme())
			setTitle("@UI.Modifications")
			setDesignerSelector("Window.Dialog.Modifications")
			setSize(window.getDesktop().getContainerSize() - Point.new(100, 100))
			
			createContent()
		end)
		doLayout()
		show(window, false, WindowModal.Placement.desktop)
		
		pModelSortBy.addListener(SearchSelectionChanged.new(this))
		
		pModEventListener = ModEventListener.new(this)
		serviceMods.addModsListener(pModEventListener)
		
		updateSubscribedMods()
		pOrgSubscribedMods = Dictionary.new(pSubscribedMods)
		updateSystemMods()
		
		serviceMods.getTags(null)
		searchMods(ServiceModFilter.new())
		
		pModelViewCategory.addListener(ViewCategoryChanged.new(this))
	end
	
	/** Dispose of window. */
	func void dispose()
		if pModEventListener != null
			pServiceMods.removeModsListener(pModEventListener)
			pModEventListener = null
		end
		
		pModelViewCategory = null
		pModelMods = null
		pListMods = null
		pButtonSearchMore = null
		pModelSearchName = null
		pModelSortBy = null
		pPanelTags = null
		pPanelSearchName = null
		pPanelSearchSort = null
		pSearchTagCategories = null
		
		pSearchModsListener = null
		pServiceMods = null
		
		super.dispose()
	end
	
	
	
	/**
	 * \brief Servide mods.
	 */
	func ServiceMods getServiceMods()
		return pServiceMods
	end
	
	/**
	 * \brief Cached service mods features.
	 */
	func ServiceModsFeatures getServiceModsFeatures()
		return pServiceModFeatures
	end
	
	/**
	 * \brief Active view category
	 */
	func ViewCategory getViewCategory()
		return pModelViewCategory.getSelectedElement() cast ViewCategory
	end
	
	/**
	 * \brief Search filter.
	 */
	func ServiceModFilter getSearchFilter()
		return pSearchFilter
	end
	
	
	/**
	 * \brief Update dictionary of subscribed modifications.
	 */
	func void updateSubscribedMods()
		pSubscribedMods = pServiceMods.getSubscribedMods()
	end
	
	/**
	 * \brief Update dictionary of system modifications.
	 */
	func void updateSystemMods()
		pSystemMods = pServiceMods.getSystemMods()
	end
	
	/**
	 * \brief Index of ModListEntry matching id.
	 */
	func int indexOfModListEntry(String modId)
		var int i, count = pModelMods.getCount()
		var ModListEntry entry
		
		for i = 0 to count
			entry = pModelMods.getAt(i) cast ModListEntry
			if entry.info.id.equals(modId)
				return i
			end
		end
		
		return -1
	end
	
	/**
	 * \brief Search for modifications.
	 * 
	 * Builds search filter from current widget states then calls
	 * \ref #searchMods(ServiceModFilter).
	 */
	func void searchMods()
		if pPreventSearch
			return
		end
		
		var ServiceModFilter filter = ServiceModFilter.new()
		
		filter.matchingName = Set.newFrom(pCodecPropertyString.decodeStringList(pModelSearchName.getText()))
		filter.sortField = pModelSortBy.getSelectedElement() cast ServiceModFilter.SortField
		filter.withTags = Set.new()
		pSearchTagCategories.forEach(block SearchTagCategory each
			each.updateFilter(filter)
		end)
		
		if getViewCategory() == ViewCategory.subscribedMods
			filter.withIds = Set.newFrom(pSubscribedMods.getKeys())
		end
		
		searchMods(filter)
	end
	
	/**
	 * \brief Search for modifications.
	 * 
	 * Clears the list and starts searching for the first page of modifications.
	 */
	func void searchMods(ServiceModFilter filter)
		pSearchFilter = ServiceModFilter.new(filter)
		pModelMods.removeAll()
		pButtonSearchMore.setEnabled(false)
		pSearchModsListener = SearchModsListener.new(this)
		pServiceMods.listAllMods(filter, pSearchModsListener)
	end
	
	/**
	 * \brief Continue searching modifications.
	 */
	func void searchMoreMods()
		if pSearchFilter == null or pSearchModsListener != null
			return
		end
		
		pButtonSearchMore.setEnabled(false)
		pSearchModsListener = SearchModsListener.new(this)
		pServiceMods.listAllMods(pSearchFilter, pSearchModsListener)
	end
	
	/**
	 * \brief Clear search parameters then search again.
	 */
	func void clearSearchParameters()
		try
			pPreventSearch = true
			pModelSearchName.setText("")
			pPanelTags.runWhileBlockingLayout(block
				pSearchTagCategories.forEach(block SearchTagCategory each
					each.reset()
				end)
			end)
			pPanelTags.doLayoutIfBlocked()
			pPreventSearch = false
			
		catch Exception e
			pPreventSearch = false
			throw
		end
		
		searchMods()
	end
	
	/**
	 * \brief Show modification information in a new window.
	 */
	func void showModInfo(ModListEntry entry)
		WindowModManagementMod.new(this, pServiceMods, entry, WindowDialog.BlockResultListener.new(block Object results
			var int index = pModelMods.indexOf(entry)
			if index != -1
				pModelMods.notifyContentChanged(index, index)
			end
		end))
	end
	
	/**
	 * \brief Check for modification changes and activate mods.
	 * 
	 * If there are no changes nothing is done. If there are changes activates the modifications
	 * then checks for subscribed and unsubscribed modifications. Depending on the changes do
	 * an update on the respective data. If script changes are required ask for restarting.
	 */
	func void activateMods()
		var GameApp app = GameApp.getGameApp()
		
		pServiceMods.activateMods()
		
		var Array unsubscribed = pOrgSubscribedMods.getKeys().collect(block String each
			return not pSubscribedMods.has(each)
		end)
		var Array subscribed = pSubscribedMods.getKeys().collect(block String each
			return not pOrgSubscribedMods.has(each)
		end)
		var Array changed = subscribed
		
		if anyHasMatchingFiles(changed, "/scripts", Set.newWith("*.ds"))
			WindowDialog.question(this, "Mod Management",\
			"One or more modifications contains scripts. Restarting is required.", null,\
			Array.newWith(WindowDialog.ButtonConfiguration.new("Restart", true),\
				WindowDialog.ButtonConfiguration.new("Cancel", false)),\
			WindowDialog.BlockResultListener.new(block Object result
				Engine.restart("manageMods")
			end))
		end
		
		if subscribed.getCount() > 0 or unsubscribed.getCount() > 0
			app.reloadAfterModsChanged()
		end
	end
	
	/**
	 * Function anyHasMatchingFiles.
	 */
	protected func bool anyHasMatchingFiles(Array mods, String directory, Set patterns)
		return mods.find(block String each
			return pServiceMods.modHasMatchingFiles(each, directory, true, patterns)
		end) != null
	end
	
	
	/**
	 * \brief View category changed.
	 */
	func void onViewCategoryChanged()
		select getViewCategory()
		case ViewCategory.browseMods
			searchMods()
			
		case ViewCategory.subscribedMods
			searchMods()
			
		case ViewCategory.transfer
			
		end
	end
	
	/**
	 * \brief Search results retrieved from service provider.
	 * 
	 * For use by SearchModsListener only.
	 */
	func void onSearchResult(SearchModsListener listener, Array mods, Exception exception)
		if listener != pSearchModsListener
			return
		end
		
		pSearchModsListener = null
		pButtonSearchMore.setEnabled(true)
		
		if exception != null
			GameApp.getApp().getConsole().addError("onSearchResult", exception)
			WindowDialog.message(getWindow(), "Failure", exception.toString(), null, null, null)
			return
		end
		
		pModelMods.addAll(mods.map(block ServiceModInfo each
			return ModListEntry.new(each, pSubscribedMods.getAt(each.id, null) cast ServiceModStatus)
		end))
		
		var int count = pModelMods.getCount()
		if pSearchFilter.startIndex < pModelMods.getCount()
			pSearchFilter.startIndex = count
			
		else
			//WindowDialog.message(getWindow(), "Search Mods", "No more search results", null, null, null)
		end
		pButtonSearchMore.setEnabled(true)
	end
	
	/**
	 * Update modification list entry.
	 */
	func void updateModEntry(String modId, ServiceModInfo info)
		var int index = indexOfModListEntry(modId)
		if index == -1
			return
		end
		
		var ModListEntry entry = pModelMods.getAt(index) cast ModListEntry
		
		if info != null
			entry.info = info
		end
		
		updateSubscribedMods()
		entry.status = pSubscribedMods.getAt(modId, null) cast ServiceModStatus
		
		pModelMods.notifyContentChanged(index, index)
	end
	
	/**
	 * Update modification list entry progress.
	 */
	func void updateModEntryProgress(String modId, ServiceModProgress progress)
		var int index = indexOfModListEntry(modId)
		if index == -1
			return
		end
		
		// var ModListEntry entry = pModelMods.getAt(index) cast ModListEntry
		
		// TODO
		
		// pModelMods.notifyContentChanged(index, index)
	end
	
	
	/** Create window content. */
	protected func void createContent()
		var TextField textField
		var ComboBox comboBox
		var Viewport viewport
		
		setLayout(BorderLayout.new(10))
		
		// top: view buttons
		addWidget(Panel.new(FlowLayout.new(LayoutAxis.y, 10), block Panel p
			p.addWidget(Panel.new(FlowLayout.new(LayoutAxis.x, 5), block Panel p2
				p2.addWidget(createToggleButton("Available Mods", "Browse available modifications",\
					OptionGroupModel.newFor(pModelViewCategory, ViewCategory.browseMods),\
					".ViewCategory.BrowseMods"))
				
				p2.addWidget(createToggleButton("Subscribed Mods", "Browse subscribed modifications",\
					OptionGroupModel.newFor(pModelViewCategory, ViewCategory.subscribedMods),\
					".ViewCategory.SubscribedMods"))
				
				p2.addWidget(createToggleButton("Mods Transfer", "Modification transfer progress",\
					OptionGroupModel.newFor(pModelViewCategory, ViewCategory.transfer),\
					".ViewCategory.ModsTransfer"))
			end))
		end), BorderLayout.Area.top)
		
		// content: listing
		pListMods = ListBox.new(pModelMods, ModListElementRenderer.new(pServiceMods))
		pListMods.setDesignerSelector("ListBox.WindowModManagement.Mods")
		pListMods.setType(ListBox.Type.verticalWrap)
		pListMods.setNumberDisplayLines(1)
		pListMods.addMouseListener(ClickedModDetails.new(this, pListMods))
		addWidget(ScrollPanel.new(pListMods, ScrollPanel.Policy.hidden, ScrollPanel.Policy.visible), BorderLayout.Area.content)
		
		// right side: search parameters
		viewport = Viewport.new(Panel.new(FlowLayout.new(LayoutAxis.y), block Panel p
			// search button
			p.addWidget(createButton("@UI.ModManagement.Search", "@UI.ModManagement.Search.ToolTip",\
				".Search", BlockActionListener.new(block ActionEvent e
					searchMods()
				end)))
			
			// search name
			pPanelSearchName = Panel.new(FlowLayout.new(LayoutAxis.y), block Panel p2
				p2.setDesignerSelector("Panel.WindowModManagement.Group.Search.Name")
				p2.setTitle("@UI.ModManagement.SearchName")
				
				textField = createTextField(pModelSearchName, ".Search.Name", 20)
				textField.setToolTip("@UI.ModManagement.SearchName.ToolTip")
				p2.addWidget(textField)
				textField.addActionListener(BlockActionListener.new(block ActionEvent event
					searchMods()
				end))
			end)
			p.addWidget(pPanelSearchName)
			
			
			// sort by
			pPanelSearchSort = Panel.new(FlowLayout.new(LayoutAxis.y), block Panel p2
				p2.setDesignerSelector("Panel.WindowModManagement.Group.Search.SortBy")
				p2.setTitle("@UI.ModManagement.SortBy")
				
				var EnumListElementRenderer renderer = EnumListElementRenderer.new()
				renderer.setTranslationPrefix("UI.ModManagement.Enum.SortField.")
				comboBox = createComboBox(pModelSortBy, renderer, ".SortBy")
				comboBox.setToolTip("@UI.ModManagement.SortBy.ToolTip")
				p2.addWidget(comboBox)
			end)
			p.addWidget(pPanelSearchSort)
			
			// tags. will be filled once data has been retrieved from service
			pPanelTags = Panel.new(FlowLayout.new(LayoutAxis.y))
			p.addWidget(pPanelTags)
		end))
		viewport.setLayout(FlowLayout.new(LayoutAxis.y))
		addWidget(ScrollPanel.new(viewport, ScrollPanel.Policy.hidden, ScrollPanel.Policy.needed), BorderLayout.Area.right)
		
		// button line at bottom
		addWidget(Panel.new(CentrizedBoxLayout.new(LayoutAxis.x, 20), block Panel p
			pButtonSearchMore = createButton("@UI.ModManagement.SearchMore", "@UI.ModManagement.SearchMore.ToolTip",\
				".MoreResults", BlockActionListener.new(block ActionEvent e
					searchMoreMods()
				end))
			p.addWidget(pButtonSearchMore)
			
			p.addWidget(createButton("@UI.ModManagement.Close", "@UI.ModManagement.Close.ToolTip",\
				".Close", BlockActionListener.new(block ActionEvent e
					activateMods()
					close()
				end)))
		end ), BorderLayout.Area.bottom)
	end
	
	/**
	 * \brief Create search tag widgets.
	 */
	func void updateSearchTagCategories(Array categories)
		try
			pPreventSearch = true
			pPanelTags.runWhileBlockingLayout(block
				pPanelTags.removeAllWidgets()
				
				pSearchTagCategories.removeAll()
				categories.forEach(block ServiceModTagCategory category
					pSearchTagCategories.add(createTagCategory(category))
				end)
				
				pSearchTagCategories.forEach(block SearchTagCategory each
					each.createWidgets(pPanelTags)
				end)
			end)
			pPanelTags.doLayout()
			pPreventSearch = false
			
		catch Exception e
			pPreventSearch = false
			throw
		end
	end
	
	/**
	 * \brief Create service tag category.
	 */
	protected func SearchTagCategory createTagCategory(ServiceModTagCategory category)
		if category.multiSelection
			return SearchCategoryCheckBox.new(this, category)
		else
			return SearchCategoryComboBox.new(this, category)
		end
	end
	
	/**
	 * \brief Create button.
	 */
	func Button createButton(String text, String toolTip, String designerSelectorSuffix, ActionListener action)
		var Button button = Button.new(text, action)
		button.setDesignerSelector("Button.WindowModManagement" + designerSelectorSuffix)
		button.setToolTip(toolTip)
		return button
	end
	
	/**
	 * \brief Create toggle button.
	 */
	func ToggleButton createToggleButton(String text, String toolTip, ToggleModel model, String designerSelectorSuffix)
		var ToggleButton button = ToggleButton.new(model, text)
		button.setStickyToggled(true)
		button.setDesignerSelector("Button.WindowModManagement" + designerSelectorSuffix)
		button.setToolTip(toolTip)
		return button
	end
	
	/**
	 * \brief Create text field.
	 */
	func TextField createTextField(TextModel model, String designerSelectorSuffix, int displayCharCount)
		var TextField textField = TextField.new(model, displayCharCount)
		textField.setDesignerSelector("TextField.WindowModManagement" + designerSelectorSuffix)
		return textField
	end
	
	/**
	 * \brief Create combo box.
	 */
	func ComboBox createComboBox(ListModel model, ListElementRenderer renderer, String designerSelectorSuffix)
		var ComboBox comboBox = ComboBox.new(model, renderer)
		comboBox.setDesignerSelector("ComboBox.WindowModManagement" + designerSelectorSuffix)
		return comboBox
	end
	
	/**
	 * \brief Create check box.
	 */
	func CheckBox createCheckBox(String text, ToggleModel model, String designerSelectorSuffix)
		var CheckBox checkBox = CheckBox.new(model, text)
		checkBox.setDesignerSelector("CheckBox.WindowModManagement" + designerSelectorSuffix)
		return checkBox
	end
end
