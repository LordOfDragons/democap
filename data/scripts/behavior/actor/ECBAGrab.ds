/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2022, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Characters
pin Democap.Elements

pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * Actor behavior using grab spots.
 */
class ECBAGrab extends DefaultECBehavior
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		private var ECBAGrab pECBehavior
		private var ECBehaviorGrabber.Instance pGrabber
		private var ECBehaviorAttachSlot.Instance pAttachSlot
		private var ECBAPhysicsToucher.Instance pPhysicsToucher
		private var ECBGrabAttach.Instance pGrabAttach
		private var Collider pPhysicsGrabCollider
		private var ColliderConstraint pPhysicsGrabConstraint
		private var bool pTriggerPulled
		
		
		
		/** Create behavior instance. */
		public func new(ECBAGrab ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pGrabber = ecbehavior.grabber.instance(element)
			pAttachSlot = ecbehavior.attachSlot.instance(element)
			pPhysicsToucher = ecbehavior.physicsToucher.instance(element)
		end
		
		/** Dispose of behavior instance. */
		public func void dispose()
			pPhysicsGrabConstraint = null
			pPhysicsGrabCollider = null
			pGrabber = null
			pPhysicsToucher = null
			pAttachSlot = null
			pGrabAttach = null
			super.dispose()
		end
		
		
		
		public func ECBAGrab getECBehavior()
			return pECBehavior
		end
		
		public func ECBehaviorGrabber.Instance getGrabber()
			return pGrabber
		end
		
		public func ECBehaviorAttachSlot.Instance getAttachSlot()
			return pAttachSlot
		end
		
		public func ECBGrabAttach.Instance getGrabAttach()
			return pGrabAttach
		end
		
		public func ColliderConstraint getPhysicsGrabConstraint()
			return pPhysicsGrabConstraint
		end
		
		
		
		/** Start grabbing. Returns true if grab succeeded. */
		public func bool grab()
			var ECBehaviorGrabSpot.Instance grabSpot = pGrabber.closestTouchingGrabSpot()
			if grabSpot != null
				var BehaviorElement element = grabSpot.getElement()
				
				pGrabAttach = element.findInstance(block ECBGrabAttach.Instance each
					return tryGrabAttach(each)
				end) cast ECBGrabAttach.Instance
				if pGrabAttach != null
					return true
				end
			end
			
			var ECBAPhysicsToucher.TouchObject touchObject = pPhysicsToucher.closestTouchingObject()
			if touchObject != null
				if tryGrabAttach(touchObject)
					return true
				end
			end
			
			return false
		end
		
		/** Update grabbing. */
		public func void updateGrab()
		end
		
		/** Stop grabbing. */
		public func void ungrab()
			if pPhysicsGrabConstraint != null or pGrabAttach != null
				ungrabGrabAttach()
			end
		end
		
		/** Pull trigger. Returns true if processed or false otherwise. */
		public func bool triggerPull()
			if pGrabAttach != null or pPhysicsGrabConstraint != null
				return true
			end
			
			return false
		end
		
		/** Release trigger. */
		public func void triggerRelease()
			if pGrabAttach != null or pPhysicsGrabConstraint != null
			end
		end
		
		/** Menu button pressed. Returns true if processed or false otherwise. */
		public func bool menuPress()
			if pGrabAttach != null or pPhysicsGrabConstraint != null
				return true
			end
			
			return false
		end
		
		/** Menu button released. */
		public func void menuRelease()
			if pGrabAttach != null or pPhysicsGrabConstraint != null
			end
		end
		
		/** Track pad touched. Returns true if processed or false otherwise. */
		public func bool trackPadTouch()
			if pGrabAttach != null or pPhysicsGrabConstraint != null
				return true
			end
			
			return false
		end
		
		/** Track pad untouched. */
		public func void trackPadUntouch()
			if pGrabAttach != null or pPhysicsGrabConstraint != null
			end
		end
		
		
		
		protected func bool tryGrabAttach(ECBGrabAttach.Instance grabAttach)
			var ECBehaviorAttachable.Instance attachable = grabAttach.getAttachable()
			
			pGrabber.regrab(grabAttach.getGrabSpot())
			
			// grab using predefined position
			/*
			var ECBehaviorGrabSpot.Instance grabSpot = grabAttach.getGrabSpot()
			var Matrix matrix = (grabSpot.getElement().getElementMatrix()\
				* grabSpot.getTouchCollider().getInverseMatrix()).toMatrix()
			
			attachable.reattach(pAttachSlot, matrix.getPosition(), matrix.toQuaternion())
			*/
			
			// grab using world position
			
			// TODO: use pPhysicsToucher attach bone and position
			
			attachable.reattachWorld(pAttachSlot)
			
			return true
		end
		
		protected func bool tryGrabAttach(ECBAPhysicsToucher.TouchObject touchObject)
			var MoCapActor actor = getElement() cast MoCapActor
			var Component component = actor.getComponent().getComponent()
			var Collider collider = actor.getCollider().getCollider()
			var String attachBone
			var String constraintBone
			var ColliderRig colliderRig
			var int constraintBoneIndex
			
			// get matching attach bone from character configuration if present
			var ECBCharacterConfiguration.Instance characterConfig = ECBCharacterConfiguration.getInstanceIn(actor)
			if characterConfig != null
				if pGrabber.getECBehavior().getID().equals(BaseVRActorClass.idNonVRRightHand)
					attachBone = characterConfig.getCharacter().getGrabBoneRight()
					
				else
					attachBone = characterConfig.getCharacter().getGrabBoneLeft()
				end
			end
			
			// determine if the actor has a bone with shape as attach bone. only a bone
			// with shapes can be physically active in the game world and thus can only
			// be used as attachment point for physics objects. for this the attach bone
			// is tested. if it has no shapes go up to the parent and test. continue
			// until a valid bone is found. in general the attach bone has no shape but
			// the hand bone it is attached to does
			if not attachBone.empty() and collider != null and collider castable ColliderRig and component != null
				colliderRig = collider cast ColliderRig
				if colliderRig.getRig() != null
					var Rig rig = colliderRig.getRig()
					if rig != null
						var int index = rig.indexOfBoneNamed(attachBone)
						while index != -1
							if rig.boneGetShapes(index).getCount() > 0
								constraintBone = rig.boneGetName(index)
								constraintBoneIndex = index
								break
							end
							index = rig.boneGetParent(index)
						end
					end
				end
			end
			
			// if we have no bone with shapes we can not attach
			// 
			// note: later on add a fallback mode which uses a world constraint. this requires
			//       updating the constraint position properly every think()
			if constraintBone == null
				return false
			end
			
			//var Collider handCollider = pPhysicsToucher.getVRHand().getCollider()
			//var DMatrix handMatrix = handCollider.getMatrix()
			var DMatrix attachMatrix = component.boneGetMatrix(constraintBoneIndex).toDMatrix() * component.getMatrix()
			
			var Matrix coordSysObj
			
			pPhysicsGrabCollider = touchObject.collider
			
			pPhysicsGrabConstraint = ColliderConstraint.new()
			pPhysicsGrabConstraint.setTargetCollider(collider)
			pPhysicsGrabConstraint.setTargetBone(constraintBone)
			
			if touchObject.bone != -1
				pPhysicsGrabConstraint.setBone(touchObject.bone)
				
				var ColliderRig pcrig = pPhysicsGrabCollider cast ColliderRig
				coordSysObj = (attachMatrix * pcrig.boneGetInverseMatrix(touchObject.bone)).toMatrix()
				
			else
				coordSysObj = (attachMatrix * pPhysicsGrabCollider.getInverseMatrix()).toMatrix()
			end
			
			pPhysicsGrabConstraint.setPosition1(coordSysObj.getPosition())
			pPhysicsGrabConstraint.setOrientation1(coordSysObj.toQuaternion())
			
			pPhysicsGrabConstraint.lockAll()
			
			pPhysicsGrabCollider.addConstraint(pPhysicsGrabConstraint)
			
			return true
		end
		
		protected func void ungrabGrabAttach()
			if pPhysicsGrabConstraint != null
				if pPhysicsGrabCollider.hasConstraint(pPhysicsGrabConstraint)
					pPhysicsGrabCollider.removeConstraint(pPhysicsGrabConstraint)
				end
				
				pPhysicsGrabConstraint = null
				pPhysicsGrabCollider = null
				
			elif pGrabAttach != null
				pGrabAttach.getAttachable().detach()
				pGrabAttach.getGrabSpot().release()
				pGrabAttach = null
			end
			// TODO if object is dynamic give it linear/angular velocity while recording?
		end
	end
	
	
	
	public var ECBehaviorGrabber grabber
	public var ECBehaviorAttachSlot attachSlot
	public var ECBAPhysicsToucher physicsToucher
	
	
	
	/** Create behavior and add it to element class. */
	public func new(BehaviorElementClass eclass, ECBehaviorGrabber grabber,\
	ECBehaviorAttachSlot attachSlot, ECBAPhysicsToucher physicsToucher, String id) super(eclass, id)
		this.grabber = grabber
		this.attachSlot = attachSlot
		this.physicsToucher = physicsToucher
		eclass.addBehavior(this)
	end
	
	public func void dispose()
		grabber = null
		attachSlot = null
		physicsToucher = null
		super.dispose()
	end
	
	
	
	/** Get instance in element from owner element class. */
	public func Instance instance( BehaviorElement element )
		return element.getInstanceAt(getInstanceIndex()) cast Instance
	end
	
	/** Get instance in element or null if absent. */
	static public func Instance getInstanceIn(BehaviorElement element, String id)
		return element.findInstance(block Instance each
			return each.getECBehavior().getID().equals(id)
		end) cast Instance
	end
	
	/** Create behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
