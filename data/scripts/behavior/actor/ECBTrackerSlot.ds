/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Characters

pin Dragengine.Commands
pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * Behavior tracking state of a tracker slot. Can show attached tracker in 3D.
 */
class ECBTrackerSlot extends DefaultECBehavior
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		/** Controller attach/detach listener. */
		class AttachDetachListener extends DefaultBindingManagerListener
			private var Instance pInstance
			private var String pDeviceID
			
			public func new(Instance instance)
				pInstance = instance
				pDeviceID = instance.getECBehavior().getTrackerSlot().getInputDeviceID()
			end
			
			public func void deviceAttached(BindingManager manager, InputDevice device)
				if device.getID().equals(pDeviceID)
					pInstance.setInputDevice(device)
				end
			end
			
			public func void deviceDetached(BindingManager manager, InputDevice device)
				if pInstance.getInputDevice() == device
					pInstance.setInputDevice(null)
				end
			end
			
			public func void devicesReloaded(BindingManager manager)
				// temporary
				pInstance.findInputDevice()
			end
		end
		
		/** Update controllers. */
		class UpdateControllers extends ECBehaviorActorAnimated.DefaultListener
			private var Instance pInstance
			
			public func new(Instance instance)
				pInstance = instance
			end
			
			public func void updateControllers(ECBehaviorActorAnimated.Instance instance, float elapsed)
				pInstance.updateControllers()
			end
		end
		
		
		
		private var ECBTrackerSlot pECBehavior
		private var ECBehaviorVRPlayspace.Instance pVRPlayspace
		private var ECBehaviorActorAnimated.Instance pActorAnimated
		private var ECBehaviorComponent.Instance pComponent
		private var AnimatorController pControllerPosition
		private var AnimatorController pControllerRotation
		private var bool pShowTracker
		private var bool pShowCoordSystem
		private var InputDevice pInputDevice
		private var SmoothSlotWMM pSmoothSlot
		private var Vector pPosition
		private var Quaternion pOrientation
		private var Matrix pMatrix
		private var Matrix pReferenceMatrix
		private var Matrix pComponentMatrix
		private var AttachDetachListener pAttachDetachListener
		private var DebugDrawer pDDCoordSystem
		private var Vector pCalibrationPosition
		private var Quaternion pCalibrationOrientation
		private var int pCalibrationCounter
		
		
		
		/** Create instance. */
		public func new(ECBTrackerSlot ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pShowTracker = false //true
			pShowCoordSystem = false //true
			pPosition = Vector.new()
			pOrientation = Quaternion.new()
			pMatrix = Matrix.new()
			pReferenceMatrix = Matrix.new()
			pComponentMatrix = Matrix.new()
			pAttachDetachListener = AttachDetachListener.new(this)
			
			pVRPlayspace = ecbehavior.getVRPlayspace().instance(element)
			pActorAnimated = ecbehavior.getActorAnimated().instance(element)
			pComponent = ecbehavior.getComponent().instance(element)
		end
		
		/** Dispose of instance. */
		public func void dispose()
			pAttachDetachListener = null
			pComponent = null
			pVRPlayspace = null
			pActorAnimated = null
			super.dispose()
		end
		
		/** Init behavior instance. */
		public func void init(StubElement stub)
			initSmoothing()
			
			pControllerPosition = pActorAnimated.getControllerNamed(pECBehavior.getControllerNamePosition())
			pControllerRotation = pActorAnimated.getControllerNamed(pECBehavior.getControllerNameRotation())
			
			pActorAnimated.addListener(UpdateControllers.new(this))
			
			updateVisibile()
		end
		
		
		
		/** Behavior. */
		public func ECBTrackerSlot getECBehavior()
			return pECBehavior
		end
		
		/** VR Playspace. */
		public func ECBehaviorVRPlayspace.Instance getVRPlayspace()
			return pVRPlayspace
		end
		
		/** Actor animated. */
		public func ECBehaviorActorAnimated.Instance getActorAnimated()
			return pActorAnimated
		end
		
		/** Component behavior instance. */
		public func ECBehaviorComponent.Instance getComponent()
			return pComponent
		end
		
		/** Character tracker slot. */
		public func CharacterTrackerSlot getTrackerSlot()
			return pECBehavior.getTrackerSlot()
		end
		
		/** Animator controller position. */
		public func AnimatorController getControllerPosition()
			return pControllerPosition
		end
		
		/** Animator controller rotation. */
		public func AnimatorController getControllerRotation()
			return pControllerRotation
		end
		
		/** Show hand. */
		public func bool getShowTracker()
			return pShowTracker
		end
		
		/** Set show hand. */
		protected func void setShowTracker(bool showHand)
			if showHand == pShowTracker
				return
			end
			
			pShowTracker = showHand
			stateChanged()
		end
		
		/** Show coordinate system. */
		public func bool getShowCoordSystem()
			return pShowCoordSystem
		end
		
		/** Set show coordinate system. */
		protected func void setShowCoordSystem(bool show)
			if show == pShowCoordSystem
				return
			end
			
			pShowCoordSystem = show
			stateChanged()
		end
		
		/** Input device or null if detached. */
		public func InputDevice getInputDevice()
			return pInputDevice
		end
		
		/** Set input device or null if detached. */
		public func void setInputDevice(InputDevice device)
			if device == pInputDevice
				return
			end
			
			pInputDevice = device
			updateModelSkin()
			initSmoothing()
		end
		
		/** \brief Tracker is attached. */
		public func bool isAttached()
			return this.pInputDevice != null
		end
		
		/** \brief Tracker is detached. */
		public func bool isDetached()
			return this.pInputDevice == null
		end
		
		
		
		/** World matrix. */
		public func DMatrix getMatrix()
			return pMatrix.toDMatrix() * pVRPlayspace.getMatrix()
		end
		
		/** Character local matrix. */
		public func Matrix getMatrixCharacter()
			return pMatrix
		end
		
		/** Character reference matrix. */
		public func Matrix getMatrixReference()
			return pReferenceMatrix
		end
		
		/** Set character reference matrix. */
		public func void setMatrixReference(Matrix matrix)
			if matrix == null
				throw ENullPointer.new("matrix")
			end
			pReferenceMatrix = matrix
		end
		
		/** Character component matrix. */
		public func Matrix getMatrixComponent()
			return pComponentMatrix
		end
		
		/** Set character component matrix. */
		public func void setMatrixComponent(Matrix matrix)
			if matrix == null
				throw ENullPointer.new("matrix")
			end
			pComponentMatrix = matrix
		end
		
		/** World position. */
		public func DVector getPosition()
			return pVRPlayspace.getMatrix() * DVector.new(pPosition)
		end
		
		/** Character local position. */
		public func Vector getPositionCharacter()
			return pPosition
		end
		
		/** World orientation. */
		public func Quaternion getOrientation()
			return pOrientation * pVRPlayspace.getOrientation()
		end
		
		/** Character local orientation. */
		public func Quaternion getOrientationCharacter()
			return pOrientation
		end
		
		/** Set character local matrix. */
		public func void setMatrixCharacter(Matrix matrix)
			if matrix == null
				throw ENullPointer.new("matrix")
			end
			
			pMatrix = matrix
			pPosition = matrix.getPosition()
			pOrientation = pMatrix.normalize().toQuaternion()
			
			pControllerPosition.setVector(pPosition)
			pControllerRotation.setRotation(pOrientation.getEulerAngles())
		end
		
		/** Set playspace local matrix. */
		public func void setMatrixCharacter(Vector position, Vector rotation)
			if position == null
				throw ENullPointer.new("position")
			end
			if rotation == null
				throw ENullPointer.new("rotation")
			end
			
			pPosition = position
			pMatrix = Matrix.newRT(rotation, position)
			pOrientation = pMatrix.toQuaternion()
			
			pControllerPosition.setVector(pPosition)
			pControllerRotation.setRotation(rotation)
		end
		
		/** Find input device. */
		public func void findInputDevice()
			var String id = pECBehavior.getTrackerSlot().getInputDeviceID()
			setInputDevice(GameApp.getGameApp().getBindingManager().findDevice(block InputDevice each
				return each.getID().equals(id)
			end))
		end
		
		
		
		/** Element has been added to game world. Start tracking device. */
		public func void addToGameWorld()
			GameApp.getGameApp().getBindingManager().addListener(pAttachDetachListener)
			findInputDevice()
			createDDCoordSystem()
		end
		
		/** Element has been removed from game world. Stop tracking device. */
		public func void removeFromGameWorld()
			GameApp.getGameApp().getBindingManager().removeListener(pAttachDetachListener)
			setInputDevice(null)
			destroyDDCoordSystem()
		end
		
		/** Element state changed like visible. */
		public func void stateChanged()
			updateVisibile()
		end
		
		/** Update controllers. */
		public func void updateControllers()
			if pComponent == null
				return // dispose protection
			end
			
			updateMatrix(false)
			
			var Component component = pComponent.getComponent()
			if component != null
				var DMatrix matrix = pComponentMatrix.toDMatrix() * pVRPlayspace.getMatrix()
				component.setPosition(matrix.getPosition())
				component.setOrientation(matrix.toQuaternion())
			end
			
			if pDDCoordSystem != null
				var DMatrix matrix = getMatrix()
				pDDCoordSystem.setPosition(matrix.getPosition())
				pDDCoordSystem.setOrientation(matrix.toQuaternion())
			end
		end
		
		/** Set component position from character matrix. */
		public func void setComponentFromMatrixCharacter(Matrix matrix)
			var CharacterTrackerSlot slot = pECBehavior.getTrackerSlot()
			var CharacterConfiguration config = slot.getConfiguration()
			
			if pDDCoordSystem != null
				var DMatrix m = matrix.toDMatrix() * pVRPlayspace.getMatrix()
				pDDCoordSystem.setPosition(m.getPosition())
				pDDCoordSystem.setOrientation(m.toQuaternion())
			end
			
			if pInputDevice != null
				matrix = slot.getOffsetMatrixInverse() * matrix
			end
			
			if config.getScaleMode() == CharacterConfiguration.ScaleMode.actor
				matrix = matrix * config.getMatrixCalibrateInverse()
				
			else
				matrix = matrix * config.getMatrixScaleInverse() * config.getMatrixCalibrateInverse()
			end
			
			var Component component = pComponent.getComponent()
			if component != null
				var DMatrix m = matrix.toDMatrix() * pVRPlayspace.getMatrix()
				component.setPosition(m.getPosition())
				component.setOrientation(m.toQuaternion())
			end
		end
		
		
		
		/** Begin calibration. */
		public func void beginCalibration()
			pCalibrationPosition = Vector.new()
			pCalibrationOrientation = Quaternion.new()
			pCalibrationCounter = 0
			findInputDevice()
		end
		
		/** Update calibration. */
		public func void updateCalibration()
			if pInputDevice == null
				return
			end
			
			pCalibrationPosition = pCalibrationPosition + pInputDevice.getDevicePosePosition()
			pCalibrationOrientation = pCalibrationOrientation + pInputDevice.getDevicePoseOrientation()
			pCalibrationCounter++
		end
		
		/** End calibration. */
		public func void endCalibration()
			if pInputDevice == null
				return
			end
			
			if pCalibrationCounter > 1
				pCalibrationPosition = pCalibrationPosition / pCalibrationCounter
				pCalibrationOrientation = pCalibrationOrientation.normalize()
			end
			pCalibrationCounter++
		end
		
		/** Calibration position. */
		public func Vector getCalibrationPosition()
			return pCalibrationPosition
		end
		
		/** Calibration orientation. */
		public func Quaternion getCalibrationOrientation()
			return pCalibrationOrientation
		end
		
		/** Calibration counter. */
		public func int getCalibrationCounter()
			return pCalibrationCounter
		end
		
		
		
		/** Update component model and skin. */
		protected func void updateModelSkin()
			var Component component = pComponent.getComponent()
			if component == null
				return
			end
			
			if pInputDevice != null and pInputDevice.getType() != InputDeviceType.vrHMD
				component.setModelAndSkin(pInputDevice.getVRModel(), pInputDevice.getVRSkin())
				
			else
				component.setModelAndSkin(null, null)
			end
		end
		
		/** Update component visible. */
		protected func void updateVisibile()
			var Component component = pComponent.getComponent()
			if component == null
				return
			end
			
			component.setVisible(pShowTracker and getElement().getVisible())
			createDDCoordSystem()
		end
		
		/** Update matrix. */
		public func void updateMatrix(bool calibrating)
			var CharacterTrackerSlot slot = pECBehavior.getTrackerSlot()
			var CharacterConfiguration config = slot.getConfiguration()
			
			// some notes:
			// - pComponentMatrix is the real VR device location in VR playspace
			// - pReferenceMatrix is the reference slot location in character space
			// - pMatrix is the slot location in character space
			// - getOffsetMatrix() applies only to real VR devices to obtain pMatrix
			// - config.getMatrixCalibrate() transforms from VR playspace to actor space
			// - config.getMatrixScale() is characterShoulderLevel / actorShoulderLevel
			// - config.getMatrixScaleInverse() is actorShoulderLevel / characterShoulderLevel
			pReferenceMatrix = slot.getMatrix() * config.getMatrixScale()
			
			if pInputDevice != null
				if calibrating
					if pCalibrationCounter > 0
						pComponentMatrix = Matrix.newWorld(pCalibrationPosition, pCalibrationOrientation)
						
					else
						pComponentMatrix = pInputDevice.getDevicePoseMatrix()
					end
					
				else
					pComponentMatrix = applySmoothing(pInputDevice.getDevicePoseMatrix())
				end
				pMatrix = pComponentMatrix * config.getMatrixCalibrate() * config.getMatrixScale()
				
			else
				pMatrix = slot.getTargetMatrix()
				pComponentMatrix = pMatrix * config.getMatrixScaleInverse() * config.getMatrixCalibrateInverse()
			end
			
			if config.getScaleMode() == CharacterConfiguration.ScaleMode.actor
				pComponentMatrix = pMatrix * config.getMatrixCalibrateInverse()
			end
			
			if pInputDevice != null
				pMatrix = slot.getOffsetMatrix() * pMatrix
			end
			
			pPosition = pMatrix.getPosition()
			pOrientation = pMatrix.normalize().toQuaternion()
			
			pControllerPosition.setVector(pPosition)
			pControllerRotation.setRotation(pOrientation.getEulerAngles())
		end
		
		/** Create coordinate system debug drawer if required. */
		protected func void createDDCoordSystem()
			if not pShowCoordSystem or pInputDevice == null or not getElement().getVisible()\
			or getElement().getGameWorld() == null
				destroyDDCoordSystem()
				return
			end
			
			select pInputDevice.getType()
			case InputDeviceType.vrRightHand, InputDeviceType.vrLeftHand, InputDeviceType.vrTracker
				if pDDCoordSystem != null
					return
				end
				
				pDDCoordSystem = DebugDrawer.new()
				pDDCoordSystem.setVisible(true)
				pDDCoordSystem.setXRay(true)
				pDDCoordSystem.setShapeCount(3)
				pDDCoordSystem.shapeSetFillColor(0, Color.red)
				pDDCoordSystem.shapeSetFillColor(1, Color.green)
				pDDCoordSystem.shapeSetFillColor(2, Color.blue)
				
				var ShapeList shapes = ShapeList.new()
				shapes.addBox(Vector.new(0.05, 0, 0), Vector.new(0.05, 0.005, 0.005))
				pDDCoordSystem.shapeSetShapes(0, shapes)
				
				shapes = ShapeList.new()
				shapes.addBox(Vector.new(0, 0.05, 0), Vector.new(0.005, 0.05, 0.005))
				pDDCoordSystem.shapeSetShapes(1, shapes)
				
				shapes = ShapeList.new()
				shapes.addBox(Vector.new(0, 0, 0.05), Vector.new(0.005, 0.005, 0.05))
				pDDCoordSystem.shapeSetShapes(2, shapes)
				
				getElement().getGameWorld().getWorld().addDebugDrawer(pDDCoordSystem)
				
			else
				destroyDDCoordSystem()
			end
		end
		
		/** Destroy coordinate system debug drawer if present. */
		protected func void destroyDDCoordSystem()
			if pDDCoordSystem == null
				return
			end
			
			getElement().getGameWorld().getWorld().removeDebugDrawer(pDDCoordSystem)
			pDDCoordSystem = null
		end
		
		/** Init smoothing. Smoothing is only used if an input device is present. */
		protected func void initSmoothing()
			if pInputDevice == null
				pSmoothSlot = null
				return
			end
			
			pSmoothSlot = SmoothSlotWMM.new()
			pSmoothSlot.setStrength(SessionSettings.get().getSmoothSlotStrength())
			pSmoothSlot.init(pInputDevice.getDevicePoseMatrix())
		end
		
		/** Apply smoothing if present. */
		protected func Matrix applySmoothing(Matrix matrix)
			if pSmoothSlot == null
				return matrix
			end
			
			pSmoothSlot.setStrength(SessionSettings.get().getSmoothSlotStrength())
			return pSmoothSlot.update(matrix)
		end
	end
	
	
	
	private var CharacterTrackerSlot pTrackerSlot
	private var ECBehaviorVRPlayspace pVRPlayspace
	private var ECBehaviorActorAnimated pActorAnimated
	private var ECBehaviorComponent pComponent
	private var String pControllerNamePosition
	private var String pControllerNameRotation
	
	
	
	/** Create behavior element class. */
	public func new(BaseVRActorClass eclass, CharacterTrackerSlot slot) super(eclass, slot.getName())
		if slot == null
			throw ENullPointer.new("slot")
		end
		
		var String subId = "tracker(" + slot.getName() + ")"
		var String prefix = subId + "."
		
		pTrackerSlot = slot
		pVRPlayspace = eclass.getVRPlayspace()
		pActorAnimated = eclass.getActorAnimated()
		
		pControllerNamePosition = slot.getName() + ".position"
		pControllerNameRotation = slot.getName() + ".rotation"
		
		pComponent = ECBehaviorComponent.new(eclass, null, subId, prefix + "component")
		
		eclass.addBehavior(this)
	end
	
	/** Dispose of behavior. */
	public func void dispose()
		pVRPlayspace = null
		pTrackerSlot = null
		super.dispose()
	end
	
	
	
	/** Tracker slot. */
	public func CharacterTrackerSlot getTrackerSlot()
		return pTrackerSlot
	end
	
	/** VR Playspace behavior. */
	public func ECBehaviorVRPlayspace getVRPlayspace()
		return pVRPlayspace
	end
	
	/** Actor animated behavior. */
	public func ECBehaviorActorAnimated getActorAnimated()
		return pActorAnimated
	end
	
	/** Component behavior. */
	public func ECBehaviorComponent getComponent()
		return pComponent
	end
	
	/** Animator controller name position. */
	public func String getControllerNamePosition()
		return pControllerNamePosition
	end
	
	/** Animator controller name rotation. */
	public func String getControllerNameRotation()
		return pControllerNameRotation
	end
	
	
	
	/** Get instance in element from owner element class. */
	public func Instance instance( BehaviorElement element )
		return element.getInstanceAt( this.getInstanceIndex() ) cast Instance
	end
	
	
	
	/** Get behavior with slot name in element class or null if absent. */
	static public func ECBTrackerSlot getBehaviorIn(BehaviorElementClass eclass, String slotName)
		return eclass.findBehavior(block ECBTrackerSlot each
			return each.getTrackerSlot().getName().equals(slotName)
		end) cast ECBTrackerSlot
	end
	
	/** Get list of all behaviors in element. */
	static public func Array getAllBehaviorsIn(BehaviorElementClass eclass)
		return eclass.collectBehaviors(block ECBTrackerSlot each
			return true
		end)
	end
	
	/** Get instance with slot name in element or null if absent. */
	static public func Instance getInstanceIn(BehaviorElement element, String slotName)
		return element.findInstance(block Instance each
			return each.getECBehavior().getTrackerSlot().getName().equals(slotName)
		end) cast Instance
	end
	
	/** Get list of all instances in element. */
	static public func Array getAllInstancesIn(BehaviorElement element)
		return element.collectInstances(block Instance each
			return true
		end)
	end
	
	
	
	/** Create Behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
