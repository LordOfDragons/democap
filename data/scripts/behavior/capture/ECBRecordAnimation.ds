/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Actors
pin Democap.Characters

pin Dragengine.Gui
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Behavior adding support to record animations.
 */
class ECBRecordAnimation extends DefaultECBehavior
	/** Listener. */
	interface Listener
		/** Prepare recording. Called when recording delays starts. */
		func void prepareRecording(Instance instance)
		
		/** Recording starts. Called when recording delay ends. */
		func void startRecording(Instance instance)
		
		/** Recording stopped. */
		func void stopRecording(Instance instance)
	end
	
	/** Default listener implementation. */
	class DefaultListener implements Listener
		/** Create listener. */
		public func new()
		end
		
		/** Prepare recording. Called when recording delays starts. */
		public func void prepareRecording(Instance instance)
		end
		
		/** Recording starts. Called when recording delay ends. */
		public func void startRecording(Instance instance)
		end
		
		/** Recording stopped. */
		public func void stopRecording(Instance instance)
		end
	end
	
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		class RecordDeviceSlot
			protected var ECBTrackerSlot.Instance pSlot
			protected var int pBone
			protected var Matrix pMatrix1, pMatrix2
			
			public func new(ECBTrackerSlot.Instance slot, int bone, Matrix matrix1, Matrix matrix2)
				pSlot = slot
				pBone = bone
				pMatrix1 = matrix1
				pMatrix2 = matrix2
			end
			
			public func Matrix calcMatrix()
				return pMatrix1 * pSlot.getMatrixCharacter() * pMatrix2
			end
		end
		
		class RecordStateChanged extends RecordScene.DefaultListener
			protected var Instance pInstance
			
			public func new(Instance instance)
				pInstance = instance
			end
			
			public func void prepareRecording(RecordScene recordScene)
				pInstance.prepareRecording()
			end
			
			public func void startRecording(RecordScene recordScene)
				pInstance.startRecording()
			end
			
			public func void stopRecording(RecordScene recordScene)
				pInstance.stopRecording()
			end
		end
		
		
		private var ECBRecordAnimation pECBehavior
		private var ECBehaviorComponent.Instance pComponent
		private var ECBCharacterConfiguration.Instance pCharacter
		private var ECBCapturedAnimations.Instance pCapturedAnimations
		private var Array pBoneIndices
		private var Array pRootBoneIndices
		private var Array pStaticBoneIndices
		private var Array pStaticRootBoneIndices
		private var Matrix pTransformRootBones
		private var int pOriginBoneIndex
		private var Array pOriginChildrenIndices
		private var RecordAnimation pRecordAnimation
		private var RecordAnimation pRecordAnimationDevices
		private var RecordAnimation pRecordAnimationObject
		private var CharacterAnimation pCharacterAnimation
		private var SessionSettings.RecordDevices pRecordDevices
		private var Array pRecordDeviceSlots
		private var bool pIsPreparing
		private var bool pIsRecording
		private var float pRecordTime
		private var bool pIncrementTime
		private var Array pListeners
		private var bool pFullRecording
		private var bool pFirstFrame
		private var RecordStateChanged pRecordStateChanged
		private var bool pAutoStopRecord
		
		
		
		/** Create instance. */
		public func new(ECBRecordAnimation ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pBoneIndices = Array.new()
			pRootBoneIndices = Array.new()
			pStaticBoneIndices = Array.new()
			pStaticRootBoneIndices = Array.new()
			pOriginBoneIndex = -1
			pOriginChildrenIndices = Array.new()
			pRecordDeviceSlots = Array.new()
			pListeners = Array.new()
			pTransformRootBones = Matrix.new()
			
			pComponent = ecbehavior.getComponent().instance(element)
			if ecbehavior.getCharacter() != null
				pCharacter = ecbehavior.getCharacter().instance(element)
			end
			if ecbehavior.getCapturedAnimations() != null
				pCapturedAnimations = ecbehavior.getCapturedAnimations().instance(element)
			end
			
			pRecordStateChanged = RecordStateChanged.new(this)
			GameApp.getGameApp().getRecordScene().addListener(pRecordStateChanged)
			
			setRequiresThink(true)
		end
		
		/** Dispose of instance. */
		public func void dispose()
			if pRecordStateChanged != null
				GameApp.getGameApp().getRecordScene().removeListener(pRecordStateChanged)
				pRecordStateChanged = null
			end
			
			pCapturedAnimations = null
			pListeners = null
			pCharacter = null
			pComponent = null
			super.dispose()
		end
		
		/** Init behavior instance. */
		public func void init(StubElement stub)
		end
		
		
		
		/** Behavior. */
		public func ECBRecordAnimation getECBehavior()
			return pECBehavior
		end
		
		/** Component. */
		public func ECBehaviorComponent.Instance getComponent()
			return pComponent
		end
		
		
		
		/** Record animation or null. */
		public func RecordAnimation getRecordAnimation()
			return pRecordAnimation
		end
		
		/** Record devices animation or null. */
		public func RecordAnimation getRecordAnimationDevices()
			return pRecordAnimationDevices
		end
		
		/** Record object animation or null. */
		public func RecordAnimation getRecordAnimationObject()
			return pRecordAnimationObject
		end
		
		/** Character animation or null. */
		public func CharacterAnimation getCharacterAnimation()
			return pCharacterAnimation
		end
		
		/** Captured animations or null. */
		public func ECBCapturedAnimations.Instance getCapturedAnimations()
			return pCapturedAnimations
		end
		
		
		
		/** Is preparing to record. */
		public func bool isPreparing()
			return pIsPreparing
		end
		
		/** Is recording animation. */
		public func bool isRecording()
			return pIsRecording
		end
		
		/** Is preparing or recording. */
		public func bool isPreparingOrRecording()
			return pIsPreparing or pIsRecording
		end
		
		/** Is not recording nor preparing. */
		public func bool isNotRecording()
			return not pIsRecording and not pIsPreparing
		end
		
		/** Prepare to record. */
		public func void prepareRecording()
			if pIsPreparing or pIsRecording
				return
			end
			if pCharacter != null and GameApp.getGameApp().getWorldSpawnCharacter().getActor() != getElement()
				// NOTE later on this could be enabled in the form of passive recording
				return
			end
			
			// find captured animations to use
			var BehaviorElement selectionElement
			
			if pCharacter != null
				var ECBSelectable.Instance selection = GameApp.getGameApp().getSelectionTracker().getElement()
				if selection != null
					selectionElement = selection.getElement()
					pCapturedAnimations = ECBCapturedAnimations.getInstanceIn(selectionElement)
					if pCapturedAnimations.getCaptureTarget() == ECBCapturedAnimations.CaptureTarget.character
						if not pCapturedAnimations.getCharacterProfile().equals(pCharacter.getCharacter().getProfile().getName())
							throw EInvalidParam.new("character profile mismatch")
						end
						
					else
						pCapturedAnimations = null
					end
				end
			end
			
			if pCapturedAnimations != null and not pCapturedAnimations.getRecord()
				return
			end
			
			// find animation to record
			pCharacterAnimation = null
			pFullRecording = false
			
			if pCapturedAnimations != null
				pCharacterAnimation = pCapturedAnimations.getAnimations().getActive()
				pFullRecording = pCapturedAnimations.getAnimations().getAt(0) == pCharacterAnimation
			end
			
			// prepare capturing
			pFirstFrame = true
			
			pRecordAnimation = RecordAnimation.new()
			pRecordAnimation.setFPS(SessionSettings.get().getModelRecordFrameRate().getValue())
			pRecordAnimation.setMoveName("MoCap")
			
			pRecordDevices = SessionSettings.get().getRecordDevices()
			
			pRecordDeviceSlots.removeAll()
			
			if pRecordDevices != SessionSettings.RecordDevices.none and pCharacter != null
				pRecordAnimationDevices = RecordAnimation.new("-devices")
				pRecordAnimationDevices.setFPS(pRecordAnimation.getFPS())
				pRecordAnimationDevices.setMoveName("MoCapDevices")
				pRecordAnimationDevices.createRig(pCharacter.getCharacter())
			end
			
			pRecordAnimationObject = RecordAnimation.new("-object")
			pRecordAnimationObject.setFPS(pRecordAnimation.getFPS())
			pRecordAnimationObject.setMoveName("MoCapObject")
			pRecordAnimationObject.createObjectRig()
			
			if pCharacter != null
				if pFullRecording
					prepareAllBoneIndices()
					
				else
					prepareBoneIndices()
				end
				prepareOriginBone()
				
			else
				prepareObjectBones()
			end
			
			pTransformRootBones = Matrix.new()
			
			if pCharacterAnimation != null
				pCharacterAnimation.clear()
			end
			
			var BehaviorElement element = getElement()
			
			if selectionElement != null
				// ensure actor element lines up with selection element. if this is not
				// the case the captured animation would be played back at the wrong
				// position. we could calculate the transformation matrix from actor
				// element in selection element coordinate system but this hides the
				// problem and causes troubles later on while using the animation
// 				element.setGeometry(selectionElement.getPosition(), selectionElement.getOrientation())
				pTransformRootBones = (element.getElementMatrix() * selectionElement.getInverseElementMatrix()).toMatrix()
			end
			
			// if physics attachments are used init collider bone states from component.
			// this is required since collider bone states are in world space and do not
			// move if the actor moves due to teleportation
			/*
			var Collider collider = ECBehaviorCollider.getInstanceIn(element).getCollider()
			if collider.getResponseType() == CollisionResponse.dynamic\
			and collider castable ColliderComponent
				(collider cast ColliderComponent).copyStatesFromComponent()
			end
			*/
			
			if pRecordDevices != SessionSettings.RecordDevices.none and pCharacter != null
				// has to be done after pTransformRootBones has been calculated
				var Matrix matCalibInv = pCharacter.getCharacter().getMatrixCalibrateInverse()
				var Rig rig = pRecordAnimationDevices.getRig()
				
				pCharacter.getCharacter().getTrackerSlots().forEach(block int index, CharacterTrackerSlot each
					var ECBTrackerSlot.Instance slot = ECBTrackerSlot.getInstanceIn(getElement(), each.getName())
					var Matrix matrix1
					
					select pRecordDevices
					case SessionSettings.RecordDevices.device
						matrix1 = Matrix.new()
						
					case SessionSettings.RecordDevices.reference
						matrix1 = each.getCalibrateReferenceMatrix() * each.getCalibrateMatrixInverse()
						
					case SessionSettings.RecordDevices.target
						matrix1 = each.getCalibrateReferenceMatrix() * each.getCalibrateMatrixInverse()\
							* each.getTargetMatrix() * each.getCalibrateReferenceMatrixInverse()
					end
					
					var Matrix matrix2 = matCalibInv * pTransformRootBones * rig.getBoneInverseMatrix(index)
					
					pRecordDeviceSlots.add(RecordDeviceSlot.new(slot, index, matrix1, matrix2))
					pRecordAnimationDevices.addBone(each.getName())
				end)
			end
			
			if pRecordAnimationObject != null
				var Rig rig = pRecordAnimationObject.getRig()
				var int i, count = rig.getBoneCount()
				for i = 0 to count
					pRecordAnimationObject.addBone(rig.boneGetName(i))
				end
			end
			
			pIsPreparing = true
			
			pAutoStopRecord = SessionSettings.get().getModelAutoStopRecord().getToggled()\
				and GameApp.getGameApp().getPlaybackScene().getPlaytime() > 0
			
			pListeners.forEach(block Listener each
				each.prepareRecording(this)
			end)
		end
		
		
		
		/**
		 * Prepare bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareBoneIndices()
			// order is important: add first all root bones then all non-root bones
			var Set ignoreBones = pECBehavior.getIgnoreBones()
			
			var Component component = pComponent.getComponent()
			var Rig rig = component.getRig()
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1
						pRootBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			pECBehavior.getBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and not pRootBoneIndices.has(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
		end
		
		/**
		 * Prepare all bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareAllBoneIndices()
			// order is important: add first all root bones then all non-root bones
			var Set ignoreBones = pECBehavior.getIgnoreBones()
			var Rig rig = pComponent.getComponent().getRig()
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			// add root bones. since all bone indices are added it is important to add root
			// bones only as root bones if they are true root bones (of the entire component)
			// not just root bones of all captured bone chains. if this split is not done the
			// root bone transform is applied twice causing problems
			var Array allRootBones = Array.new()
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and rig.boneGetParent(index) == -1
						allRootBones.add(index)
						pRootBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and rig.boneGetParent(index) != -1
						allRootBones.add(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			// add regular bones as in the not all mode
			pECBehavior.getBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and not allRootBones.has(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			// add static bones
			var int i, count = rig.getBoneCount()
			
			for i = 0 to count
				if rig.boneGetParent(i) == -1 and not allRootBones.has(i) and not pBoneIndices.has(i)
					pStaticRootBoneIndices.add(i)
					pRecordAnimation.addBone(rig.boneGetName(i))
				end
			end
			
			for i = 0 to count
				if rig.boneGetParent(i) != -1 and not allRootBones.has(i) and not pBoneIndices.has(i)
					pStaticBoneIndices.add(i)
					pRecordAnimation.addBone(rig.boneGetName(i))
				end
			end
		end
		
		/** Prepare origin bone. */
		protected func void prepareOriginBone()
			pOriginBoneIndex = -1
			pOriginChildrenIndices.removeAll()
			
			if pCharacter == null
				return
			end
			
			var String originBone = pCharacter.getCharacter().getProfile().getOriginBone()
			pRecordAnimation.setOriginBone(originBone)
			
			var Rig rig = pComponent.getComponent().getRig()
			pOriginBoneIndex = rig.indexOfBoneNamed(originBone)
			if pOriginBoneIndex == -1
				return
			end
			
			if rig.boneGetParent(pOriginBoneIndex) != -1
				// origin bone is not a root bone. this is not supported
				pOriginBoneIndex = -1
				return
			end
			
			(pBoneIndices + pStaticBoneIndices).forEach(block int index
				if rig.boneGetParent(index) == pOriginBoneIndex
					pOriginChildrenIndices.add(index)
				end
			end)
			
			if pOriginChildrenIndices.getCount() == 0\
			and not pRootBoneIndices.has(pOriginBoneIndex)\
			and not pStaticRootBoneIndices.has(pOriginBoneIndex)
				// adjusting origin bone transform has no effect so skip it
				pOriginBoneIndex = -1
			end
		end
		
		/**
		 * Prepare object bone indices. For each bone find also the root bone.
		 * All bones are dynamic.
		 */
		protected func void prepareObjectBones()
			// order is important: add first all root bones then all non-root bones
			var Set ignoreBones = pECBehavior.getIgnoreBones()
			var Rig rig = pComponent.getComponent().getRig()
			var int i, boneCount = rig.getBoneCount()
			var String bone
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			// add root bones
			for i = 0 to boneCount
				bone = rig.boneGetName(i)
				if not ignoreBones.has(bone) and rig.boneGetParent(i) == -1
					pRootBoneIndices.add(i)
					pRecordAnimation.addBone(bone)
				end
			end
			
			// add regular bones
			for i = 0 to boneCount
				bone = rig.boneGetName(i)
				if not ignoreBones.has(bone) and rig.boneGetParent(i) != -1
					pBoneIndices.add(i)
					pRecordAnimation.addBone(bone)
				end
			end
		end
		
		/** Start recording animation. */
		public func void startRecording()
			if not (pIsPreparing and not pIsRecording)
				return
			end
			
			pIsPreparing = false
			pIsRecording = true
			pRecordTime = 0
			pIncrementTime = false
			
			pListeners.forEach(block Listener each
				each.startRecording(this)
			end)
		end
		
		/** Stop recording animation. */
		public func void stopRecording()
			var GameApp app = GameApp.getGameApp()
			
			pAutoStopRecord = false
			
			if pIsRecording
				pIsRecording = false
				
				if pRecordAnimation != null
					pRecordAnimation.createAnimation()
					if pRecordAnimationDevices != null
						pRecordAnimationDevices.createAnimation()
					end
					if pRecordAnimationObject != null
						pRecordAnimationObject.createAnimation()
					end
					
					if pCharacterAnimation != null
						var Project project = app.getProject()
						var File directory = app.getProject().getDataDirectory()
						var Project.AnimationPath animPath = project.nextAnimationPath()
						
						if pRecordAnimation.getAnimation() != null
							pRecordAnimation.getAnimation().save((directory + animPath.getPath()).getPath())
						end
						if pRecordAnimationDevices != null
							pRecordAnimationDevices.getRig().save((directory + animPath.getPathDevicesRig()).getPath())
							pRecordAnimationDevices.getAnimation().save((directory + animPath.getPathDevices()).getPath())
						end
						if pRecordAnimationObject != null
							pRecordAnimationObject.getRig().save((directory + animPath.getPathObjectRig()).getPath())
							pRecordAnimationObject.getAnimation().save((directory + animPath.getPathObject()).getPath())
						end
						
						writeCaptureInfoFile((directory + animPath.getPathMeta()).getPath(),\
							animPath.getPath(), animPath.getPathDevices(), animPath.getPathDevicesRig(),\
							animPath.getPathObject(), animPath.getPathObjectRig())
						
						pCharacterAnimation.setPathMeta(animPath.getPathMeta())
						
						if pRecordAnimation.getAnimation() != null
							pCharacterAnimation.setPath(animPath.getPath())
							pCharacterAnimation.setAnimation(pRecordAnimation.getAnimation())
						end
						if pRecordAnimationDevices != null
							pCharacterAnimation.setPathDevices(animPath.getPathDevices())
							pCharacterAnimation.setPathDevicesRig(animPath.getPathDevicesRig())
							pCharacterAnimation.setAnimationDevices(pRecordAnimationDevices.getAnimation())
							pCharacterAnimation.setRigDevices(pRecordAnimationDevices.getRig())
						end
						if pRecordAnimationObject != null
							pCharacterAnimation.setPathObject(animPath.getPathObject())
							pCharacterAnimation.setPathObjectRig(animPath.getPathObjectRig())
							pCharacterAnimation.setAnimationObject(pRecordAnimationObject.getAnimation())
							pCharacterAnimation.setRigObject(pRecordAnimationObject.getRig())
						end
						
						if pCapturedAnimations != null
							pCapturedAnimations.getAnimations().notifyAnimationChanged(pCharacterAnimation)
						end
						
						if pCharacterAnimation != null and app.getSessionSettings().getModelAutoExport().getToggled()
							pCharacterAnimation.export(project, getAutoExportPath())
						end
						
					else
						if pRecordAnimation.getAnimation() != null
							pRecordAnimation.getAnimation().save(pRecordAnimation.getPath())
						end
						
						var String pathDevices = "", pathDevicesRig = ""
						if pRecordAnimationDevices != null
							pathDevicesRig = pRecordAnimationDevices.getPathRig()
							pathDevices = pRecordAnimationDevices.getPath()
							
							if pRecordAnimationDevices.getRig() != null
								pRecordAnimationDevices.getRig().save(pathDevicesRig)
							end
							if pRecordAnimationDevices.getAnimation() != null
								pRecordAnimationDevices.getAnimation().save(pathDevices)
							end
						end
						
						var String pathObject = "", pathObjectRig = ""
						if pRecordAnimationObject != null
							pathObjectRig = pRecordAnimationObject.getPathRig()
							pathObject = pRecordAnimationObject.getPath()
							
							if pRecordAnimationObject.getRig() != null
								pRecordAnimationObject.getRig().save(pathObjectRig)
							end
							if pRecordAnimationObject.getAnimation() != null
								pRecordAnimationObject.getAnimation().save(pathObject)
							end
						end
						
						writeCaptureInfoFile(pRecordAnimation.getPathMeta(), pRecordAnimation.getPath(),\
							pathDevices, pathDevicesRig, pathObject, pathObjectRig)
					end
				end
				
				pRecordAnimation = null
				pRecordAnimationDevices = null
				pRecordAnimationObject = null
				pCharacterAnimation = null
				pTransformRootBones = Matrix.new()
				
			elif pIsPreparing
				pIsPreparing = false
				pRecordAnimation = null
				pRecordAnimationDevices = null
				pRecordAnimationObject = null
				pCharacterAnimation = null
				pTransformRootBones = Matrix.new()
				
			else
				return
			end
			
			pListeners.forEach(block Listener each
				each.stopRecording(this)
			end)
		end
		
		
		
		/** Add listener. */
		public func void addListener(Listener listener)
			pListeners.add(listener)
		end
		
		/** Remove listener. */
		public func void removeListener(Listener listener)
			pListeners.remove(listener)
		end
		
		
		
		/** Frame update. */
		public func void think(float elapsed)
			if pIsRecording and pAutoStopRecord
				var PlaybackScene playback = GameApp.getGameApp().getPlaybackScene()
				if playback.getTime() == playback.getPlaytime()
					stopRecording()
				end
			end
		end
		
		/** Post think. Called after rendering and thus when animation frame is ready to record. */
		public func void postThink(float elapsed)
			if not pIsRecording and not GameApp.getGameApp().getServer().isListening()
				return
			end
			
			pComponent.getComponent().updateBones()
			
			if pIsRecording
				if pIncrementTime
					pRecordTime += elapsed
				end
				pIncrementTime = true
				
				if pRecordAnimation != null
					captureBones()
				end
				
				if pRecordAnimationObject != null
					var BehaviorElement element = getElement()
					pRecordAnimationObject.addKeyframe(pRecordTime,\
						element.getPosition().toVector(), element.getOrientation())
				end
			end
		end
		
		/** Capture bones. */
		protected func void captureBones()
			var Component component = pComponent.getComponent()
			
			// bones
			var Matrix originTransform = Matrix.new()
			if pOriginBoneIndex != -1
				originTransform = pTransformRootBones * component.getBoneOriginInverseMatrix(pOriginBoneIndex)
			end
			
			var Matrix matrix
			pRootBoneIndices.forEach(block int index
				if index == pOriginBoneIndex
					matrix = Matrix.new()
				else
					matrix = component.boneGetMatrix(index) * pTransformRootBones\
						* component.getBoneOriginInverseMatrix(index)
				end
				pRecordAnimation.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
			end)
			
			pBoneIndices.forEach(block int index
				if pOriginChildrenIndices.has(index)
					matrix = component.boneGetMatrix(index) * originTransform\
						* component.getBoneOriginInverseMatrix(index)
					pRecordAnimation.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
				else
					pRecordAnimation.addKeyframe(pRecordTime, \
						component.boneGetPosition(index), component.boneGetRotation(index))
				end
			end)
			
			if pFirstFrame
				pFirstFrame = false
				
				pStaticRootBoneIndices.forEach(block int index
					if index == pOriginBoneIndex
						matrix = Matrix.new()
					else
						matrix = component.boneGetMatrix(index) * pTransformRootBones\
							* component.getBoneOriginInverseMatrix(index)
					end
					pRecordAnimation.addStaticKeyframe(matrix.getPosition(), matrix.toQuaternion())
				end)
				
				pStaticBoneIndices.forEach(block int index
					if pOriginChildrenIndices.has(index)
						matrix = component.boneGetMatrix(index) * originTransform\
							* component.getBoneOriginInverseMatrix(index)
						pRecordAnimation.addStaticKeyframe(matrix.getPosition(), matrix.toQuaternion())
					else
						pRecordAnimation.addStaticKeyframe(\
							component.boneGetPosition(index), component.boneGetRotation(index))
					end
				end)
			end
			
			// devices
			pRecordDeviceSlots.forEach(block RecordDeviceSlot each
				matrix = each.calcMatrix()
				pRecordAnimationDevices.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
			end)
		end
		
		/** Write capture information file. */
		public func void writeCaptureInfoFile(String path, String animPath, String animDevicesPath,\
		String animDevicesRigPath, String animObjectPath, String animObjectRigPath)
			var EasyXML document = EasyXML.new()
			var EasyXMLElement root = document.getRootElement()
			var TimeDate timestamp = pRecordAnimation.getTimestamp()
			
			root.setTagName("mocapAnimation")
			
			// general information
			root.addDataTag("timestamp", timestamp.format("%Y-%m-%dT%H:%M:%S"))
			
			// actor
			if pCharacter != null
				var ActorProfile actorProfile = GameApp.getGameApp().getActiveActorProfile()
				if actorProfile != null
					var EasyXMLElement tag = root.addTag("actor")
					tag.addDataTag("profileName", actorProfile.getName())
					tag.addDataTag("shoulderLevel", actorProfile.getShoulderLevel())
					tag.addDataTag("shoulderWide", actorProfile.getShoulderWidth())
					tag.addDataTag("armLength", actorProfile.getArmLength())
					tag.addDataTag("legLength", actorProfile.getLegLength())
				end
				
			else
				var EasyXMLElement tag = root.addTag("object")
				tag.addDataTag("elementClass", getElement().getClass().getClassname())
				tag.addDataTag("identifier", getElement().getID().toHexString())
			end
			
			// character
			var String originBone = ""
			
			if pCharacter != null
				var CharacterProfile profile = pCharacter.getCharacter().getProfile()
				originBone = profile.getOriginBone()
				
				var EasyXMLElement tag = root.addTag("character")
				tag.addDataTag("profileName", profile.getName())
				tag.addDataTag("configurationName", pCharacter.getCharacter().getName())
				
				tag.addDataTag("originBone", originBone)
				tag.addDataTag("shoulderLevel", profile.getShoulderLevel())
				tag.addDataTag("scaleMode", pCharacter.getCharacter().getScaleMode().name())
				tag.addDataTag("calibratedScale", pCharacter.getCharacter().getCalibrateScale())
				
				var CharacterAppearance appearance = profile.getAppearance()
				var EasyXMLElement tagAppearance = tag.addTag("appearance")
				tagAppearance.addDataTag("pathModel", appearance.getPathModel())
				tagAppearance.addDataTag("pathSkin", appearance.getPathSkin())
				tagAppearance.addDataTag("pathRig", appearance.getPathRig())
				tagAppearance.addDataTag("pathAnimation", appearance.getPathAnimation())
			end
			
			// animation
			var Animation animation = pRecordAnimation.getAnimation()
			if animation != null
				var bool hasOriginBone = not originBone.empty() and not pRecordAnimation.hasBone(originBone)
				var String moveName = animation.getMoveName(0)
				
				var EasyXMLElement tagAnimation = root.addTag("capturedAnimation")
				tagAnimation.addDataTag("pathAnimation", animPath)
				tagAnimation.addDataTag("moveName", moveName)
				tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
				tagAnimation.addDataTag("frameRate", pRecordAnimation.getFPS())
				
				if hasOriginBone
					tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount() + 1)
					
				else
					tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount())
				end
				
				var EasyXMLElement tagBones = tagAnimation.addTag("bones")
				pRecordAnimation.forEachBone(block String each
					tagBones.addDataTag("boneName", each)
				end)
				
				if hasOriginBone
					tagBones.addDataTag("boneName", originBone)
				end
			end
			
			// devices animation
			if pRecordAnimationDevices != null and not animDevicesPath.empty()
				animation = pRecordAnimationDevices.getAnimation()
				var String moveName = animation.getMoveName(0)
				
				var EasyXMLElement tagAnimation = root.addTag("capturedAnimationDevices")
				tagAnimation.addDataTag("pathAnimation", animDevicesPath)
				
				if not animDevicesRigPath.empty()
					tagAnimation.addDataTag("pathRig", animDevicesRigPath)
				end
				
				tagAnimation.addDataTag("moveName", moveName)
				tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
				tagAnimation.addDataTag("frameRate", pRecordAnimationDevices.getFPS())
				tagAnimation.addDataTag("boneCount", pRecordAnimationDevices.getBoneCount())
				
				var EasyXMLElement tagBones = tagAnimation.addTag("bones")
				pRecordAnimationDevices.forEachBone(block String each
					tagBones.addDataTag("boneName", each)
				end)
			end
			
			// object animation
			if pRecordAnimationObject != null and not animObjectPath.empty()
				animation = pRecordAnimationObject.getAnimation()
				var String moveName = animation.getMoveName(0)
				
				var EasyXMLElement tagAnimation = root.addTag("capturedAnimationObject")
				tagAnimation.addDataTag("pathAnimation", animObjectPath)
				
				if not animObjectRigPath.empty()
					tagAnimation.addDataTag("pathRig", animObjectRigPath)
				end
				
				tagAnimation.addDataTag("moveName", moveName)
				tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
				tagAnimation.addDataTag("frameRate", pRecordAnimationObject.getFPS())
				
				var EasyXMLElement tagBones = tagAnimation.addTag("bones")
				pRecordAnimationObject.forEachBone(block String each
					tagBones.addDataTag("boneName", each)
				end)
			end
			
			// write to file
			document.writeToFile(FileWriter.new(path), false)
		end
		
		/** Create auto export path. */
		public func String getAutoExportPath()
			var Scene scene = GameApp.getGameApp().getScene()
			var File path = File.new(scene.getName())
			
			var StageDirection stageDirection = scene.getStageDirections().getSelected()
			if stageDirection != null
				path = path + stageDirection.getName()
			end
			
			var BehaviorElement element = getElement()
			if pCapturedAnimations != null
				element = pCapturedAnimations.getElement()
			end
			
			var ECBSceneObject.Instance sceneObject = ECBSceneObject.getInstanceIn(element)
			var String objectName = sceneObject.getName()
			if objectName.empty()
				objectName = "{}-{}".format(Array.newWith(element.getClass().getClassname(), element.getID()))
			end
			path = path + objectName
			
			if pCharacterAnimation != null
				path = path + pCharacterAnimation.getName()
				
			else
				path = path + "Object"
			end
			
			return path.getPath()
		end
	end
	
	
	
	private var ECBehaviorComponent pComponent
	private var ECBCharacterConfiguration pCharacter
	private var ECBCapturedAnimations pCapturedAnimations
	private var Set pBones
	private var Set pRootBones
	private var Set pIgnoreBones
	
	
	
	/** Create behavior element class. */
	public func new(BehaviorElementClass eclass, ECBehaviorComponent component,\
	ECBCharacterConfiguration characterConfiguration) super(eclass)
		pComponent = component
		pCharacter = characterConfiguration
		
		pBones = Set.new()
		pRootBones = Set.new()
		pIgnoreBones = Set.new()
		
		eclass.addBehavior(this)
	end
	
	/** Create behavior element class. */
	public func new(BehaviorElementClass eclass, ECBehaviorComponent component,\
	ECBCapturedAnimations capturedAnimations) super(eclass)
		pComponent = component
		pCapturedAnimations = capturedAnimations
		
		pBones = Set.new()
		pRootBones = Set.new()
		pIgnoreBones = Set.new()
		
		eclass.addBehavior(this)
	end
	
	/** Dispose of behavior. */
	public func void dispose()
		pCharacter = null
		pCapturedAnimations = null
		pComponent = null
		super.dispose()
	end
	
	
	
	/** Component behavior. */
	public func ECBehaviorComponent getComponent()
		return pComponent
	end
	
	/** Character configuration behavior or null. */
	public func ECBCharacterConfiguration getCharacter()
		return pCharacter
	end
	
	/** Captured animations behavior or null. */
	public func ECBCapturedAnimations getCapturedAnimations()
		return pCapturedAnimations
	end
	
	
	
	/** Bones to record. Set of String. */
	public func Set getBones()
		return pBones
	end
	
	/** Add bone to record if not present. */
	public func void addBone(String bone)
		pBones.add(bone)
	end
	
	/** Add bones to record if not present. Expects Array of String. */
	public func void addBones(Array bones)
		pBones.addAll(Set.newFrom(bones))
	end
	
	
	
	/** Root bones. Set of String. */
	public func Set getRootBones()
		return pRootBones
	end
	
	/** Add root bone if not present. */
	public func void addRootBone(String bone)
		pRootBones.add(bone)
	end
	
	/** Add root bones if not present. Expects Array of String. */
	public func void addRootBones(Array rootBones)
		pRootBones.addAll(Set.newFrom(rootBones))
	end
	
	
	
	/** Bones to ignore. Set of String. */
	public func Set getIgnoreBones()
		return pIgnoreBones
	end
	
	/** Add bone to ignore if not present. */
	public func void addIgnoreBone(String bone)
		pIgnoreBones.add(bone)
	end
	
	/** Add bones to ignore if not present. Expects Array of String. */
	public func void addIgnoreBones(Array bones)
		pIgnoreBones.addAll(Set.newFrom(bones))
	end
	
	
	
	/** Get instance in element from owner element class. */
	public func Instance instance( BehaviorElement element )
		return element.getInstanceAt( this.getInstanceIndex() ) cast Instance
	end
	
	/** Get behavior in element class or null if absent. */
	static public func ECBRecordAnimation getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBRecordAnimation each
			return true
		end) cast ECBRecordAnimation
	end
	
	/** Get instance with slot name in element or null if absent. */
	static public func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	/** Create Behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
