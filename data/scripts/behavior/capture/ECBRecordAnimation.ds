/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Actors
pin Democap.Characters

pin Dragengine.Gui
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Behavior adding support to record animations.
 * 
 * \see https://developer.dragondreams.ch/wiki/doku.php/democap:behavior_ecbrecordanimation
 */
class ECBRecordAnimation extends DefaultECBehavior
	/** Listener. */
	interface Listener
		/** Prepare recording. Called when recording delays starts. */
		func void prepareRecording(Instance instance)
		
		/** Recording starts. Called when recording delay ends. */
		func void startRecording(Instance instance)
		
		/** Recording stopped. */
		func void stopRecording(Instance instance)
	end
	
	/** Default listener implementation. */
	class DefaultListener implements Listener
		/** Create listener. */
		func new()
		end
		
		/** Prepare recording. Called when recording delays starts. */
		func void prepareRecording(Instance instance)
		end
		
		/** Recording starts. Called when recording delay ends. */
		func void startRecording(Instance instance)
		end
		
		/** Recording stopped. */
		func void stopRecording(Instance instance)
		end
	end
	
	/**
	 * Behavior factory.
	 * 
	 * Automatically assigns these behaviors if present before adding:
	 * - Optional: \ref ECBehaviorComponent
	 * - Optional: \ref ECBCapturedAnimations
	 * 
	 * Example XML element class:
	 * \code{.xml}
	 * <behavior type='ECBehaviorComponent'/>
	 * <behavior type='ECBCapturedAnimations'/>
	 * 
	 * <behavior type='ECBRecordAnimation'>
	 * </behavior>
	 * \endcode
	 */
	class Factory implements BehaviorFactory
		func new()
		end
		
		func String factoryId()
			return "ECBRecordAnimation"
		end
		
		func ECBehavior addBehavior(BehaviorElementClass eclass, String id, Dictionary parameters)
			if not id.empty()
				throw EInvalidParam.new("id is not empty string")
			end
			
			return ECBRecordAnimation.new(eclass,\
				eclass.sharedFactoryHelper.defaultComponent(eclass, parameters),\
				ECBCapturedAnimations.getBehaviorIn(eclass))
		end
	end
	
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		class RecordDeviceSlot
			protected var CharacterConfiguration pConfig
			protected var ECBTrackerSlot.Instance pSlot
			protected var int pBone
			protected var Matrix pMatrix1, pMatrix2
			
			func new(CharacterConfiguration config, ECBTrackerSlot.Instance slot,\
			int bone, Matrix matrix1, Matrix matrix2)
				pConfig = config
				pSlot = slot
				pBone = bone
				pMatrix1 = matrix1
				pMatrix2 = matrix2
			end
			
			func Matrix calcMatrix()
				var Matrix m = pMatrix1 * pSlot.getMatrixCharacter()
				m = pConfig.characterToActor(m) * pConfig.getMatrixCalibrateInverse()
				m = pConfig.actorToComponent(m) * pMatrix2
				return m
			end
		end
		
		class RecordStateChanged extends RecordScene.DefaultListener
			protected var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func void prepareRecording(RecordScene recordScene)
				pInstance.prepareRecording()
			end
			
			func void startRecording(RecordScene recordScene)
				pInstance.startRecording()
			end
			
			func void stopRecording(RecordScene recordScene)
				pInstance.stopRecording()
			end
		end
		
		
		var ECBRecordAnimation pECBehavior
		var ECBehaviorComponent.Instance pComponent
		var ECBCharacterConfiguration.Instance pCharacter
		var ECBCapturedAnimations.Instance pCapturedAnimations
		var Array pBoneIndices
		var Array pRootBoneIndices
		var Array pStaticBoneIndices
		var Array pStaticRootBoneIndices
		var Matrix pTransformRootBones
		var int pOriginBoneIndex
		var Array pOriginChildrenIndices
		var Array pVPSIndices
		var Array pStaticVPSIndices
		var RecordAnimation pRecordAnimation
		var RecordAnimation pRecordAnimationDevices
		var RecordAnimation pRecordAnimationObject
		var CharacterAnimation pCharacterAnimation
		var SessionSettings.RecordDevices pRecordDevices
		var Array pRecordDeviceSlots
		var bool pIsPreparing
		var bool pIsRecording
		var float pRecordTime
		var bool pIncrementTime
		var Array pListeners
		var bool pFullRecording
		var bool pRecordObject
		var bool pFirstFrame
		var RecordStateChanged pRecordStateChanged
		var bool pAutoStopRecord
		
		
		
		/** Create instance. */
		func new(ECBRecordAnimation ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pBoneIndices = Array.new()
			pRootBoneIndices = Array.new()
			pStaticBoneIndices = Array.new()
			pStaticRootBoneIndices = Array.new()
			pOriginBoneIndex = -1
			pOriginChildrenIndices = Array.new()
			pRecordDeviceSlots = Array.new()
			pListeners = Array.new()
			pTransformRootBones = Matrix.new()
			pVPSIndices = Array.new()
			pStaticVPSIndices = Array.new()
			
			pComponent = ecbehavior.getComponent().instance(element)
			if ecbehavior.getCharacter() != null
				pCharacter = ecbehavior.getCharacter().instance(element)
			end
			if ecbehavior.getCapturedAnimations() != null
				pCapturedAnimations = ecbehavior.getCapturedAnimations().instance(element)
			end
			
			pRecordStateChanged = RecordStateChanged.new(this)
			GameApp.getGameApp().getRecordScene().addListener(pRecordStateChanged)
			
			setRequiresThink(true)
		end
		
		/** Dispose of instance. */
		func void dispose()
			if pRecordStateChanged != null
				GameApp.getGameApp().getRecordScene().removeListener(pRecordStateChanged)
				pRecordStateChanged = null
			end
			
			pCapturedAnimations = null
			pListeners = null
			pCharacter = null
			pComponent = null
			super.dispose()
		end
		
		/** Init behavior instance. */
		func void init(StubElement stub)
		end
		
		
		
		/** Behavior. */
		func ECBRecordAnimation getECBehavior()
			return pECBehavior
		end
		
		/** Component. */
		func ECBehaviorComponent.Instance getComponent()
			return pComponent
		end
		
		
		
		/** Record animation or null. */
		func RecordAnimation getRecordAnimation()
			return pRecordAnimation
		end
		
		/** Record devices animation or null. */
		func RecordAnimation getRecordAnimationDevices()
			return pRecordAnimationDevices
		end
		
		/** Record object animation or null. */
		func RecordAnimation getRecordAnimationObject()
			return pRecordAnimationObject
		end
		
		/** Character or null. */
		func ECBCharacterConfiguration.Instance getCharacter()
			return pCharacter
		end
		
		/** Character animation or null. */
		func CharacterAnimation getCharacterAnimation()
			return pCharacterAnimation
		end
		
		/** Captured animations or null. */
		func ECBCapturedAnimations.Instance getCapturedAnimations()
			return pCapturedAnimations
		end
		
		
		
		/** Is preparing to record. */
		func bool isPreparing()
			return pIsPreparing
		end
		
		/** Is recording animation. */
		func bool isRecording()
			return pIsRecording
		end
		
		/** Is preparing or recording. */
		func bool isPreparingOrRecording()
			return pIsPreparing or pIsRecording
		end
		
		/** Is not recording nor preparing. */
		func bool isNotRecording()
			return not pIsRecording and not pIsPreparing
		end
		
		/** Prepare to record. */
		func void prepareRecording()
			if pIsPreparing or pIsRecording
				return
			end
			if pCharacter != null and GameApp.getGameApp().getWorldSpawnCharacter().getActor() != getElement()
				// NOTE later on this could be enabled in the form of passive recording
				return
			end
			
			// find captured animations to use
			var BehaviorElement capturedElement
			
			if pCharacter != null
				var ECBCapturable.Instance captured = GameApp.getGameApp().getCapturableTracker().getElement()
				if captured != null
					capturedElement = captured.getElement()
					pCapturedAnimations = ECBCapturedAnimations.getInstanceIn(capturedElement)
					if pCapturedAnimations.getCaptureTarget() == ECBCapturedAnimations.CaptureTarget.character
						if not pCapturedAnimations.getCharacterProfile().equals(pCharacter.getCharacter().getProfile().getName())
							throw EInvalidParam.new("character profile mismatch")
						end
						
					else
						pCapturedAnimations = null
					end
				end
			end
			
			// this check is only used if this is not the captured character or this is not
			// a CapturedCharacter. for captured character recording is always enabled.
			// 
			// right now this check affects only non-CapturedCharacter objects because
			// not captured CapturedCharacter are ruled out above in the "NOTE". to enable
			// recording for other objects new code has to be done since this behavior is
			// present on the MoCap actor but not CapturedCharacter
			if pCharacter == null
				if pCapturedAnimations != null and not pCapturedAnimations.getRecord()
					return
				end
			end
			
			// find animation to record
			pCharacterAnimation = null
			pFullRecording = false
			pRecordObject = false
			
			if pCapturedAnimations != null
				pCharacterAnimation = pCapturedAnimations.getAnimations().getActive()
				pFullRecording = pCapturedAnimations.getAnimations().getAt(0) == pCharacterAnimation
				pRecordObject = pCapturedAnimations.getRecordObject()
			end
			
			// prepare capturing
			pFirstFrame = true
			
			pRecordAnimation = RecordAnimation.new()
			pRecordAnimation.setFPS(SessionSettings.get().getModelRecordFrameRate().getValue())
			pRecordAnimation.setMoveName("MoCap")
			
			pRecordDevices = SessionSettings.get().getRecordDevices()
			
			pRecordDeviceSlots.removeAll()
			
			if pRecordDevices != SessionSettings.RecordDevices.none and pCharacter != null
				pRecordAnimationDevices = RecordAnimation.new("-devices")
				pRecordAnimationDevices.setFPS(pRecordAnimation.getFPS())
				pRecordAnimationDevices.setMoveName("MoCapDevices")
				pRecordAnimationDevices.createRig(pCharacter.getCharacter())
			end
			
			if pRecordObject
				pRecordAnimationObject = RecordAnimation.new("-object")
				pRecordAnimationObject.setFPS(pRecordAnimation.getFPS())
				pRecordAnimationObject.setMoveName("MoCapObject")
				pRecordAnimationObject.createObjectRig()
			end
			
			if pCharacter != null
				if pFullRecording
					prepareAllBoneIndices()
					prepareAllVPSIndices()
					
				else
					prepareBoneIndices()
					prepareVPSIndices()
				end
				prepareOriginBone()
				
			else
				prepareObjectBones()
			end
			
			pTransformRootBones = Matrix.new()
			
			/*
			if pCharacterAnimation != null
				pCharacterAnimation.clear()
				pCapturedAnimations.getAnimations().notifyAnimationChanged(pCharacterAnimation)
			end
			*/
			
			var BehaviorElement element = getElement()
			
			if capturedElement != null
				// ensure actor element lines up with captured element. if this is not
				// the case the captured animation would be played back at the wrong
				// position. we could calculate the transformation matrix from actor
				// element in captured element coordinate system but this hides the
				// problem and causes troubles later on while using the animation
// 				element.setGeometry(capturedElement.getPosition(), capturedElement.getOrientation())
				pTransformRootBones = (element.getElementMatrix().normalize()\
					* capturedElement.getInverseElementMatrix().normalize()).toMatrix()
			end
			
			// if physics attachments are used init collider bone states from component.
			// this is required since collider bone states are in world space and do not
			// move if the actor moves due to teleportation
			/*
			var Collider collider = ECBehaviorCollider.getInstanceIn(element).getCollider()
			if collider.getResponseType() == CollisionResponse.dynamic\
			and collider castable ColliderComponent
				(collider cast ColliderComponent).copyStatesFromComponent()
			end
			*/
			
			if pRecordDevices != SessionSettings.RecordDevices.none and pCharacter != null
				// has to be done after pTransformRootBones has been calculated
				var CharacterConfiguration config = pCharacter.getCharacter()
				var Rig rig = pRecordAnimationDevices.getRig()
				
				config.getTrackerSlots().forEach(block int index, CharacterTrackerSlot each
					var ECBTrackerSlot.Instance slot = ECBTrackerSlot.getInstanceIn(getElement(), each.getName())
					var Matrix matrix1
					
					select pRecordDevices
					case SessionSettings.RecordDevices.device
						matrix1 = Matrix.new()
						
					case SessionSettings.RecordDevices.reference
						matrix1 = each.getCalibrateReferenceMatrix()\
							* each.getCalibrateMatrixInverseOriginal()
						
					case SessionSettings.RecordDevices.target
						matrix1 = each.getCalibrateReferenceMatrix()\
							* each.getCalibrateMatrixInverseOriginal()\
							* each.getTargetMatrix()\
							* each.getCalibrateReferenceMatrixInverse()
					end
					
					var Matrix matrix2 = pTransformRootBones * rig.getBoneInverseMatrix(index)
					
					pRecordDeviceSlots.add(RecordDeviceSlot.new(config, slot, index, matrix1, matrix2))
					pRecordAnimationDevices.addBone(each.getName())
				end)
			end
			
			if pRecordAnimationObject != null
				var Rig rig = pRecordAnimationObject.getRig()
				var int i, count = rig.getBoneCount()
				for i = 0 to count
					pRecordAnimationObject.addBone(rig.boneGetName(i))
				end
			end
			
			pIsPreparing = true
			
			pAutoStopRecord = SessionSettings.get().getModelAutoStopRecord().getToggled()\
				and GameApp.getGameApp().getPlaybackScene().getPlaytime() > 0
			
			pListeners.forEach(block Listener each
				each.prepareRecording(this)
			end)
		end
		
		
		
		/**
		 * Prepare bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareBoneIndices()
			// order is important: add first all root bones then all non-root bones
			var Set ignoreBones = pECBehavior.getIgnoreBones()
			
			var Component component = pComponent.getComponent()
			var Rig rig = component.getRig()
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1
						pRootBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			pECBehavior.getBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and not pRootBoneIndices.has(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
		end
		
		/** Prepare vertex position set indices */
		protected func void prepareVPSIndices()
			var Set ignoreVPS = pECBehavior.getIgnoreVPS()
			var Component component = pComponent.getComponent()
			
			pVPSIndices.removeAll()
			pStaticVPSIndices.removeAll()
			
			pECBehavior.getVPS().forEach(block String vps
				if not ignoreVPS.has(vps)
					var int index = component.indexOfVertexPositionSetNamed(vps)
					if index != -1
						pVPSIndices.add(index)
						pRecordAnimation.addVPS(vps)
					end
				end
			end)
		end
		
		/**
		 * Prepare all bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareAllBoneIndices()
			// order is important: add first all root bones then all non-root bones
			var Set ignoreBones = pECBehavior.getIgnoreBones()
			var Rig rig = pComponent.getComponent().getRig()
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			// add root bones. since all bone indices are added it is important to add root
			// bones only as root bones if they are true root bones (of the entire component)
			// not just root bones of all captured bone chains. if this split is not done the
			// root bone transform is applied twice causing problems
			var Array allRootBones = Array.new()
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and rig.boneGetParent(index) == -1
						allRootBones.add(index)
						pRootBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and rig.boneGetParent(index) != -1
						allRootBones.add(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			// add regular bones as in the not all mode
			pECBehavior.getBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and not allRootBones.has(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			// add static bones
			var int i, count = rig.getBoneCount()
			
			for i = 0 to count
				if rig.boneGetParent(i) == -1 and not allRootBones.has(i) and not pBoneIndices.has(i)
					pStaticRootBoneIndices.add(i)
					pRecordAnimation.addBone(rig.boneGetName(i))
				end
			end
			
			for i = 0 to count
				if rig.boneGetParent(i) != -1 and not allRootBones.has(i) and not pBoneIndices.has(i)
					pStaticBoneIndices.add(i)
					pRecordAnimation.addBone(rig.boneGetName(i))
				end
			end
		end
		
		/** Prepare all vertex position set indices */
		protected func void prepareAllVPSIndices()
			var Set ignoreVPS = pECBehavior.getIgnoreVPS()
			var Component component = pComponent.getComponent()
			
			pVPSIndices.removeAll()
			pStaticVPSIndices.removeAll()
			
			// add vertex position sets as in the not all mode
			pECBehavior.getVPS().forEach(block String vps
				if not ignoreVPS.has(vps)
					var int index = component.indexOfVertexPositionSetNamed(vps)
					if index != -1
						pVPSIndices.add(index)
						pRecordAnimation.addVPS(vps)
					end
				end
			end)
			
			// add static vertex position sets
			var int i, count = component.getVertexPositionSetCount()
			
			for i = 0 to count
				if not pVPSIndices.has(i)
					pStaticVPSIndices.add(i)
					pRecordAnimation.addVPS(component.vertexPositionSetGetNameAt(i))
				end
			end
		end
		
		/** Prepare origin bone. */
		protected func void prepareOriginBone()
			pOriginBoneIndex = -1
			pOriginChildrenIndices.removeAll()
			
			if pCharacter == null
				return
			end
			
			var String originBone = pCharacter.getCharacter().getProfile().getOriginBone()
			pRecordAnimation.setOriginBone(originBone)
			
			var Rig rig = pComponent.getComponent().getRig()
			pOriginBoneIndex = rig.indexOfBoneNamed(originBone)
			if pOriginBoneIndex == -1
				return
			end
			
			if rig.boneGetParent(pOriginBoneIndex) != -1
				// origin bone is not a root bone. this is not supported
				pOriginBoneIndex = -1
				return
			end
			
			(pBoneIndices + pStaticBoneIndices).forEach(block int index
				if rig.boneGetParent(index) == pOriginBoneIndex
					pOriginChildrenIndices.add(index)
				end
			end)
			
			if pOriginChildrenIndices.getCount() == 0\
			and not pRootBoneIndices.has(pOriginBoneIndex)\
			and not pStaticRootBoneIndices.has(pOriginBoneIndex)
				// adjusting origin bone transform has no effect so skip it
				pOriginBoneIndex = -1
			end
		end
		
		/**
		 * Prepare object bone indices. For each bone find also the root bone.
		 * All bones are dynamic.
		 */
		protected func void prepareObjectBones()
			// order is important: add first all root bones then all non-root bones
			var Set ignoreBones = pECBehavior.getIgnoreBones()
			var Rig rig = pComponent.getComponent().getRig()
			var int i, boneCount = rig.getBoneCount()
			var String bone
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			// add root bones
			for i = 0 to boneCount
				bone = rig.boneGetName(i)
				if not ignoreBones.has(bone) and rig.boneGetParent(i) == -1
					pRootBoneIndices.add(i)
					pRecordAnimation.addBone(bone)
				end
			end
			
			// add regular bones
			for i = 0 to boneCount
				bone = rig.boneGetName(i)
				if not ignoreBones.has(bone) and rig.boneGetParent(i) != -1
					pBoneIndices.add(i)
					pRecordAnimation.addBone(bone)
				end
			end
		end
		
		/** Start recording animation. */
		func void startRecording()
			if not (pIsPreparing and not pIsRecording)
				return
			end
			
			pIsPreparing = false
			pIsRecording = true
			pRecordTime = 0
			pIncrementTime = false
			
			pListeners.forEach(block Listener each
				each.startRecording(this)
			end)
		end
		
		/** Stop recording animation. */
		func void stopRecording()
			var GameApp app = GameApp.getGameApp()
			
			pAutoStopRecord = false
			
			if pIsRecording
				pIsRecording = false
				
				if pRecordAnimation != null
					pRecordAnimation.createAnimation()
					if pRecordAnimationDevices != null
						pRecordAnimationDevices.createAnimation()
					end
					if pRecordAnimationObject != null
						pRecordAnimationObject.createAnimation()
					end
					
					if pCharacterAnimation != null
						var Project project = app.getProject()
						var File directory = app.getProject().getDataDirectory()
						var Project.AnimationPath animPath = project.nextAnimationPath()
						
						if pRecordAnimation.getAnimation() != null
							pRecordAnimation.getAnimation().save((directory + animPath.getPath()).getPath())
						end
						if pRecordAnimationDevices != null
							pRecordAnimationDevices.getRig().save((directory + animPath.getPathDevicesRig()).getPath())
							pRecordAnimationDevices.getAnimation().save((directory + animPath.getPathDevices()).getPath())
						end
						if pRecordAnimationObject != null
							pRecordAnimationObject.getRig().save((directory + animPath.getPathObjectRig()).getPath())
							pRecordAnimationObject.getAnimation().save((directory + animPath.getPathObject()).getPath())
						end
						
						writeCaptureInfoFile((directory + animPath.getPathMeta()).getPath(),\
							animPath.getPath(), animPath.getPathDevices(), animPath.getPathDevicesRig(),\
							animPath.getPathObject(), animPath.getPathObjectRig())
						
						pCharacterAnimation.clear()
						
						pCharacterAnimation.setPathMeta(animPath.getPathMeta())
						
						if pRecordAnimation.getAnimation() != null
							pCharacterAnimation.setPath(animPath.getPath())
							pCharacterAnimation.setAnimation(pRecordAnimation.getAnimation())
						end
						if pRecordAnimationDevices != null
							pCharacterAnimation.setPathDevices(animPath.getPathDevices())
							pCharacterAnimation.setPathDevicesRig(animPath.getPathDevicesRig())
							pCharacterAnimation.setAnimationDevices(pRecordAnimationDevices.getAnimation())
							pCharacterAnimation.setRigDevices(pRecordAnimationDevices.getRig())
						end
						if pRecordAnimationObject != null
							pCharacterAnimation.setPathObject(animPath.getPathObject())
							pCharacterAnimation.setPathObjectRig(animPath.getPathObjectRig())
							pCharacterAnimation.setAnimationObject(pRecordAnimationObject.getAnimation())
							pCharacterAnimation.setRigObject(pRecordAnimationObject.getRig())
						end
						
						if pCapturedAnimations != null
							pCapturedAnimations.getAnimations().notifyAnimationChanged(pCharacterAnimation)
							
							if app.getSessionSettings().getModelAutoExport().getToggled()
								pCharacterAnimation.export(project, getAutoExportPath())
							end
						end
						
					else
						if pRecordAnimation.getAnimation() != null
							pRecordAnimation.getAnimation().save(pRecordAnimation.getPath())
						end
						
						var String pathDevices = "", pathDevicesRig = ""
						if pRecordAnimationDevices != null
							pathDevicesRig = pRecordAnimationDevices.getPathRig()
							pathDevices = pRecordAnimationDevices.getPath()
							
							if pRecordAnimationDevices.getRig() != null
								pRecordAnimationDevices.getRig().save(pathDevicesRig)
							end
							if pRecordAnimationDevices.getAnimation() != null
								pRecordAnimationDevices.getAnimation().save(pathDevices)
							end
						end
						
						var String pathObject = "", pathObjectRig = ""
						if pRecordAnimationObject != null
							pathObjectRig = pRecordAnimationObject.getPathRig()
							pathObject = pRecordAnimationObject.getPath()
							
							if pRecordAnimationObject.getRig() != null
								pRecordAnimationObject.getRig().save(pathObjectRig)
							end
							if pRecordAnimationObject.getAnimation() != null
								pRecordAnimationObject.getAnimation().save(pathObject)
							end
						end
						
						writeCaptureInfoFile(pRecordAnimation.getPathMeta(), pRecordAnimation.getPath(),\
							pathDevices, pathDevicesRig, pathObject, pathObjectRig)
					end
				end
				
				pRecordAnimation = null
				pRecordAnimationDevices = null
				pRecordAnimationObject = null
				pCharacterAnimation = null
				pTransformRootBones = Matrix.new()
				
			elif pIsPreparing
				pIsPreparing = false
				pRecordAnimation = null
				pRecordAnimationDevices = null
				pRecordAnimationObject = null
				pCharacterAnimation = null
				pTransformRootBones = Matrix.new()
				
			else
				return
			end
			
			pListeners.forEach(block Listener each
				each.stopRecording(this)
			end)
		end
		
		
		
		/** Add listener. */
		func void addListener(Listener listener)
			pListeners.add(listener)
		end
		
		/** Remove listener. */
		func void removeListener(Listener listener)
			pListeners.remove(listener)
		end
		
		
		
		/** Frame update. */
		func void think(float elapsed)
			if pIsRecording and pAutoStopRecord
				var PlaybackScene playback = GameApp.getGameApp().getPlaybackScene()
				if playback.getTime() == playback.getPlaytime()
					stopRecording()
				end
			end
		end
		
		/** Post think. Called after rendering and thus when animation frame is ready to record. */
		func void postThink(float elapsed)
			if not pIsRecording and not GameApp.getGameApp().getServer().isListening()
				return
			end
			
			pComponent.getComponent().updateBones()
			
			if pIsRecording
				if pIncrementTime
					pRecordTime += elapsed
				end
				pIncrementTime = true
				
				if pRecordAnimation != null
					captureFrame()
				end
				
				if pRecordAnimationObject != null and pCapturedAnimations != null
					var BehaviorElement element = pCapturedAnimations.getElement()
					pRecordAnimationObject.addKeyframe(pRecordTime,\
						element.getPosition().toVector(), element.getOrientation())
					pRecordAnimationObject.addKeyframe(pRecordTime, Vector.new(), Quaternion.new()) // attached
				end
			end
		end
		
		/** Capture frame. */
		protected func void captureFrame()
			var Component component = pComponent.getComponent()
			
			// bones
			var Matrix originTransform = Matrix.new()
			if pOriginBoneIndex != -1
				originTransform = pTransformRootBones * component.getBoneOriginInverseMatrix(pOriginBoneIndex)
			end
			
			var Matrix matrix
			pRootBoneIndices.forEach(block int index
				if index == pOriginBoneIndex
					matrix = Matrix.new()
				else
					matrix = component.boneGetMatrix(index) * pTransformRootBones\
						* component.getBoneOriginInverseMatrix(index)
				end
				pRecordAnimation.addKeyframe(pRecordTime, matrix.getPosition(), matrix.normalize().toQuaternion())
			end)
			
			pBoneIndices.forEach(block int index
				if pOriginChildrenIndices.has(index)
					matrix = component.boneGetMatrix(index) * originTransform\
						* component.getBoneOriginInverseMatrix(index)
					pRecordAnimation.addKeyframe(pRecordTime, matrix.getPosition(), matrix.normalize().toQuaternion())
				else
					pRecordAnimation.addKeyframe(pRecordTime, \
						component.boneGetPosition(index), component.boneGetRotation(index))
				end
			end)
			
			// vertex position sets
			pVPSIndices.forEach(block int index
				pRecordAnimation.addVPSKeyframe(pRecordTime, component.vertexPositionSetGetWeightAt(index))
			end)
			
			// static
			if pFirstFrame
				pFirstFrame = false
				
				// static bones
				pStaticRootBoneIndices.forEach(block int index
					if index == pOriginBoneIndex
						matrix = Matrix.new()
					else
						matrix = component.boneGetMatrix(index) * pTransformRootBones\
							* component.getBoneOriginInverseMatrix(index)
					end
					pRecordAnimation.addStaticKeyframe(matrix.getPosition(), matrix.normalize().toQuaternion())
				end)
				
				pStaticBoneIndices.forEach(block int index
					if pOriginChildrenIndices.has(index)
						matrix = component.boneGetMatrix(index) * originTransform\
							* component.getBoneOriginInverseMatrix(index)
						pRecordAnimation.addStaticKeyframe(matrix.getPosition(), matrix.normalize().toQuaternion())
					else
						pRecordAnimation.addStaticKeyframe(\
							component.boneGetPosition(index), component.boneGetRotation(index))
					end
				end)
				
				// static vertex position sets
				pStaticVPSIndices.forEach(block int index
					pRecordAnimation.addVPSStaticKeyframe(component.vertexPositionSetGetWeightAt(index))
				end)
			end
			
			// devices
			pRecordDeviceSlots.forEach(block RecordDeviceSlot each
				matrix = each.calcMatrix()
				pRecordAnimationDevices.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
			end)
		end
		
		/** Write capture information file. */
		func void writeCaptureInfoFile(String path, String animPath, String animDevicesPath,\
		String animDevicesRigPath, String animObjectPath, String animObjectRigPath)
			var EasyXML document = EasyXML.new()
			var EasyXMLElement root = document.getRootElement()
			var TimeDate timestamp = pRecordAnimation.getTimestamp()
			
			root.setTagName("mocapAnimation")
			
			// make path relative
			if not animPath.empty()
				animPath = File.new(animPath).getComponentAt(-1)
			end
			if not animDevicesPath.empty()
				animDevicesPath = File.new(animDevicesPath).getComponentAt(-1)
			end
			if not animDevicesRigPath.empty()
				animDevicesRigPath = File.new(animDevicesRigPath).getComponentAt(-1)
			end
			if not animObjectPath.empty()
				animObjectPath = File.new(animObjectPath).getComponentAt(-1)
			end
			if not animObjectRigPath.empty()
				animObjectRigPath = File.new(animObjectRigPath).getComponentAt(-1)
			end
			
			// general information
			root.addDataTag("timestamp", timestamp.format("%Y-%m-%dT%H:%M:%S"))
			
			// actor
			if pCharacter != null
				var ActorProfile actorProfile = GameApp.getGameApp().getActiveActorProfile()
				if actorProfile != null
					var EasyXMLElement tag = root.addTag("actor")
					tag.addDataTag("profileName", actorProfile.getName())
					tag.addDataTag("shoulderLevel", actorProfile.getShoulderLevel())
					tag.addDataTag("shoulderWide", actorProfile.getShoulderWidth())
					tag.addDataTag("armLength", actorProfile.getArmLength())
					tag.addDataTag("legLength", actorProfile.getLegLength())
				end
				
			else
				var EasyXMLElement tag = root.addTag("object")
				tag.addDataTag("elementClass", getElement().getClass().getClassname())
				tag.addDataTag("identifier", getElement().getID().toHexString())
			end
			
			// character
			var String originBone = ""
			
			if pCharacter != null
				var CharacterProfile profile = pCharacter.getCharacter().getProfile()
				originBone = profile.getOriginBone()
				
				var EasyXMLElement tag = root.addTag("character")
				tag.addDataTag("profileName", profile.getName())
				tag.addDataTag("configurationName", pCharacter.getCharacter().getName())
				
				tag.addDataTag("originBone", originBone)
				tag.addDataTag("shoulderLevel", profile.getShoulderLevel())
				tag.addDataTag("scaleMode", pCharacter.getCharacter().getScaleMode().name())
				tag.addDataTag("calibratedScale", pCharacter.getCharacter().getCalibrateScale())
				
				var CharacterAppearance appearance = profile.getAppearance()
				var EasyXMLElement tagAppearance = tag.addTag("appearance")
				tagAppearance.addDataTag("pathModel", appearance.getPathModel())
				tagAppearance.addDataTag("pathSkin", appearance.getPathSkin())
				tagAppearance.addDataTag("pathRig", appearance.getPathRig())
				tagAppearance.addDataTag("pathAnimation", appearance.getPathAnimation())
			end
			
			// animation
			var Animation animation = pRecordAnimation.getAnimation()
			if animation != null
				var bool hasOriginBone = not originBone.empty() and not pRecordAnimation.hasBone(originBone)
				var String moveName = animation.getMoveName(0)
				
				var EasyXMLElement tagAnimation = root.addTag("capturedAnimation")
				tagAnimation.addDataTag("pathAnimation", animPath)
				tagAnimation.addDataTag("moveName", moveName)
				tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
				tagAnimation.addDataTag("frameRate", pRecordAnimation.getFPS())
				
				if hasOriginBone
					tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount() + 1)
					
				else
					tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount())
				end
				
				var EasyXMLElement tagBones = tagAnimation.addTag("bones")
				pRecordAnimation.forEachBone(block String each
					tagBones.addDataTag("boneName", each)
				end)
				
				if hasOriginBone
					tagBones.addDataTag("boneName", originBone)
				end
				
				tagAnimation.addDataTag("vertexPositionSetCount", pRecordAnimation.getVPSCount())
				
				var EasyXMLElement tagVPS = tagAnimation.addTag("vertexPositionSets")
				pRecordAnimation.forEachVPS(block String each
					tagVPS.addDataTag("vertexPositionSetName", each)
				end)
			end
			
			// devices animation
			if pRecordAnimationDevices != null and not animDevicesPath.empty()
				animation = pRecordAnimationDevices.getAnimation()
				var String moveName = animation.getMoveName(0)
				
				var EasyXMLElement tagAnimation = root.addTag("capturedAnimationDevices")
				tagAnimation.addDataTag("pathAnimation", animDevicesPath)
				
				if not animDevicesRigPath.empty()
					tagAnimation.addDataTag("pathRig", animDevicesRigPath)
				end
				
				tagAnimation.addDataTag("moveName", moveName)
				tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
				tagAnimation.addDataTag("frameRate", pRecordAnimationDevices.getFPS())
				tagAnimation.addDataTag("boneCount", pRecordAnimationDevices.getBoneCount())
				
				var EasyXMLElement tagBones = tagAnimation.addTag("bones")
				pRecordAnimationDevices.forEachBone(block String each
					tagBones.addDataTag("boneName", each)
				end)
			end
			
			// object animation
			if pRecordAnimationObject != null and not animObjectPath.empty()
				animation = pRecordAnimationObject.getAnimation()
				if animation != null
					var String moveName = animation.getMoveName(0)
					
					var EasyXMLElement tagAnimation = root.addTag("capturedAnimationObject")
					tagAnimation.addDataTag("pathAnimation", animObjectPath)
					
					if not animObjectRigPath.empty()
						tagAnimation.addDataTag("pathRig", animObjectRigPath)
					end
					
					tagAnimation.addDataTag("moveName", moveName)
					tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
					tagAnimation.addDataTag("frameRate", pRecordAnimationObject.getFPS())
					
					var EasyXMLElement tagBones = tagAnimation.addTag("bones")
					pRecordAnimationObject.forEachBone(block String each
						tagBones.addDataTag("boneName", each)
					end)
				end
			end
			
			// write to file
			document.writeToFile(FileWriter.new(path), false)
		end
		
		/** Create auto export path. */
		func String getAutoExportPath()
			var Scene scene = GameApp.getGameApp().getScene()
			var File path = File.new(scene.getName())
			
			var StageDirection stageDirection = scene.getStageDirections().getSelected()
			if stageDirection != null
				path = path + stageDirection.getName()
			end
			
			var BehaviorElement element = getElement()
			if pCapturedAnimations != null
				element = pCapturedAnimations.getElement()
			end
			
			var ECBSceneObject.Instance sceneObject = ECBSceneObject.getInstanceIn(element)
			var String objectName = sceneObject.getName()
			if objectName.empty()
				objectName = "{}-{}".format(Array.newWith(element.getClass().getClassname(), element.getID()))
			end
			path = path + objectName
			
			if pCharacterAnimation != null
				path = path + pCharacterAnimation.getName()
				
			else
				path = path + "Object"
			end
			
			return path.getPath()
		end
	end
	
	
	
	var ECBehaviorComponent pComponent
	var ECBCharacterConfiguration pCharacter
	var ECBCapturedAnimations pCapturedAnimations
	var Set pBones
	var Set pRootBones
	var Set pIgnoreBones
	var Set pVPS
	var Set pIgnoreVPS
	
	
	
	/** Create behavior element class. */
	func new(BehaviorElementClass eclass, ECBehaviorComponent component,\
	ECBCharacterConfiguration characterConfiguration) super(eclass)
		pComponent = component
		pCharacter = characterConfiguration
		
		pBones = Set.new()
		pRootBones = Set.new()
		pIgnoreBones = Set.new()
		pVPS = Set.new()
		pIgnoreVPS = Set.new()
		
		eclass.addBehavior(this)
	end
	
	/** Create behavior element class. */
	func new(BehaviorElementClass eclass, ECBehaviorComponent component,\
	ECBCapturedAnimations capturedAnimations) super(eclass)
		pComponent = component
		pCapturedAnimations = capturedAnimations
		
		pBones = Set.new()
		pRootBones = Set.new()
		pIgnoreBones = Set.new()
		pVPS = Set.new()
		pIgnoreVPS = Set.new()
		
		eclass.addBehavior(this)
	end
	
	/** Dispose of behavior. */
	func void dispose()
		pCharacter = null
		pCapturedAnimations = null
		pComponent = null
		super.dispose()
	end
	
	
	
	/** Component behavior. */
	func ECBehaviorComponent getComponent()
		return pComponent
	end
	
	/** Character configuration behavior or null. */
	func ECBCharacterConfiguration getCharacter()
		return pCharacter
	end
	
	/** Captured animations behavior or null. */
	func ECBCapturedAnimations getCapturedAnimations()
		return pCapturedAnimations
	end
	
	
	
	/** Bones to record. Set of String. */
	func Set getBones()
		return pBones
	end
	
	/** Add bone to record if not present. */
	func void addBone(String bone)
		pBones.add(bone)
	end
	
	/** Add bones to record if not present. Expects Array of String. */
	func void addBones(Array bones)
		pBones.addAll(Set.newFrom(bones))
	end
	
	
	
	/** Root bones. Set of String. */
	func Set getRootBones()
		return pRootBones
	end
	
	/** Add root bone if not present. */
	func void addRootBone(String bone)
		pRootBones.add(bone)
	end
	
	/** Add root bones if not present. Expects Array of String. */
	func void addRootBones(Array rootBones)
		pRootBones.addAll(Set.newFrom(rootBones))
	end
	
	
	
	/** Bones to ignore. Set of String. */
	func Set getIgnoreBones()
		return pIgnoreBones
	end
	
	/** Add bone to ignore if not present. */
	func void addIgnoreBone(String bone)
		pIgnoreBones.add(bone)
	end
	
	/** Add bones to ignore if not present. Expects Array of String. */
	func void addIgnoreBones(Array bones)
		pIgnoreBones.addAll(Set.newFrom(bones))
	end
	
	
	
	/** Vertex position sets to record. Set of String. */
	func Set getVPS()
		return pVPS
	end
	
	/** Add vertex position set to record if not present. */
	func void addVPS(String name)
		pVPS.add(name)
	end
	
	/** Add vertex position sets to record if not present. Expects Array of String. */
	func void addVPS(Array names)
		pVPS.addAll(Set.newFrom(names))
	end
	
	
	
	/** Vertex position sets to ignore. Set of String. */
	func Set getIgnoreVPS()
		return pIgnoreVPS
	end
	
	/** Add vertex position set to ignore if not present. */
	func void addIgnoreVPS(String name)
		pIgnoreVPS.add(name)
	end
	
	/** Add vertex position sets to ignore if not present. Expects Array of String. */
	func void addIgnoreVPS(Array list)
		pIgnoreVPS.addAll(Set.newFrom(list))
	end
	
	
	
	/** Get instance in element from owner element class. */
	func Instance instance( BehaviorElement element )
		return element.getInstanceAt( this.getInstanceIndex() ) cast Instance
	end
	
	/** Get behavior in element class or null if absent. */
	static func ECBRecordAnimation getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBRecordAnimation each
			return true
		end) cast ECBRecordAnimation
	end
	
	/** Get instance with slot name in element or null if absent. */
	static func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	/** Create Behavior instance. */
	func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
