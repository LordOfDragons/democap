/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Actors
pin Democap.Characters

pin Dragengine.Gui
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Behavior adding support to record animations.
 */
class ECBRecordAnimation extends DefaultECBehavior
	/** Listener. */
	interface Listener
		/** Prepare recording. Called when recording delays starts. */
		func void prepareRecording(Instance instance)
		
		/** Recording starts. Called when recording delay ends. */
		func void startRecording(Instance instance)
		
		/** Recording stopped. */
		func void stopRecording(Instance instance)
	end
	
	/** Default listener implementation. */
	class DefaultListener implements Listener
		/** Create listener. */
		public func new()
		end
		
		/** Prepare recording. Called when recording delays starts. */
		public func void prepareRecording(Instance instance)
		end
		
		/** Recording starts. Called when recording delay ends. */
		public func void startRecording(Instance instance)
		end
		
		/** Recording stopped. */
		public func void stopRecording(Instance instance)
		end
	end
	
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		private var ECBRecordAnimation pECBehavior
		private var ECBehaviorActorAnimated.Instance pActorAnimated
		private var Array pBoneIndices
		private var Array pRootBoneIndices
		private var Matrix pTransformRootBones
		private var RecordAnimation pRecordAnimation
		private var CharacterAnimation pCharacterAnimation
		private var bool pIsPreparing
		private var bool pIsRecording
		private var float pRecordTime
		private var bool pIncrementTime
		private var Component pComponent
		private var Rig pRig
		private var Array pListeners
		private var ECBCapturedAnimations.Instance pCapturedAnimations
		
		
		
		/** Create instance. */
		public func new(ECBRecordAnimation ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pBoneIndices = Array.new()
			pRootBoneIndices = Array.new()
			pListeners = Array.new()
			pTransformRootBones = Matrix.new()
			pActorAnimated = ecbehavior.getActorAnimated().instance(element)
			setRequiresThink(true)
		end
		
		/** Dispose of instance. */
		public func void dispose()
			pCapturedAnimations = null
			pListeners = null
			pActorAnimated = null
			super.dispose()
		end
		
		/** Init behavior instance. */
		public func void init(StubElement stub)
		end
		
		
		
		/** Behavior. */
		public func ECBRecordAnimation getECBehavior()
			return pECBehavior
		end
		
		/** Actor animated. */
		public func ECBehaviorActorAnimated.Instance getActorAnimated()
			return pActorAnimated
		end
		
		
		
		/** Record animation or null. */
		public func RecordAnimation getRecordAnimation()
			return pRecordAnimation
		end
		
		/** Character animation or null. */
		public func CharacterAnimation getCharacterAnimation()
			return pCharacterAnimation
		end
		
		/** Captured animations or null. */
		public func ECBCapturedAnimations.Instance getCapturedAnimations()
			return pCapturedAnimations
		end
		
		
		
		/** Is preparing to record. */
		public func bool isPreparing()
			return pIsPreparing
		end
		
		/** Is recording animation. */
		public func bool isRecording()
			return pIsRecording
		end
		
		/** Is preparing or recording. */
		public func bool isPreparingOrRecording()
			return pIsPreparing or pIsRecording
		end
		
		/** Is not recording nor preparing. */
		public func bool isNotRecording()
			return not pIsRecording and not pIsPreparing
		end
		
		/** Prepare to record. */
		public func void prepareRecording()
			stopRecording()
			
			var GameApp app = GameApp.getGameApp()
			app.getPlaybackScene().pause()
			
			pRecordAnimation = RecordAnimation.new()
			
			prepareBoneIndices()
			
			pTransformRootBones = Matrix.new()
			
			var ECBSelectable.Instance selection = app.getSelectionTracker().getElement()
			if selection != null
				var BehaviorElement selectionElement = selection.getElement()
				pCapturedAnimations = ECBCapturedAnimations.getInstanceIn(selectionElement)
				
				if pCapturedAnimations != null
					if not pCapturedAnimations.getCharacterProfile().equals(\
					app.getWorldSpawnCharacter().getCharacter().getProfile().getName())
						pCapturedAnimations = null
						throw EInvalidParam.new("character profile mismatch")
					end
					
					if pCapturedAnimations.getAnimations().getActive() == null
						pCapturedAnimations = null
						throw EInvalidParam.new("no active animation")
					end
					
					pCharacterAnimation = pCapturedAnimations.getAnimations().getActive()
					
					if pCharacterAnimation != null
						pCharacterAnimation.clear()
						GameApp.getGameApp().getProject().save()
					end
					
					// ensure actor element lines up with selection element. if this is not
					// the case the captured animation would be played back at the wrong
					// position. we could calculate the transformation matrix from actor
					// element in selection element coordinate system but this hides the
					// problem and causes troubles later on while using the animation
					var BehaviorElement element = getElement()
// 					element.setGeometry(selectionElement.getPosition(), selectionElement.getOrientation())
					
					pTransformRootBones = (element.getElementMatrix()\
						* selectionElement.getInverseElementMatrix()).toMatrix()
					
					// if physics attachments are used init collider bone states from component.
					// this is required since collider bone states are in world space and do not
					// move if the actor moves due to teleportation
					var Collider collider = ECBehaviorCollider.getInstanceIn(element).getCollider()
					if collider.getResponseType() == CollisionResponse.dynamic\
					and collider castable ColliderComponent
						(collider cast ColliderComponent).copyStatesFromComponent()
					end
				end
			end
			
			pIsPreparing = true
			
			pListeners.forEach(block Listener each
				each.prepareRecording(this)
			end)
		end
		
		/**
		 * Prepare bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareBoneIndices()
			pComponent = pActorAnimated.getComponent().getComponent()
			pRig = pComponent.getRig()
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			
			pECBehavior.getRootBones().forEach(block String bone
				var int index = pRig.indexOfBoneNamed(bone)
				if index != -1
					pRootBoneIndices.add(index)
					pRecordAnimation.addBone(bone)
				end
			end)
			
			pECBehavior.getBones().forEach(block String bone
				var int index = pRig.indexOfBoneNamed(bone)
				if index != -1 and not pRootBoneIndices.has(index)
					pBoneIndices.add(index)
					pRecordAnimation.addBone(bone)
				end
			end)
			
			pRecordAnimation.setOriginBone(GameApp.getGameApp()\
				.getWorldSpawnCharacter().getCharacter().getProfile().getOriginBone())
		end
		
		/** Start recording animation. */
		public func void startRecording()
			if not pIsPreparing
				prepareRecording()
			end
			
			pIsPreparing = false
			pIsRecording = true
			pRecordTime = 0
			pIncrementTime = false
			
			pListeners.forEach(block Listener each
				each.startRecording(this)
			end)
			
			GameApp.getGameApp().getPlaybackScene().play(false)
		end
		
		/** Stop recording animation. */
		public func void stopRecording()
			var GameApp app = GameApp.getGameApp()
			
			if pIsRecording
				pIsRecording = false
				pComponent = null
				pRig = null
				
				if pRecordAnimation != null
					pRecordAnimation.createAnimation()
					
					if pCharacterAnimation != null
						var Project project = app.getProject()
						var File directory = app.getProject().getDataDirectory()
						var Project.AnimationPath animPath = project.nextAnimationPath("deanim")
						
						pRecordAnimation.getAnimation().save((directory + animPath.getPath()).getPath())
						writeCaptureInfoFile((directory + animPath.getPathMeta()).getPath(), animPath.getPath())
						
						pCharacterAnimation.setPath(animPath.getPath())
						pCharacterAnimation.setPathMeta(animPath.getPathMeta())
						pCharacterAnimation.setAnimation(pRecordAnimation.getAnimation())
						project.save()
						
						pCapturedAnimations.getAnimations().notifyAnimationChanged(pCharacterAnimation)
						
					else
						pRecordAnimation.getAnimation().save(pRecordAnimation.getPath())
						writeCaptureInfoFile(pRecordAnimation.getPathMeta(), pRecordAnimation.getPath())
					end
				end
				
				pRecordAnimation = null
				pCharacterAnimation = null
				pCapturedAnimations = null
				pTransformRootBones = Matrix.new()
				
			elif pIsPreparing
				pIsPreparing = false
				pRecordAnimation = null
				pCharacterAnimation = null
				pCapturedAnimations = null
				pTransformRootBones = Matrix.new()
				
			else
				return
			end
			
			pListeners.forEach(block Listener each
				each.stopRecording(this)
			end)
			
			var PlaybackScene ps = app.getPlaybackScene()
			ps.stop()
			ps.updatePlaytime()
		end
		
		
		
		/** Add listener. */
		public func void addListener(Listener listener)
			pListeners.add(listener)
		end
		
		/** Remove listener. */
		public func void removeListener(Listener listener)
			pListeners.remove(listener)
		end
		
		
		
		/** Post think. Called after rendering and thus when animation frame is ready to record. */
		public func void postThink(float elapsed)
			if not pIsRecording
				return
			end
			
			if pIncrementTime
				pRecordTime += elapsed
			end
			pIncrementTime = true
			
			pComponent.updateBones()
			
			pRootBoneIndices.forEach(block int index
				var Matrix matrix = pComponent.boneGetMatrix(index)\
					* pTransformRootBones * pComponent.getBoneOriginInverseMatrix(index)
				pRecordAnimation.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
			end)
			
			pBoneIndices.forEach(block int index
				pRecordAnimation.addKeyframe(pRecordTime, \
					pComponent.boneGetPosition(index), pComponent.boneGetRotation(index))
			end)
		end
		
		/** Write capture information file. */
		public func void writeCaptureInfoFile(String path, String animPath)
			var GameApp app = GameApp.getGameApp()
			var WorldSpawnCharacter wsc = app.getWorldSpawnCharacter()
			var EasyXML document = EasyXML.new()
			var EasyXMLElement root = document.getRootElement()
			var TimeDate timestamp = pRecordAnimation.getTimestamp()
			
			root.setTagName("mocapAnimation")
			
			// general information
			root.addDataTag("timestamp", timestamp.format("%Y-%m-%dT%H:%M:%S"))
			
			// actor
			var ActorProfile actorProfile = app.getActiveActorProfile()
			if actorProfile != null
				var EasyXMLElement tag = root.addTag("actor")
				tag.addDataTag("profileName", actorProfile.getName())
				tag.addDataTag("shoulderLevel", actorProfile.getShoulderLevel())
				tag.addDataTag("shoulderWide", actorProfile.getShoulderWidth())
				tag.addDataTag("armLength", actorProfile.getArmLength())
				tag.addDataTag("legLength", actorProfile.getLegLength())
			end
			
			// character
			var CharacterConfiguration character = wsc.getCharacter()
			var String originBone = ""
			
			if character != null
				var CharacterProfile profile = character.getProfile()
				originBone = profile.getOriginBone()
				
				var EasyXMLElement tag = root.addTag("character")
				tag.addDataTag("profileName", profile.getName())
				tag.addDataTag("configurationName", character.getName())
				
				tag.addDataTag("originBone", originBone)
				tag.addDataTag("shoulderLevel", profile.getShoulderLevel())
				tag.addDataTag("scaleMode", character.getScaleMode().name())
				tag.addDataTag("calibratedScale", character.getCalibrateScale())
				
				var CharacterAppearance appearance = profile.getAppearance()
				var EasyXMLElement tagAppearance = tag.addTag("appearance")
				tagAppearance.addDataTag("pathModel", appearance.getPathModel())
				tagAppearance.addDataTag("pathSkin", appearance.getPathSkin())
				tagAppearance.addDataTag("pathRig", appearance.getPathRig())
				tagAppearance.addDataTag("pathAnimation", appearance.getPathAnimation())
			end
			
			// animation
			var bool hasOriginBone = not originBone.empty() and not pRecordAnimation.hasBone(originBone)
			var Animation animation = pRecordAnimation.getAnimation()
			var String moveName = animation.getMoveName(0)
			
			var EasyXMLElement tagAnimation = root.addTag("capturedAnimation")
			tagAnimation.addDataTag("pathAnimation", animPath)
			tagAnimation.addDataTag("moveName", moveName)
			tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
			tagAnimation.addDataTag("frameRate", animation.getMoveFPS(moveName))
			
			if hasOriginBone
				tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount() + 1)
				
			else
				tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount())
			end
			
			var EasyXMLElement tagBones = tagAnimation.addTag("bones")
			pRecordAnimation.forEachBone(block String each
				tagBones.addDataTag("boneName", each)
			end)
			
			if hasOriginBone
				tagBones.addDataTag("boneName", originBone)
			end
			
			// write to file
			document.writeToFile(FileWriter.new(path), false)
		end
	end
	
	
	
	private var ECBehaviorActorAnimated pActorAnimated
	private var Set pBones
	private var Set pRootBones
	
	
	
	/** Create behavior element class. */
	public func new(BaseVRActorClass eclass) super(eclass)
		pActorAnimated = eclass.getActorAnimated()
		pBones = Set.new()
		pRootBones = Set.new()
		
		eclass.addBehavior(this)
	end
	
	
	
	/** Actor animated behavior. */
	public func ECBehaviorActorAnimated getActorAnimated()
		return pActorAnimated
	end
	
	
	
	/** Bones to record. Set of String. */
	public func Set getBones()
		return pBones
	end
	
	/** Add bone to record if not present. */
	public func void addBone(String bone)
		pBones.add(bone)
	end
	
	/** Add bones to record if not present. Expects Array of String. */
	public func void addBones(Array bones)
		pBones.addAll(Set.newFrom(bones))
	end
	
	
	
	/** Root bones. Set of String. */
	public func Set getRootBones()
		return pRootBones
	end
	
	/** Add root bone if not present. */
	public func void addRootBone(String bone)
		pRootBones.add(bone)
	end
	
	/** Add root bones if not present. Expects Array of String. */
	public func void addRootBones(Array rootBones)
		pRootBones.addAll(Set.newFrom(rootBones))
	end
	
	
	
	/** Get instance in element from owner element class. */
	public func Instance instance( BehaviorElement element )
		return element.getInstanceAt( this.getInstanceIndex() ) cast Instance
	end
	
	/** Get behavior in element class or null if absent. */
	static public func ECBRecordAnimation getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBRecordAnimation each
			return true
		end) cast ECBRecordAnimation
	end
	
	/** Get instance with slot name in element or null if absent. */
	static public func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	/** Create Behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
