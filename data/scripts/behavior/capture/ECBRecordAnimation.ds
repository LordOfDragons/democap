/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Actors
pin Democap.Characters

pin Dragengine.Gui
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Behavior adding support to record animations.
 */
class ECBRecordAnimation extends DefaultECBehavior
	/** Listener. */
	interface Listener
		/** Prepare recording. Called when recording delays starts. */
		func void prepareRecording(Instance instance)
		
		/** Recording starts. Called when recording delay ends. */
		func void startRecording(Instance instance)
		
		/** Recording stopped. */
		func void stopRecording(Instance instance)
	end
	
	/** Default listener implementation. */
	class DefaultListener implements Listener
		/** Create listener. */
		public func new()
		end
		
		/** Prepare recording. Called when recording delays starts. */
		public func void prepareRecording(Instance instance)
		end
		
		/** Recording starts. Called when recording delay ends. */
		public func void startRecording(Instance instance)
		end
		
		/** Recording stopped. */
		public func void stopRecording(Instance instance)
		end
	end
	
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		class RecordDeviceSlot
			protected var ECBTrackerSlot.Instance pSlot
			protected var int pBone
			protected var Matrix pMatrix1, pMatrix2
			
			public func new(ECBTrackerSlot.Instance slot, int bone, Matrix matrix1, Matrix matrix2)
				pSlot = slot
				pBone = bone
				pMatrix1 = matrix1
				pMatrix2 = matrix2
			end
			
			public func Matrix calcMatrix()
				return pMatrix1 * pSlot.getMatrixCharacter() * pMatrix2
			end
		end
		
		
		private var ECBRecordAnimation pECBehavior
		private var ECBehaviorActorAnimated.Instance pActorAnimated
		private var Array pBoneIndices
		private var Array pRootBoneIndices
		private var Array pStaticBoneIndices
		private var Array pStaticRootBoneIndices
		private var Matrix pTransformRootBones
		private var RecordAnimation pRecordAnimation
		private var RecordAnimation pRecordAnimationDevices
		private var CharacterConfiguration pCharacterConfiguration
		private var CharacterAnimation pCharacterAnimation
		private var SessionSettings.RecordDevices pRecordDevices
		private var Array pRecordDeviceSlots
		private var bool pIsPreparing
		private var bool pIsRecording
		private var float pRecordTime
		private var bool pIncrementTime
		private var Component pComponent
		private var Rig pRig
		private var Array pListeners
		private var ECBCapturedAnimations.Instance pCapturedAnimations
		private var bool pFullRecording
		private var bool pFirstFrame
		
		
		
		/** Create instance. */
		public func new(ECBRecordAnimation ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pBoneIndices = Array.new()
			pRootBoneIndices = Array.new()
			pStaticBoneIndices = Array.new()
			pStaticRootBoneIndices = Array.new()
			pRecordDeviceSlots = Array.new()
			pListeners = Array.new()
			pTransformRootBones = Matrix.new()
			pActorAnimated = ecbehavior.getActorAnimated().instance(element)
			setRequiresThink(true)
		end
		
		/** Dispose of instance. */
		public func void dispose()
			pCapturedAnimations = null
			pListeners = null
			pActorAnimated = null
			super.dispose()
		end
		
		/** Init behavior instance. */
		public func void init(StubElement stub)
		end
		
		
		
		/** Behavior. */
		public func ECBRecordAnimation getECBehavior()
			return pECBehavior
		end
		
		/** Actor animated. */
		public func ECBehaviorActorAnimated.Instance getActorAnimated()
			return pActorAnimated
		end
		
		
		
		/** Record animation or null. */
		public func RecordAnimation getRecordAnimation()
			return pRecordAnimation
		end
		
		/** Record devices animation or null. */
		public func RecordAnimation getRecordAnimationDevices()
			return pRecordAnimationDevices
		end
		
		/** Character animation or null. */
		public func CharacterAnimation getCharacterAnimation()
			return pCharacterAnimation
		end
		
		/** Captured animations or null. */
		public func ECBCapturedAnimations.Instance getCapturedAnimations()
			return pCapturedAnimations
		end
		
		
		
		/** Is preparing to record. */
		public func bool isPreparing()
			return pIsPreparing
		end
		
		/** Is recording animation. */
		public func bool isRecording()
			return pIsRecording
		end
		
		/** Is preparing or recording. */
		public func bool isPreparingOrRecording()
			return pIsPreparing or pIsRecording
		end
		
		/** Is not recording nor preparing. */
		public func bool isNotRecording()
			return not pIsRecording and not pIsPreparing
		end
		
		/** Prepare to record. */
		public func void prepareRecording()
			stopRecording()
			
			var GameApp app = GameApp.getGameApp()
			app.getPlaybackScene().pause()
			
			pCharacterConfiguration = app.getWorldSpawnCharacter().getCharacter()
			
			pFirstFrame = true
			
			pRecordAnimation = RecordAnimation.new()
			pRecordAnimation.setFPS(SessionSettings.get().getModelRecordFrameRate().getValue())
			pRecordAnimation.setMoveName("MoCap")
			
			pRecordDevices = SessionSettings.get().getRecordDevices()
			
			pRecordDeviceSlots.removeAll()
			
			if pRecordDevices != SessionSettings.RecordDevices.none
				pRecordAnimationDevices = RecordAnimation.new("-devices")
				pRecordAnimationDevices.setFPS(pRecordAnimation.getFPS())
				pRecordAnimationDevices.setMoveName("MoCapDevices")
				pRecordAnimationDevices.createRig(pCharacterConfiguration)
			end
			
			var ECBSelectable.Instance selection = app.getSelectionTracker().getElement()
			var BehaviorElement selectionElement
			var bool firstAnimation
			
			if selection != null
				selectionElement = selection.getElement()
				pCapturedAnimations = ECBCapturedAnimations.getInstanceIn(selectionElement)
				
				if pCapturedAnimations != null
					if not pCapturedAnimations.getCharacterProfile().equals(pCharacterConfiguration.getProfile().getName())
						pCapturedAnimations = null
						throw EInvalidParam.new("character profile mismatch")
					end
					
					if pCapturedAnimations.getAnimations().getActive() == null
						pCapturedAnimations = null
						throw EInvalidParam.new("no active animation")
					end
					
					pCharacterAnimation = pCapturedAnimations.getAnimations().getActive()
					
					firstAnimation = pCapturedAnimations.getAnimations().getAt(0) == pCharacterAnimation
				end
			end
			
			pFullRecording = pCapturedAnimations == null or firstAnimation
			
			if pFullRecording
				prepareAllBoneIndices()
				
			else
				prepareBoneIndices()
			end
			
			pTransformRootBones = Matrix.new()
			
			if pCapturedAnimations != null
				if pCharacterAnimation != null
					pCharacterAnimation.clear()
					GameApp.getGameApp().getProject().save()
				end
				
				// ensure actor element lines up with selection element. if this is not
				// the case the captured animation would be played back at the wrong
				// position. we could calculate the transformation matrix from actor
				// element in selection element coordinate system but this hides the
				// problem and causes troubles later on while using the animation
				var BehaviorElement element = getElement()
// 				element.setGeometry(selectionElement.getPosition(), selectionElement.getOrientation())
				
				pTransformRootBones = (element.getElementMatrix()\
					* selectionElement.getInverseElementMatrix()).toMatrix()
				
				// if physics attachments are used init collider bone states from component.
				// this is required since collider bone states are in world space and do not
				// move if the actor moves due to teleportation
				var Collider collider = ECBehaviorCollider.getInstanceIn(element).getCollider()
				if collider.getResponseType() == CollisionResponse.dynamic\
				and collider castable ColliderComponent
					(collider cast ColliderComponent).copyStatesFromComponent()
				end
			end
			
			if pRecordDevices != SessionSettings.RecordDevices.none
				// has to be done after pTransformRootBones has been calculated
				var Matrix matCalibInv = pCharacterConfiguration.getMatrixCalibrateInverse()
				var Rig rig = pRecordAnimationDevices.getRig()
				
				pCharacterConfiguration.getTrackerSlots().forEach(block int index, CharacterTrackerSlot each
					var ECBTrackerSlot.Instance slot = ECBTrackerSlot.getInstanceIn(getElement(), each.getName())
					var Matrix matrix1, matrix2
					
					select pRecordDevices
					case SessionSettings.RecordDevices.device
						matrix1 = Matrix.new()
						
					case SessionSettings.RecordDevices.reference
						matrix1 = each.getCalibrateReferenceMatrix() * each.getCalibrateMatrixInverse()
						
					case SessionSettings.RecordDevices.target
						matrix1 = each.getCalibrateReferenceMatrix() * each.getCalibrateMatrixInverse()\
							* each.getTargetMatrix() * each.getCalibrateReferenceMatrixInverse()
					end
					
					matrix2 = matCalibInv * pTransformRootBones * rig.getBoneInverseMatrix(index)
					
					pRecordDeviceSlots.add(RecordDeviceSlot.new(slot, index, matrix1, matrix2))
					pRecordAnimationDevices.addBone(each.getName())
				end)
			end
			
			pIsPreparing = true
			
			pListeners.forEach(block Listener each
				each.prepareRecording(this)
			end)
		end
		
		/**
		 * Prepare bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareBoneIndices()
			// order is important: add first all root bones then all non-root bones
			pComponent = pActorAnimated.getComponent().getComponent()
			pRig = pComponent.getRig()
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			pECBehavior.getRootBones().forEach(block String bone
				var int index = pRig.indexOfBoneNamed(bone)
				if index != -1
					pRootBoneIndices.add(index)
					pRecordAnimation.addBone(bone)
				end
			end)
			
			pECBehavior.getBones().forEach(block String bone
				var int index = pRig.indexOfBoneNamed(bone)
				if index != -1 and not pRootBoneIndices.has(index)
					pBoneIndices.add(index)
					pRecordAnimation.addBone(bone)
				end
			end)
			
			pRecordAnimation.setOriginBone(pCharacterConfiguration.getProfile().getOriginBone())
		end
		
		/**
		 * Prepare all bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareAllBoneIndices()
			// order is important: add first all root bones then all non-root bones
			prepareBoneIndices()
			
			pRig = pActorAnimated.getComponent().getComponent().getRig()
			var int i, count = pRig.getBoneCount()
			
			for i = 0 to count
				if pRig.boneGetParent(i) == -1 and not pRootBoneIndices.has(i) and not pBoneIndices.has(i)
					pStaticRootBoneIndices.add(i)
					pRecordAnimation.addBone(pRig.boneGetName(i))
				end
			end
			
			for i = 0 to count
				if pRig.boneGetParent(i) != -1 and not pRootBoneIndices.has(i) and not pBoneIndices.has(i)
					pStaticBoneIndices.add(i)
					pRecordAnimation.addBone(pRig.boneGetName(i))
				end
			end
		end
		
		/** Start recording animation. */
		public func void startRecording()
			if not pIsPreparing
				prepareRecording()
			end
			
			pIsPreparing = false
			pIsRecording = true
			pRecordTime = 0
			pIncrementTime = false
			
			pListeners.forEach(block Listener each
				each.startRecording(this)
			end)
			
			GameApp.getGameApp().getPlaybackScene().play(false)
		end
		
		/** Stop recording animation. */
		public func void stopRecording()
			var GameApp app = GameApp.getGameApp()
			
			if pIsRecording
				pIsRecording = false
				pComponent = null
				pRig = null
				
				if pRecordAnimation != null
					pRecordAnimation.createAnimation()
					
					if pRecordAnimationDevices != null
						pRecordAnimationDevices.createAnimation()
					end
					
					if pCharacterAnimation != null
						var Project project = app.getProject()
						var File directory = app.getProject().getDataDirectory()
						var Project.AnimationPath animPath = project.nextAnimationPath()
						
						pRecordAnimation.getAnimation().save((directory + animPath.getPath()).getPath())
						
						if pRecordAnimationDevices != null
							pRecordAnimationDevices.getRig().save((directory + animPath.getPathDevicesRig()).getPath())
							
							pRecordAnimationDevices.getAnimation().save((directory + animPath.getPathDevices()).getPath())
						end
						
						writeCaptureInfoFile((directory + animPath.getPathMeta()).getPath(),\
							animPath.getPath(), animPath.getPathDevices(), animPath.getPathDevicesRig())
						
						pCharacterAnimation.setPath(animPath.getPath())
						pCharacterAnimation.setPathMeta(animPath.getPathMeta())
						pCharacterAnimation.setAnimation(pRecordAnimation.getAnimation())
						
						if pRecordAnimationDevices != null
							pCharacterAnimation.setPathDevices(animPath.getPathDevices())
							pCharacterAnimation.setPathDevicesRig(animPath.getPathDevicesRig())
							pCharacterAnimation.setAnimationDevices(pRecordAnimationDevices.getAnimation())
							pCharacterAnimation.setRigDevices(pRecordAnimationDevices.getRig())
						end
						
						project.save()
						
						pCapturedAnimations.getAnimations().notifyAnimationChanged(pCharacterAnimation)
						
					else
						pRecordAnimation.getAnimation().save(pRecordAnimation.getPath())
						
						if pRecordAnimationDevices != null
							pRecordAnimationDevices.getRig().save(pRecordAnimationDevices.getPathRig())
							
							pRecordAnimationDevices.getAnimation().save(pRecordAnimationDevices.getPath())
							
							writeCaptureInfoFile(pRecordAnimation.getPathMeta(), pRecordAnimation.getPath(),\
								pRecordAnimationDevices.getPath(), pRecordAnimationDevices.getPathRig())
							
						else
							writeCaptureInfoFile(pRecordAnimation.getPathMeta(), pRecordAnimation.getPath(), "", "")
						end
					end
				end
				
				pRecordAnimation = null
				pRecordAnimationDevices = null
				pCharacterAnimation = null
				pCapturedAnimations = null
				pTransformRootBones = Matrix.new()
				pCharacterConfiguration = null
				
			elif pIsPreparing
				pIsPreparing = false
				pRecordAnimation = null
				pRecordAnimationDevices = null
				pCharacterAnimation = null
				pCapturedAnimations = null
				pTransformRootBones = Matrix.new()
				pCharacterConfiguration = null
				
			else
				return
			end
			
			pListeners.forEach(block Listener each
				each.stopRecording(this)
			end)
			
			var PlaybackScene ps = app.getPlaybackScene()
			ps.stop()
			ps.updatePlaytime()
		end
		
		
		
		/** Add listener. */
		public func void addListener(Listener listener)
			pListeners.add(listener)
		end
		
		/** Remove listener. */
		public func void removeListener(Listener listener)
			pListeners.remove(listener)
		end
		
		
		
		/** Post think. Called after rendering and thus when animation frame is ready to record. */
		public func void postThink(float elapsed)
			if not pIsRecording
				return
			end
			
			if pIncrementTime
				pRecordTime += elapsed
			end
			pIncrementTime = true
			
			// bones
			pComponent.updateBones()
			
			var Matrix matrix
			pRootBoneIndices.forEach(block int index
				matrix = pComponent.boneGetMatrix(index) * pTransformRootBones\
					* pComponent.getBoneOriginInverseMatrix(index)
				pRecordAnimation.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
			end)
			
			pBoneIndices.forEach(block int index
				pRecordAnimation.addKeyframe(pRecordTime, \
					pComponent.boneGetPosition(index), pComponent.boneGetRotation(index))
			end)
			
			if pFirstFrame
				pFirstFrame = false
				
				pStaticRootBoneIndices.forEach(block int index
					matrix = pComponent.boneGetMatrix(index) * pTransformRootBones\
						* pComponent.getBoneOriginInverseMatrix(index)
					pRecordAnimation.addStaticKeyframe(matrix.getPosition(), matrix.toQuaternion())
				end)
				
				pStaticBoneIndices.forEach(block int index
					pRecordAnimation.addStaticKeyframe(\
						pComponent.boneGetPosition(index), pComponent.boneGetRotation(index))
				end)
			end
			
			// devices
			pRecordDeviceSlots.forEach(block RecordDeviceSlot each
				matrix = each.calcMatrix()
				pRecordAnimationDevices.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
			end)
		end
		
		/** Write capture information file. */
		public func void writeCaptureInfoFile(String path, String animPath,\
		String animDevicesPath, String animDevicesRigPath)
			var GameApp app = GameApp.getGameApp()
			var WorldSpawnCharacter wsc = app.getWorldSpawnCharacter()
			var EasyXML document = EasyXML.new()
			var EasyXMLElement root = document.getRootElement()
			var TimeDate timestamp = pRecordAnimation.getTimestamp()
			
			root.setTagName("mocapAnimation")
			
			// general information
			root.addDataTag("timestamp", timestamp.format("%Y-%m-%dT%H:%M:%S"))
			
			// actor
			var ActorProfile actorProfile = app.getActiveActorProfile()
			if actorProfile != null
				var EasyXMLElement tag = root.addTag("actor")
				tag.addDataTag("profileName", actorProfile.getName())
				tag.addDataTag("shoulderLevel", actorProfile.getShoulderLevel())
				tag.addDataTag("shoulderWide", actorProfile.getShoulderWidth())
				tag.addDataTag("armLength", actorProfile.getArmLength())
				tag.addDataTag("legLength", actorProfile.getLegLength())
			end
			
			// character
			var CharacterConfiguration character = wsc.getCharacter()
			var String originBone = ""
			
			if character != null
				var CharacterProfile profile = character.getProfile()
				originBone = profile.getOriginBone()
				
				var EasyXMLElement tag = root.addTag("character")
				tag.addDataTag("profileName", profile.getName())
				tag.addDataTag("configurationName", character.getName())
				
				tag.addDataTag("originBone", originBone)
				tag.addDataTag("shoulderLevel", profile.getShoulderLevel())
				tag.addDataTag("scaleMode", character.getScaleMode().name())
				tag.addDataTag("calibratedScale", character.getCalibrateScale())
				
				var CharacterAppearance appearance = profile.getAppearance()
				var EasyXMLElement tagAppearance = tag.addTag("appearance")
				tagAppearance.addDataTag("pathModel", appearance.getPathModel())
				tagAppearance.addDataTag("pathSkin", appearance.getPathSkin())
				tagAppearance.addDataTag("pathRig", appearance.getPathRig())
				tagAppearance.addDataTag("pathAnimation", appearance.getPathAnimation())
			end
			
			// animation
			var bool hasOriginBone = not originBone.empty() and not pRecordAnimation.hasBone(originBone)
			var Animation animation = pRecordAnimation.getAnimation()
			var String moveName = animation.getMoveName(0)
			
			var EasyXMLElement tagAnimation = root.addTag("capturedAnimation")
			tagAnimation.addDataTag("pathAnimation", animPath)
			tagAnimation.addDataTag("moveName", moveName)
			tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
			tagAnimation.addDataTag("frameRate", pRecordAnimation.getFPS())
			
			if hasOriginBone
				tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount() + 1)
				
			else
				tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount())
			end
			
			var EasyXMLElement tagBones = tagAnimation.addTag("bones")
			pRecordAnimation.forEachBone(block String each
				tagBones.addDataTag("boneName", each)
			end)
			
			if hasOriginBone
				tagBones.addDataTag("boneName", originBone)
			end
			
			// devices animation
			if pRecordAnimationDevices != null and not animDevicesPath.empty()
				animation = pRecordAnimationDevices.getAnimation()
				moveName = animation.getMoveName(0)
				
				tagAnimation = root.addTag("capturedAnimationDevices")
				tagAnimation.addDataTag("pathAnimation", animDevicesPath)
				
				if not animDevicesRigPath.empty()
					tagAnimation.addDataTag("pathRig", animDevicesRigPath)
				end
				
				tagAnimation.addDataTag("moveName", moveName)
				tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
				tagAnimation.addDataTag("frameRate", pRecordAnimationDevices.getFPS())
				tagAnimation.addDataTag("boneCount", pRecordAnimationDevices.getBoneCount())
				
				tagBones = tagAnimation.addTag("bones")
				pRecordAnimationDevices.forEachBone(block String each
					tagBones.addDataTag("boneName", each)
				end)
			end
			
			// write to file
			document.writeToFile(FileWriter.new(path), false)
		end
	end
	
	
	
	private var ECBehaviorActorAnimated pActorAnimated
	private var Set pBones
	private var Set pRootBones
	
	
	
	/** Create behavior element class. */
	public func new(BaseVRActorClass eclass) super(eclass)
		pActorAnimated = eclass.getActorAnimated()
		pBones = Set.new()
		pRootBones = Set.new()
		
		eclass.addBehavior(this)
	end
	
	
	
	/** Actor animated behavior. */
	public func ECBehaviorActorAnimated getActorAnimated()
		return pActorAnimated
	end
	
	
	
	/** Bones to record. Set of String. */
	public func Set getBones()
		return pBones
	end
	
	/** Add bone to record if not present. */
	public func void addBone(String bone)
		pBones.add(bone)
	end
	
	/** Add bones to record if not present. Expects Array of String. */
	public func void addBones(Array bones)
		pBones.addAll(Set.newFrom(bones))
	end
	
	
	
	/** Root bones. Set of String. */
	public func Set getRootBones()
		return pRootBones
	end
	
	/** Add root bone if not present. */
	public func void addRootBone(String bone)
		pRootBones.add(bone)
	end
	
	/** Add root bones if not present. Expects Array of String. */
	public func void addRootBones(Array rootBones)
		pRootBones.addAll(Set.newFrom(rootBones))
	end
	
	
	
	/** Get instance in element from owner element class. */
	public func Instance instance( BehaviorElement element )
		return element.getInstanceAt( this.getInstanceIndex() ) cast Instance
	end
	
	/** Get behavior in element class or null if absent. */
	static public func ECBRecordAnimation getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBRecordAnimation each
			return true
		end) cast ECBRecordAnimation
	end
	
	/** Get instance with slot name in element or null if absent. */
	static public func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	/** Create Behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
