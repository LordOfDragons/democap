/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Actors
pin Democap.Characters

pin Dragengine.Gui
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Behavior adding support to record animations.
 */
class ECBRecordAnimation extends DefaultECBehavior
	/** Listener. */
	interface Listener
		/** Prepare recording. Called when recording delays starts. */
		func void prepareRecording(Instance instance)
		
		/** Recording starts. Called when recording delay ends. */
		func void startRecording(Instance instance)
		
		/** Recording stopped. */
		func void stopRecording(Instance instance)
	end
	
	/** Default listener implementation. */
	class DefaultListener implements Listener
		/** Create listener. */
		public func new()
		end
		
		/** Prepare recording. Called when recording delays starts. */
		public func void prepareRecording(Instance instance)
		end
		
		/** Recording starts. Called when recording delay ends. */
		public func void startRecording(Instance instance)
		end
		
		/** Recording stopped. */
		public func void stopRecording(Instance instance)
		end
	end
	
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		class RecordDeviceSlot
			protected var ECBTrackerSlot.Instance pSlot
			protected var int pBone
			protected var Matrix pMatrix1, pMatrix2
			
			public func new(ECBTrackerSlot.Instance slot, int bone, Matrix matrix1, Matrix matrix2)
				pSlot = slot
				pBone = bone
				pMatrix1 = matrix1
				pMatrix2 = matrix2
			end
			
			public func Matrix calcMatrix()
				return pMatrix1 * pSlot.getMatrixCharacter() * pMatrix2
			end
		end
		
		
		private var ECBRecordAnimation pECBehavior
		private var ECBehaviorComponent.Instance pComponent
		private var Array pBoneIndices
		private var Array pRootBoneIndices
		private var Array pStaticBoneIndices
		private var Array pStaticRootBoneIndices
		private var Matrix pTransformRootBones
		private var int pOriginBoneIndex
		private var Array pOriginChildrenIndices
		private var RecordAnimation pRecordAnimation
		private var RecordAnimation pRecordAnimationDevices
		private var RecordAnimation pRecordAnimationObject
		private var CharacterConfiguration pCharacterConfiguration
		private var CharacterAnimation pCharacterAnimation
		private var SessionSettings.RecordDevices pRecordDevices
		private var Array pRecordDeviceSlots
		private var bool pIsPreparing
		private var bool pIsRecording
		private var float pRecordTime
		private var bool pIncrementTime
		private var Array pListeners
		private var ECBCapturedAnimations.Instance pCapturedAnimations
		private var bool pFullRecording
		private var bool pFirstFrame
		
		
		
		/** Create instance. */
		public func new(ECBRecordAnimation ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pBoneIndices = Array.new()
			pRootBoneIndices = Array.new()
			pStaticBoneIndices = Array.new()
			pStaticRootBoneIndices = Array.new()
			pOriginBoneIndex = -1
			pOriginChildrenIndices = Array.new()
			pRecordDeviceSlots = Array.new()
			pListeners = Array.new()
			pTransformRootBones = Matrix.new()
			pComponent = ecbehavior.getComponent().instance(element)
			setRequiresThink(true)
		end
		
		/** Dispose of instance. */
		public func void dispose()
			pCapturedAnimations = null
			pListeners = null
			pComponent = null
			super.dispose()
		end
		
		/** Init behavior instance. */
		public func void init(StubElement stub)
		end
		
		
		
		/** Behavior. */
		public func ECBRecordAnimation getECBehavior()
			return pECBehavior
		end
		
		/** Component. */
		public func ECBehaviorComponent.Instance getComponent()
			return pComponent
		end
		
		
		
		/** Record animation or null. */
		public func RecordAnimation getRecordAnimation()
			return pRecordAnimation
		end
		
		/** Record devices animation or null. */
		public func RecordAnimation getRecordAnimationDevices()
			return pRecordAnimationDevices
		end
		
		/** Record object animation or null. */
		public func RecordAnimation getRecordAnimationObject()
			return pRecordAnimationObject
		end
		
		/** Character animation or null. */
		public func CharacterAnimation getCharacterAnimation()
			return pCharacterAnimation
		end
		
		/** Captured animations or null. */
		public func ECBCapturedAnimations.Instance getCapturedAnimations()
			return pCapturedAnimations
		end
		
		
		
		/** Is preparing to record. */
		public func bool isPreparing()
			return pIsPreparing
		end
		
		/** Is recording animation. */
		public func bool isRecording()
			return pIsRecording
		end
		
		/** Is preparing or recording. */
		public func bool isPreparingOrRecording()
			return pIsPreparing or pIsRecording
		end
		
		/** Is not recording nor preparing. */
		public func bool isNotRecording()
			return not pIsRecording and not pIsPreparing
		end
		
		/** Prepare to record. */
		public func void prepareRecording()
			stopRecording()
			
			var GameApp app = GameApp.getGameApp()
			app.getPlaybackScene().pause()
			
			pCharacterConfiguration = ECBCharacterConfiguration.getInstanceIn(getElement()).getCharacter()
			
			pFirstFrame = true
			
			pRecordAnimation = RecordAnimation.new()
			pRecordAnimation.setFPS(SessionSettings.get().getModelRecordFrameRate().getValue())
			pRecordAnimation.setMoveName("MoCap")
			
			pRecordDevices = SessionSettings.get().getRecordDevices()
			
			pRecordDeviceSlots.removeAll()
			
			if pRecordDevices != SessionSettings.RecordDevices.none
				pRecordAnimationDevices = RecordAnimation.new("-devices")
				pRecordAnimationDevices.setFPS(pRecordAnimation.getFPS())
				pRecordAnimationDevices.setMoveName("MoCapDevices")
				pRecordAnimationDevices.createRig(pCharacterConfiguration)
			end
			
			if false
				pRecordAnimationObject = RecordAnimation.new("-object")
				pRecordAnimationObject.setFPS(pRecordAnimation.getFPS())
				pRecordAnimationObject.setMoveName("MoCapObject")
				pRecordAnimationObject.createObjectRig()
			end
			
			var ECBSelectable.Instance selection = app.getSelectionTracker().getElement()
			var BehaviorElement selectionElement
			var bool firstAnimation
			
			if selection != null
				selectionElement = selection.getElement()
				pCapturedAnimations = ECBCapturedAnimations.getInstanceIn(selectionElement)
				
				if pCapturedAnimations != null
					if not pCapturedAnimations.getCharacterProfile().equals(pCharacterConfiguration.getProfile().getName())
						pCapturedAnimations = null
						throw EInvalidParam.new("character profile mismatch")
					end
					
					if pCapturedAnimations.getAnimations().getActive() == null
						pCapturedAnimations = null
						throw EInvalidParam.new("no active animation")
					end
					
					pCharacterAnimation = pCapturedAnimations.getAnimations().getActive()
					
					firstAnimation = pCapturedAnimations.getAnimations().getAt(0) == pCharacterAnimation
				end
			end
			
			pFullRecording = pCapturedAnimations == null or firstAnimation
			
			if pFullRecording
				prepareAllBoneIndices()
				
			else
				prepareBoneIndices()
			end
			prepareOriginBone()
			
			pTransformRootBones = Matrix.new()
			
			if pCapturedAnimations != null
				if pCharacterAnimation != null
					pCharacterAnimation.clear()
					GameApp.getGameApp().getProject().save()
				end
				
				// ensure actor element lines up with selection element. if this is not
				// the case the captured animation would be played back at the wrong
				// position. we could calculate the transformation matrix from actor
				// element in selection element coordinate system but this hides the
				// problem and causes troubles later on while using the animation
				var BehaviorElement element = getElement()
// 				element.setGeometry(selectionElement.getPosition(), selectionElement.getOrientation())
				
				pTransformRootBones = (element.getElementMatrix()\
					* selectionElement.getInverseElementMatrix()).toMatrix()
				
				// if physics attachments are used init collider bone states from component.
				// this is required since collider bone states are in world space and do not
				// move if the actor moves due to teleportation
				var Collider collider = ECBehaviorCollider.getInstanceIn(element).getCollider()
				if collider.getResponseType() == CollisionResponse.dynamic\
				and collider castable ColliderComponent
					(collider cast ColliderComponent).copyStatesFromComponent()
				end
			end
			
			if pRecordDevices != SessionSettings.RecordDevices.none
				// has to be done after pTransformRootBones has been calculated
				var Matrix matCalibInv = pCharacterConfiguration.getMatrixCalibrateInverse()
				var Rig rig = pRecordAnimationDevices.getRig()
				
				pCharacterConfiguration.getTrackerSlots().forEach(block int index, CharacterTrackerSlot each
					var ECBTrackerSlot.Instance slot = ECBTrackerSlot.getInstanceIn(getElement(), each.getName())
					var Matrix matrix1, matrix2
					
					select pRecordDevices
					case SessionSettings.RecordDevices.device
						matrix1 = Matrix.new()
						
					case SessionSettings.RecordDevices.reference
						matrix1 = each.getCalibrateReferenceMatrix() * each.getCalibrateMatrixInverse()
						
					case SessionSettings.RecordDevices.target
						matrix1 = each.getCalibrateReferenceMatrix() * each.getCalibrateMatrixInverse()\
							* each.getTargetMatrix() * each.getCalibrateReferenceMatrixInverse()
					end
					
					matrix2 = matCalibInv * pTransformRootBones * rig.getBoneInverseMatrix(index)
					
					pRecordDeviceSlots.add(RecordDeviceSlot.new(slot, index, matrix1, matrix2))
					pRecordAnimationDevices.addBone(each.getName())
				end)
			end
			
			if pRecordAnimationObject != null
				pRecordAnimationDevices.addBone("object")
			end
			
			pIsPreparing = true
			
			pListeners.forEach(block Listener each
				each.prepareRecording(this)
			end)
		end
		
		
		
		/**
		 * Prepare bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareBoneIndices()
			// order is important: add first all root bones then all non-root bones
			var Set ignoreBones = pECBehavior.getIgnoreBones()
			
			var Component component = pComponent.getComponent()
			var Rig rig = component.getRig()
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1
						pRootBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			pECBehavior.getBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and not pRootBoneIndices.has(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
		end
		
		/**
		 * Prepare all bone indices. For each bone find also the root bone. Root bones are also
		 * added as bones to be recorded. Also find the origin bone if defined. The origin
		 * bone is always recorded as being 0.
		 */
		protected func void prepareAllBoneIndices()
			// order is important: add first all root bones then all non-root bones
			var Set ignoreBones = pECBehavior.getIgnoreBones()
			var Rig rig = pComponent.getComponent().getRig()
			
			pBoneIndices.removeAll()
			pRootBoneIndices.removeAll()
			pStaticBoneIndices.removeAll()
			pStaticRootBoneIndices.removeAll()
			
			// add root bones. since all bone indices are added it is important to add root
			// bones only as root bones if they are true root bones (of the entire component)
			// not just root bones of all captured bone chains. if this split is not done the
			// root bone transform is applied twice causing problems
			var Array allRootBones = Array.new()
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and rig.boneGetParent(index) == -1
						allRootBones.add(index)
						pRootBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			pECBehavior.getRootBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and rig.boneGetParent(index) != -1
						allRootBones.add(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			// add regular bones as in the not all mode
			pECBehavior.getBones().forEach(block String bone
				if not ignoreBones.has(bone)
					var int index = rig.indexOfBoneNamed(bone)
					if index != -1 and not allRootBones.has(index)
						pBoneIndices.add(index)
						pRecordAnimation.addBone(bone)
					end
				end
			end)
			
			// add static bones
			var int i, count = rig.getBoneCount()
			
			for i = 0 to count
				if rig.boneGetParent(i) == -1 and not allRootBones.has(i) and not pBoneIndices.has(i)
					pStaticRootBoneIndices.add(i)
					pRecordAnimation.addBone(rig.boneGetName(i))
				end
			end
			
			for i = 0 to count
				if rig.boneGetParent(i) != -1 and not allRootBones.has(i) and not pBoneIndices.has(i)
					pStaticBoneIndices.add(i)
					pRecordAnimation.addBone(rig.boneGetName(i))
				end
			end
		end
		
		/** Prepare origin bone. */
		protected func void prepareOriginBone()
			var Rig rig = pComponent.getComponent().getRig()
			
			pOriginBoneIndex = -1
			pOriginChildrenIndices.removeAll()
			
			var String originBone = pCharacterConfiguration.getProfile().getOriginBone()
			pRecordAnimation.setOriginBone(originBone)
			
			pOriginBoneIndex = rig.indexOfBoneNamed(originBone)
			if pOriginBoneIndex == -1
				return
			end
			
			if rig.boneGetParent(pOriginBoneIndex) != -1
				// origin bone is not a root bone. this is not supported
				pOriginBoneIndex = -1
				return
			end
			
			(pBoneIndices + pStaticBoneIndices).forEach(block int index
				if rig.boneGetParent(index) == pOriginBoneIndex
					pOriginChildrenIndices.add(index)
				end
			end)
			
			if pOriginChildrenIndices.getCount() == 0\
			and not pRootBoneIndices.has(pOriginBoneIndex)\
			and not pStaticRootBoneIndices.has(pOriginBoneIndex)
				// adjusting origin bone transform has no effect so skip it
				pOriginBoneIndex = -1
			end
		end
		
		/** Start recording animation. */
		public func void startRecording()
			if not pIsPreparing
				prepareRecording()
			end
			
			pIsPreparing = false
			pIsRecording = true
			pRecordTime = 0
			pIncrementTime = false
			
			pListeners.forEach(block Listener each
				each.startRecording(this)
			end)
			
			GameApp.getGameApp().getPlaybackScene().play(false)
		end
		
		/** Stop recording animation. */
		public func void stopRecording()
			var GameApp app = GameApp.getGameApp()
			
			if pIsRecording
				pIsRecording = false
				
				if pRecordAnimation != null
					pRecordAnimation.createAnimation()
					
					if pRecordAnimationDevices != null
						pRecordAnimationDevices.createAnimation()
					end
					if pRecordAnimationObject != null
						pRecordAnimationObject.createAnimation()
					end
					
					if pCharacterAnimation != null
						var Project project = app.getProject()
						var File directory = app.getProject().getDataDirectory()
						var Project.AnimationPath animPath = project.nextAnimationPath()
						
						pRecordAnimation.getAnimation().save((directory + animPath.getPath()).getPath())
						
						if pRecordAnimationDevices != null
							pRecordAnimationDevices.getRig().save((directory + animPath.getPathDevicesRig()).getPath())
							pRecordAnimationDevices.getAnimation().save((directory + animPath.getPathDevices()).getPath())
						end
						if pRecordAnimationObject != null
							pRecordAnimationObject.getRig().save((directory + animPath.getPathObjectRig()).getPath())
							pRecordAnimationObject.getAnimation().save((directory + animPath.getPathObject()).getPath())
						end
						
						writeCaptureInfoFile((directory + animPath.getPathMeta()).getPath(),\
							animPath.getPath(), animPath.getPathDevices(), animPath.getPathDevicesRig(),\
							animPath.getPathObject(), animPath.getPathObjectRig())
						
						pCharacterAnimation.setPath(animPath.getPath())
						pCharacterAnimation.setPathMeta(animPath.getPathMeta())
						pCharacterAnimation.setAnimation(pRecordAnimation.getAnimation())
						
// 						if pRecordAnimationObject != null
// 							pCharacterAnimation.setObjectAnimation(pRecordAnimationObject.getAnimation())
// 							pCharacterAnimation.setObjectRig(pRecordAnimationObject.getRig())
// 						end
						if pRecordAnimationDevices != null
							pCharacterAnimation.setPathDevices(animPath.getPathDevices())
							pCharacterAnimation.setPathDevicesRig(animPath.getPathDevicesRig())
							pCharacterAnimation.setAnimationDevices(pRecordAnimationDevices.getAnimation())
							pCharacterAnimation.setRigDevices(pRecordAnimationDevices.getRig())
						end
						
						project.save()
						
						pCapturedAnimations.getAnimations().notifyAnimationChanged(pCharacterAnimation)
						
						if app.getSessionSettings().getModelAutoExport().getToggled()
							pCharacterAnimation.export(project, getAutoExportPath())
						end
						
					else
						pRecordAnimation.getAnimation().save(pRecordAnimation.getPath())
						
						var String pathDevices = "", pathDevicesRig = ""
						if pRecordAnimationDevices != null
							pathDevicesRig = pRecordAnimationDevices.getPathRig()
							pathDevices = pRecordAnimationDevices.getPath()
							
							pRecordAnimationDevices.getRig().save(pathDevicesRig)
							pRecordAnimationDevices.getAnimation().save(pathDevices)
						end
						
						var String pathObject = "", pathObjectRig = ""
						if pRecordAnimationObject != null
							pathObjectRig = pRecordAnimationObject.getPathRig()
							pathObject = pRecordAnimationObject.getPath()
							
							pRecordAnimationObject.getRig().save(pathObjectRig)
							pRecordAnimationObject.getAnimation().save(pathObject)
						end
						
						writeCaptureInfoFile(pRecordAnimation.getPathMeta(), pRecordAnimation.getPath(),\
							pathDevices, pathDevicesRig, pathObject, pathObjectRig)
					end
				end
				
				pRecordAnimation = null
				pRecordAnimationDevices = null
				pRecordAnimationObject = null
				pCharacterAnimation = null
				pCapturedAnimations = null
				pTransformRootBones = Matrix.new()
				pCharacterConfiguration = null
				
			elif pIsPreparing
				pIsPreparing = false
				pRecordAnimation = null
				pRecordAnimationDevices = null
				pRecordAnimationObject = null
				pCharacterAnimation = null
				pCapturedAnimations = null
				pTransformRootBones = Matrix.new()
				pCharacterConfiguration = null
				
			else
				return
			end
			
			pListeners.forEach(block Listener each
				each.stopRecording(this)
			end)
			
			var PlaybackScene ps = app.getPlaybackScene()
			ps.stop()
			ps.updatePlaytime()
		end
		
		
		
		/** Add listener. */
		public func void addListener(Listener listener)
			pListeners.add(listener)
		end
		
		/** Remove listener. */
		public func void removeListener(Listener listener)
			pListeners.remove(listener)
		end
		
		
		
		/** Post think. Called after rendering and thus when animation frame is ready to record. */
		public func void postThink(float elapsed)
			var DNServer dnserver = GameApp.getGameApp().getServer()
			
			if not pIsRecording and not dnserver.isListening()
				return
			end
			
			pComponent.getComponent().updateBones()
			
			if pIsRecording
				if pIncrementTime
					pRecordTime += elapsed
				end
				pIncrementTime = true
				captureBones()
			end
			
			if dnserver.isListening()
				dnserver.updateCaptureFrame()
			end
		end
		
		/** Capture bones. */
		protected func void captureBones()
			var Component component = pComponent.getComponent()
			
			// bones
			var Matrix originTransform = Matrix.new()
			if pOriginBoneIndex != -1
				originTransform = pTransformRootBones * component.getBoneOriginInverseMatrix(pOriginBoneIndex)
			end
			
			var Matrix matrix
			pRootBoneIndices.forEach(block int index
				if index == pOriginBoneIndex
					matrix = Matrix.new()
				else
					matrix = component.boneGetMatrix(index) * pTransformRootBones\
						* component.getBoneOriginInverseMatrix(index)
				end
				pRecordAnimation.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
			end)
			
			pBoneIndices.forEach(block int index
				if pOriginChildrenIndices.has(index)
					matrix = component.boneGetMatrix(index) * originTransform\
						* component.getBoneOriginInverseMatrix(index)
					pRecordAnimation.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
				else
					pRecordAnimation.addKeyframe(pRecordTime, \
						component.boneGetPosition(index), component.boneGetRotation(index))
				end
			end)
			
			if pFirstFrame
				pFirstFrame = false
				
				pStaticRootBoneIndices.forEach(block int index
					if index == pOriginBoneIndex
						matrix = Matrix.new()
					else
						matrix = component.boneGetMatrix(index) * pTransformRootBones\
							* component.getBoneOriginInverseMatrix(index)
					end
					pRecordAnimation.addStaticKeyframe(matrix.getPosition(), matrix.toQuaternion())
				end)
				
				pStaticBoneIndices.forEach(block int index
					if pOriginChildrenIndices.has(index)
						matrix = component.boneGetMatrix(index) * originTransform\
							* component.getBoneOriginInverseMatrix(index)
						pRecordAnimation.addStaticKeyframe(matrix.getPosition(), matrix.toQuaternion())
					else
						pRecordAnimation.addStaticKeyframe(\
							component.boneGetPosition(index), component.boneGetRotation(index))
					end
				end)
			end
			
			// devices
			pRecordDeviceSlots.forEach(block RecordDeviceSlot each
				matrix = each.calcMatrix()
				pRecordAnimationDevices.addKeyframe(pRecordTime, matrix.getPosition(), matrix.toQuaternion())
			end)
			
			// object
			if pRecordAnimationObject != null
				var BehaviorElement element = getElement()
				pRecordAnimationObject.addKeyframe(pRecordTime, element.getPosition().toVector(), element.getOrientation())
			end
		end
		
		/** Write capture information file. */
		public func void writeCaptureInfoFile(String path, String animPath, String animDevicesPath,\
		String animDevicesRigPath, String animObjectPath, String animObjectRigPath)
			var GameApp app = GameApp.getGameApp()
			var EasyXML document = EasyXML.new()
			var EasyXMLElement root = document.getRootElement()
			var TimeDate timestamp = pRecordAnimation.getTimestamp()
			
			root.setTagName("mocapAnimation")
			
			// general information
			root.addDataTag("timestamp", timestamp.format("%Y-%m-%dT%H:%M:%S"))
			
			// actor
			var ActorProfile actorProfile = app.getActiveActorProfile()
			if actorProfile != null
				var EasyXMLElement tag = root.addTag("actor")
				tag.addDataTag("profileName", actorProfile.getName())
				tag.addDataTag("shoulderLevel", actorProfile.getShoulderLevel())
				tag.addDataTag("shoulderWide", actorProfile.getShoulderWidth())
				tag.addDataTag("armLength", actorProfile.getArmLength())
				tag.addDataTag("legLength", actorProfile.getLegLength())
			end
			
			// character
			var String originBone = ""
			
			if pCharacterConfiguration != null
				var CharacterProfile profile = pCharacterConfiguration.getProfile()
				originBone = profile.getOriginBone()
				
				var EasyXMLElement tag = root.addTag("character")
				tag.addDataTag("profileName", profile.getName())
				tag.addDataTag("configurationName", pCharacterConfiguration.getName())
				
				tag.addDataTag("originBone", originBone)
				tag.addDataTag("shoulderLevel", profile.getShoulderLevel())
				tag.addDataTag("scaleMode", pCharacterConfiguration.getScaleMode().name())
				tag.addDataTag("calibratedScale", pCharacterConfiguration.getCalibrateScale())
				
				var CharacterAppearance appearance = profile.getAppearance()
				var EasyXMLElement tagAppearance = tag.addTag("appearance")
				tagAppearance.addDataTag("pathModel", appearance.getPathModel())
				tagAppearance.addDataTag("pathSkin", appearance.getPathSkin())
				tagAppearance.addDataTag("pathRig", appearance.getPathRig())
				tagAppearance.addDataTag("pathAnimation", appearance.getPathAnimation())
			end
			
			// animation
			var bool hasOriginBone = not originBone.empty() and not pRecordAnimation.hasBone(originBone)
			var Animation animation = pRecordAnimation.getAnimation()
			var String moveName = animation.getMoveName(0)
			
			var EasyXMLElement tagAnimation = root.addTag("capturedAnimation")
			tagAnimation.addDataTag("pathAnimation", animPath)
			tagAnimation.addDataTag("moveName", moveName)
			tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
			tagAnimation.addDataTag("frameRate", pRecordAnimation.getFPS())
			
			if hasOriginBone
				tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount() + 1)
				
			else
				tagAnimation.addDataTag("boneCount", pRecordAnimation.getBoneCount())
			end
			
			var EasyXMLElement tagBones = tagAnimation.addTag("bones")
			pRecordAnimation.forEachBone(block String each
				tagBones.addDataTag("boneName", each)
			end)
			
			if hasOriginBone
				tagBones.addDataTag("boneName", originBone)
			end
			
			// devices animation
			if pRecordAnimationDevices != null and not animDevicesPath.empty()
				animation = pRecordAnimationDevices.getAnimation()
				moveName = animation.getMoveName(0)
				
				tagAnimation = root.addTag("capturedAnimationDevices")
				tagAnimation.addDataTag("pathAnimation", animDevicesPath)
				
				if not animDevicesRigPath.empty()
					tagAnimation.addDataTag("pathRig", animDevicesRigPath)
				end
				
				tagAnimation.addDataTag("moveName", moveName)
				tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
				tagAnimation.addDataTag("frameRate", pRecordAnimationDevices.getFPS())
				tagAnimation.addDataTag("boneCount", pRecordAnimationDevices.getBoneCount())
				
				tagBones = tagAnimation.addTag("bones")
				pRecordAnimationDevices.forEachBone(block String each
					tagBones.addDataTag("boneName", each)
				end)
			end
			
			// object animation
			if pRecordAnimationObject != null and not animObjectPath.empty()
				animation = pRecordAnimationObject.getAnimation()
				moveName = animation.getMoveName(0)
				
				tagAnimation = root.addTag("capturedAnimationObject")
				tagAnimation.addDataTag("pathAnimation", animObjectPath)
				
				if not animObjectRigPath.empty()
					tagAnimation.addDataTag("pathRig", animObjectRigPath)
				end
				
				tagAnimation.addDataTag("moveName", moveName)
				tagAnimation.addDataTag("playtime", animation.getMovePlaytime(moveName))
				tagAnimation.addDataTag("frameRate", pRecordAnimationObject.getFPS())
				tagAnimation.addDataTag("boneName", "object")
			end
			
			// write to file
			document.writeToFile(FileWriter.new(path), false)
		end
		
		/** Create auto export path. */
		public func String getAutoExportPath()
			var Scene scene = GameApp.getGameApp().getScene()
			var File path = File.new(scene.getName())
			
			var StageDirection stageDirection = scene.getStageDirections().getSelected()
			if stageDirection != null
				path = path + stageDirection.getName()
			end
			
			var BehaviorElement element = pCapturedAnimations.getElement()
			var ECBSceneObject.Instance sceneObject = ECBSceneObject.getInstanceIn(element)
			var String objectName = sceneObject.getName()
			if objectName.empty()
				objectName = "{}-{}".format(Array.newWith(element.getClass().getClassname(), element.getID()))
			end
			path = path + objectName
			
			path = path + pCharacterAnimation.getName()
			return path.getPath()
		end
	end
	
	
	
	private var ECBehaviorComponent pComponent
	private var Set pBones
	private var Set pRootBones
	private var Set pIgnoreBones
	
	
	
	/** Create behavior element class. */
	public func new(BaseVRActorClass eclass) super(eclass)
		pComponent = eclass.getComponent()
		pBones = Set.new()
		pRootBones = Set.new()
		pIgnoreBones = Set.new()
		
		eclass.addBehavior(this)
	end
	
	
	
	/** Component behavior. */
	public func ECBehaviorComponent getComponent()
		return pComponent
	end
	
	
	
	/** Bones to record. Set of String. */
	public func Set getBones()
		return pBones
	end
	
	/** Add bone to record if not present. */
	public func void addBone(String bone)
		pBones.add(bone)
	end
	
	/** Add bones to record if not present. Expects Array of String. */
	public func void addBones(Array bones)
		pBones.addAll(Set.newFrom(bones))
	end
	
	
	
	/** Root bones. Set of String. */
	public func Set getRootBones()
		return pRootBones
	end
	
	/** Add root bone if not present. */
	public func void addRootBone(String bone)
		pRootBones.add(bone)
	end
	
	/** Add root bones if not present. Expects Array of String. */
	public func void addRootBones(Array rootBones)
		pRootBones.addAll(Set.newFrom(rootBones))
	end
	
	
	
	/** Bones to ignore. Set of String. */
	public func Set getIgnoreBones()
		return pIgnoreBones
	end
	
	/** Add bone to ignore if not present. */
	public func void addIgnoreBone(String bone)
		pIgnoreBones.add(bone)
	end
	
	/** Add bones to ignore if not present. Expects Array of String. */
	public func void addIgnoreBones(Array bones)
		pIgnoreBones.addAll(Set.newFrom(bones))
	end
	
	
	
	/** Get instance in element from owner element class. */
	public func Instance instance( BehaviorElement element )
		return element.getInstanceAt( this.getInstanceIndex() ) cast Instance
	end
	
	/** Get behavior in element class or null if absent. */
	static public func ECBRecordAnimation getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBRecordAnimation each
			return true
		end) cast ECBRecordAnimation
	end
	
	/** Get instance with slot name in element or null if absent. */
	static public func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	/** Create Behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
