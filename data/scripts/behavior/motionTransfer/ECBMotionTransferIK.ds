/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Characters
pin Democap.MotionTransferSystem

pin Dragengine.Commands
pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * Behavior for MotionTransferIK.
 */
class ECBMotionTransferIK extends DefaultECBehavior
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		/** Update controllers. */
		class UpdateControllers extends ECBMoCapAnimator.DefaultListener
			private var Instance pInstance
			
			public func new(Instance instance)
				pInstance = instance
			end
			
			public func int requiredPhaseCount(ECBMoCapAnimator.Instance instance)
				return 4
			end
			
			public func void updateControllers(ECBMoCapAnimator.Instance instance, float elapsed, int phase)
				select phase
				case 0
					pInstance.updateControllersPhase1()
					
				case 1
					pInstance.updateControllersPhase2()
					
				case 2
					pInstance.updateControllersPhase3()
					
				case 3
					pInstance.updateControllersPhase4()
				end
			end
		end
		
		
		
		private var ECBMotionTransferIK pECBehavior
		private var ECBehaviorVRPlayspace.Instance pVRPlayspace
		private var ECBMoCapAnimator.Instance pMoCapAnimator
		private var ECBTrackerSlot.Instance pSlotTip
		private var ECBTrackerSlot.Instance pSlotGuide
		private var AnimatorController pControllerTipPosition
		private var AnimatorController pControllerTipOrientation
		private var AnimatorController pControllerGuideRotation
		private var AnimatorController pControllerTwist
		private var AnimatorController pControllerGuideTwistAxis
		private var AnimatorController pControllerRetracted
		private var AnimatorController pControllerBlend
		private var AnimatorController pControllerPreRotate
		private var AnimatorController pControllerBaseRotateX
		private var AnimatorController pControllerBaseRotateY
		private var Matrix pTransformTip
		private var Quaternion pTransformTipQuat
		private var Matrix pTransformGuide
		private var Matrix pMatrixRelocateTip
		private var int pBaseBone
		private var int pGuideBone
		private var int pTipBone
		private var int pPreRotateBone
		private var AnimatorInstance pAnimatorInstance
		private var Component pComponent
		private var int pTwistBone
		private var Vector pScaleReach
		private var Vector pScaleReachBack
		private var Matrix pReachMatrix
		private var Quaternion pTwistQuat, pTwistQuatInv
		private var bool pEnableScaleReach
		private var bool pEnableRelocateTip
		private var bool pEnableTwist
		private var Matrix pMatrixAdjustSlotComponent
		private var Vector2 pBaseRotateRangeCenter
		private var Vector2 pBaseRotateRangeMinimum
		private var Vector2 pBaseRotateRangeMaximum
		
		private var Matrix pTargetMatrix
		
		
		
		/** Create instance. */
		public func new(ECBMotionTransferIK ecbehavior, BehaviorElement element) super(element)
			var MotionTransferIK transfer = ecbehavior.getTransfer()
			pECBehavior = ecbehavior
			
			pVRPlayspace = ecbehavior.getVRPlayspace().instance(element)
			pMoCapAnimator = ecbehavior.getMoCapAnimator().instance(element)
			
			pMatrixRelocateTip = transfer.getCalibrateMatrixRelocateTip()
			pEnableRelocateTip = transfer.getRelocateTip()
			pScaleReach = transfer.getCalibrateReachScaleDirection() * transfer.getCalibrateReachScale()
			pScaleReachBack = transfer.getCalibrateReachScaleDirectionBack() * transfer.getCalibrateReachScale()
			pReachMatrix = Matrix.newRotation(transfer.getCalibrateReachRotation())
			
			pTwistQuat = Quaternion.newFromEuler(transfer.getCalibrateTwistBoneAxisRotation())
			pTwistQuatInv = pTwistQuat.conjugate()
			
			if ecbehavior.getSlotTip() != null
				pSlotTip = ecbehavior.getSlotTip().instance(element)
				pTransformTip = transfer.getTipTracker().getTransformMatrix()
				pTransformTipQuat = pTransformTip.toQuaternion()
			end
			
			if ecbehavior.getSlotGuide() != null
				pSlotGuide = ecbehavior.getSlotGuide().instance(element)
				pTransformGuide = transfer.getGuideTracker().getTransformMatrix()
			end
			
			pBaseRotateRangeCenter = transfer.getBaseRotateRangeCenter()
			pBaseRotateRangeMinimum = transfer.getBaseRotateRangeMinimum()
			pBaseRotateRangeMaximum = transfer.getBaseRotateRangeMaximum()
		end
		
		/** Dispose of instance. */
		public func void dispose()
			pSlotGuide = null
			pSlotTip = null
			pVRPlayspace = null
			pMoCapAnimator = null
			super.dispose()
		end
		
		
		
		/** Init behavior instance. */
		public func void init(StubElement stub)
			var ECBehaviorActorAnimated.Instance actorAnimated = pMoCapAnimator.getActorAnimated()
			var MotionTransferIK transfer = pECBehavior.getTransfer()
			
			pComponent = actorAnimated.getComponent().getComponent()
			
			pControllerTipPosition = actorAnimated.getControllerNamed(pECBehavior.getControllerNameTipPosition())
			pControllerTipOrientation = actorAnimated.getControllerNamed(pECBehavior.getControllerNameTipOrientation())
			pControllerGuideRotation = actorAnimated.getControllerNamed(pECBehavior.getControllerNameGuideRotation())
			pControllerRetracted = actorAnimated.getControllerNamed(pECBehavior.getControllerNameRetracted())
			pControllerTwist = actorAnimated.getControllerNamed(pECBehavior.getControllerNameTwist())
			pControllerGuideTwistAxis = actorAnimated.getControllerNamed(pECBehavior.getControllerNameGuideTwistAxis())
			pControllerBlend = actorAnimated.getControllerNamed(pECBehavior.getControllerNameBlend())
			pControllerPreRotate = actorAnimated.getControllerNamed(pECBehavior.getControllerNamePreRotate())
			pControllerBaseRotateX = actorAnimated.getControllerNamed(pECBehavior.getControllerNameBaseRotateX())
			pControllerBaseRotateY = actorAnimated.getControllerNamed(pECBehavior.getControllerNameBaseRotateY())
			
			pTwistBone = -1
			if not transfer.getTipBone().empty()
				pTwistBone = pComponent.indexOfBoneNamed(transfer.getTipBone())
			end
			
			pEnableTwist = pSlotTip != null and pControllerTwist != null and pTwistBone != -1
			
			pBaseBone = pComponent.indexOfBoneNamed(transfer.getBaseBone())
			pGuideBone = pComponent.indexOfBoneNamed(transfer.getGuideBone())
			pTipBone = pComponent.indexOfBoneNamed(transfer.getTipBone())
			
			if transfer.getCalibratePreRotateBone().empty()
				pPreRotateBone = -1
				
			else
				pPreRotateBone = pComponent.indexOfBoneNamed(transfer.getCalibratePreRotateBone())
			end
			
			pEnableScaleReach = pSlotTip != null and pBaseBone != -1 \
				and pControllerTipPosition != null and pControllerBlend != null
			
			pMoCapAnimator.addListener(UpdateControllers.new(this))
		end
		
		
		/** Behavior. */
		public func ECBMotionTransferIK getECBehavior()
			return pECBehavior
		end
		
		/** VR Playspace. */
		public func ECBehaviorVRPlayspace.Instance getVRPlayspace()
			return pVRPlayspace
		end
		
		/** Motion capture animator behavior. */
		public func ECBMoCapAnimator.Instance getMoCapAnimator()
			return pMoCapAnimator
		end
		
		/** Tip slot behavior instance or null. */
		public func ECBTrackerSlot.Instance getSlotTip()
			return pSlotTip
		end
		
		/** Guide slot behavior instance or null. */
		public func ECBTrackerSlot.Instance getSlotGuide()
			return pSlotGuide
		end
		
		
		
		/** Update controllers. */
		public func void updateControllersPhase1()
			// support tweaking
			var MotionTransferIK transfer = pECBehavior.getTransfer()
			pScaleReach = transfer.getCalibrateReachScaleDirection() * transfer.getCalibrateReachScale()
			pScaleReachBack = transfer.getCalibrateReachScaleDirectionBack() * transfer.getCalibrateReachScale()
			
			// target matrix
			pTargetMatrix = pSlotTip.getTrackerSlot().getConfiguration().\
				characterToComponent(pTransformTip * pSlotTip.getMatrixCharacter())
			
			// reset controllers and disable IK to get base pose for next phase
			if pControllerBlend != null
				pControllerBlend.setValue(0)
			end
			if pControllerTwist != null
				pControllerTwist.setValue(0)
			end
			if pControllerPreRotate != null
				pControllerPreRotate.setValue(0)
				pControllerPreRotate.setVector(Vector.new())
			end
			if pControllerBaseRotateX != null
				pControllerBaseRotateX.setValue(0)
			end
			if pControllerBaseRotateY != null
				pControllerBaseRotateY.setValue(0)
			end
		end
		
		public func void updateControllersPhase2()
			updateControllerBaseRotate()
		end
		
		public func void updateControllersPhase3()
			if pControllerBlend != null
				pControllerBlend.setValue(1)
			end
			
			updateControllerPreRotate()
			updateControllerIK()
			updateControllerGuide()
		end
		
		public func void updateControllersPhase4()
			updateControllersTwist()
		end
		
		protected func void updateControllerBaseRotate()
			if pControllerBaseRotateX == null or pControllerBaseRotateY == null or pBaseBone == -1
				return
			end
			
			var Matrix targetMatrix = pTargetMatrix
			if pEnableRelocateTip
				targetMatrix = targetMatrix * pMatrixRelocateTip * pComponent.boneGetMatrix(pBaseBone)
			end
			
			var Matrix reachMatrix = pReachMatrix * pComponent.boneGetMatrix(pBaseBone)
			var Vector targetPos = reachMatrix.getInverse() * targetMatrix.getPosition()
			if targetPos.getLength() < 0.01
				return
			end
			
			pControllerBaseRotateY.setValue(-DEMath.atan2(targetPos.getX(), targetPos.getZ()))
			pControllerBaseRotateX.setValue(DEMath.atan2(targetPos.getY(),\
				Vector2.new(targetPos.getX(), targetPos.getZ()).getLength()))
		end
		
		protected func void updateControllerPreRotate()
			if pControllerPreRotate == null or pPreRotateBone == -1 or pTipBone == -1 or pBaseBone == -1 or pSlotTip == null
				return
			end
			
			var Matrix targetMatrix = pTargetMatrix
			if pEnableRelocateTip
				targetMatrix = targetMatrix * pMatrixRelocateTip * pComponent.boneGetMatrix(pBaseBone)
			end
			
			var Vector targetPos = targetMatrix.getPosition()
			var Vector basePos = pComponent.boneGetMatrix(pPreRotateBone).getPosition()
			var Vector tipPos = pComponent.boneGetMatrix(pTipBone).getPosition()
			
			var Vector tipVector = tipPos - basePos
			var Vector targetVector = targetPos - basePos
			
			if tipVector.isZero() or targetVector.isZero()
				return
			end
			
			tipVector = tipVector.normalize()
			targetVector = targetVector.normalize()
			
			var Vector rotationAxis = tipVector % targetVector
			if rotationAxis.getLength() < 0.001 // too low explodes the calculation
				return
			end
			
			pControllerPreRotate.setRotation(Matrix.newVU(rotationAxis, tipVector).getEulerAngles())
			pControllerPreRotate.setValue(-DEMath.acos(tipVector * targetVector))
		end
		
		protected func void updateControllerIK()
			if pControllerTipPosition == null or pControllerTipOrientation == null or pSlotTip == null
				return
			end
			
			var Matrix matrix = pTargetMatrix
			if pEnableRelocateTip
				matrix = matrix * pMatrixRelocateTip * pComponent.boneGetMatrix(pBaseBone)
			end
			
			// position, retracted length
			var Vector targetPosition = matrix.getPosition()
			var float retractedLength = 1
			
			if pEnableScaleReach
				var Matrix reachMatrix = pReachMatrix * pComponent.boneGetMatrix(pBaseBone)
				
				var Vector targetInReach = reachMatrix.getInverse() * targetPosition
				
				targetInReach = targetInReach.compMultiply(pScaleReach).combine(\
					targetInReach.compMultiply(pScaleReachBack),\
					targetInReach.getX() > 0,\
					targetInReach.getY() > 0,\
					targetInReach.getZ() > 0)
				
				targetPosition = reachMatrix * targetInReach
				
				retractedLength = targetInReach.getLength()
			end
			
			// orientation
			var Vector targetRotation = matrix.getEulerAngles()
			
			// update controllers
			if pControllerTipPosition != null
				pControllerTipPosition.setVector(targetPosition)
			end
			if pControllerTipOrientation != null
				pControllerTipOrientation.setRotation(targetRotation)
			end
			if pControllerRetracted != null
				pControllerRetracted.setValue(retractedLength)
			end
			
			// adjust slot component if required
			adjustSlotComponentPosition(targetPosition, targetRotation)
		end
		
		protected func void updateControllerGuide()
			if pSlotGuide == null
				return
			end
			
			if pControllerGuideRotation != null
				// NOTE actually this is not fully correct. the rotation is affected by
				//      reach scaling if the direction scaling is not uniform. doing this
				//      would require to calculate the rotation matrix then apply a scale
				//      matrix using the direction scaling. the view and up vector can
				//      be obtained and normalized. this can be used to calculate a new
				//      coordinate system which is then the new rotation. the difference
				//      is neglectable for reach scalings close to 1 but become noticable
				//      for large reach scaling differences
				pControllerGuideRotation.setRotation((pTransformGuide * pSlotGuide.getMatrixCharacter()).getEulerAngles())
			end
		end
		
		protected func void updateControllersTwist()
			if not pEnableTwist
				return
			end
			
			//pControllerTwist.setValue(pComponent.boneGetRotation(pTwistBone).getEulerAngles().getZ())
			
			var Quaternion orientation = pTwistQuat * pComponent.boneGetRotation(pTwistBone) * pTwistQuatInv
//			pControllerTwist.setValue(orientation.getEulerAngles().getZ())
			
			var float factor = 0.5
			var float rotation = (orientation.slerp(Quaternion.new(), factor)).getEulerAngles().getZ() / factor
			
			pControllerTwist.setValue(rotation)
			
//			GameApp.getGameApp().getConsole().addMessage("Phase2 " + pECBehavior.getTransfer().getName() \
//				+ " " + pControllerTwist.getValue() + " " + pComponent.boneGetName(pTwistBone))
			
			if pControllerGuideTwistAxis != null and pTipBone != -1 and pGuideBone != -1
				var Vector axis = pComponent.boneGetMatrix(pTipBone).getPosition()\
					- pComponent.boneGetMatrix(pGuideBone).getPosition()
				if not axis.isZero()
					var Vector view = axis.normalize()
					var Vector up
					if DEMath.fabs(view.getY()) > DEMath.max(DEMath.fabs(view.getX()), DEMath.fabs(view.getZ()))
						up = Vector.new(0, 0, 1)
					else
						up = Vector.new(0, 1, 0)
					end
					pControllerGuideTwistAxis.setRotation(Matrix.newVU(view, up).getEulerAngles())
				end
			end
		end
		
		protected func void adjustSlotComponentPosition(Vector position, Vector rotation)
			if pMatrixAdjustSlotComponent == null or pSlotTip == null
				return
			end
			
			var CharacterConfiguration config = pSlotTip.getTrackerSlot().getConfiguration()
			pSlotTip.setComponentFromMatrixCharacter(pMatrixAdjustSlotComponent\
				* config.componentToCharacter(Matrix.newRT(rotation, position)))
		end
		
		
		
		/** Element added to game world. */
		public func void addToGameWorld()
			// slot input device is valid only once the tracker slot processed addToGameWorld
			if pSlotTip != null\
			and pSlotTip.getInputDevice() != null\
			and pSlotTip.getComponent() != null\
			and (pSlotTip.getInputDevice().getType() == InputDeviceType.vrRightHand\
			or pSlotTip.getInputDevice().getType() == InputDeviceType.vrLeftHand)
				pMatrixAdjustSlotComponent = pECBehavior.getTransfer().getTipTracker().getReverseTransformMatrix()
			end
		end
	end
	
	
	
	private var MotionTransferIK pTransfer
	private var ECBehaviorVRPlayspace pVRPlayspace
	private var ECBMoCapAnimator pMoCapAnimator
	private var ECBTrackerSlot pSlotTip
	private var ECBTrackerSlot pSlotGuide
	private var String pControllerNameTipPosition
	private var String pControllerNameTipOrientation
	private var String pControllerNameGuideRotation
	private var String pControllerNameTwist
	private var String pControllerNameGuideTwistAxis
	private var String pControllerNameRetracted
	private var String pControllerNameBlend
	private var String pControllerNamePreRotate
	private var String pControllerNameBaseRotateX
	private var String pControllerNameBaseRotateY
	
	
	
	/** Create behavior element class. */
	public func new(BaseVRActorClass eclass, MotionTransferIK transfer) \
	super(eclass, transfer.getName())
		if transfer == null
			throw ENullPointer.new("transfer")
		end
		
		var String subId = "motionTransferIK(" + transfer.getName() + ")"
		var String prefix = subId + "."
		
		pTransfer = transfer
		pVRPlayspace = eclass.getVRPlayspace()
		pMoCapAnimator = ECBMoCapAnimator.getBehaviorIn(eclass)
		if transfer.getTipTracker() != null
			pSlotTip = ECBTrackerSlot.getBehaviorIn(eclass, transfer.getTipTracker().getSlot())
		end
		if transfer.getGuideTracker() != null
			pSlotGuide = ECBTrackerSlot.getBehaviorIn(eclass, transfer.getGuideTracker().getSlot())
		end
		
		pControllerNameTipPosition = transfer.getName() + ".targetPosition"
		pControllerNameTipOrientation = transfer.getName() + ".targetOrientation"
		pControllerNameGuideRotation = transfer.getName() + ".guideRotation"
		pControllerNameTwist = transfer.getName() + ".twist"
		pControllerNameGuideTwistAxis = transfer.getName() + ".guideTwistAxis"
		pControllerNameRetracted = transfer.getName() + ".retracted"
		pControllerNameBlend = transfer.getName() + ".blend"
		pControllerNamePreRotate = transfer.getName() + ".preRotate"
		pControllerNameBaseRotateX = transfer.getName() + ".baseRotateX"
		pControllerNameBaseRotateY = transfer.getName() + ".baseRotateY"
		
		eclass.addBehavior(this)
	end
	
	/** Dispose of behavior. */
	public func void dispose()
		pVRPlayspace = null
		pMoCapAnimator = null
		pTransfer = null
		pSlotGuide = null
		pSlotTip = null
		super.dispose()
	end
	
	
	
	/** Motion transfer. */
	public func MotionTransferIK getTransfer()
		return pTransfer
	end
	
	/** VR Playspace behavior. */
	public func ECBehaviorVRPlayspace getVRPlayspace()
		return pVRPlayspace
	end
	
	/** Motion capture animator behavior. */
	public func ECBMoCapAnimator getMoCapAnimator()
		return pMoCapAnimator
	end
	
	/** Tip slot behavior or null. */
	public func ECBTrackerSlot getSlotTip()
		return pSlotTip
	end
	
	/** Guide slot behavior or null. */
	public func ECBTrackerSlot getSlotGuide()
		return pSlotGuide
	end
	
	/** Animator controller name. */
	public func String getControllerNameTipPosition()
		return pControllerNameTipPosition
	end
	
	public func String getControllerNameTipOrientation()
		return pControllerNameTipOrientation
	end
	
	public func String getControllerNameGuideRotation()
		return pControllerNameGuideRotation
	end
	
	public func String getControllerNameTwist()
		return pControllerNameTwist
	end
	
	public func String getControllerNameGuideTwistAxis()
		return pControllerNameGuideTwistAxis
	end
	
	public func String getControllerNameRetracted()
		return pControllerNameRetracted
	end
	
	public func String getControllerNameBlend()
		return pControllerNameBlend
	end
	
	public func String getControllerNamePreRotate()
		return pControllerNamePreRotate
	end
	
	public func String getControllerNameBaseRotateX()
		return pControllerNameBaseRotateX
	end
	
	public func String getControllerNameBaseRotateY()
		return pControllerNameBaseRotateY
	end
	
	
	
	/** Get instance in element from owner element class. */
	public func Instance instance( BehaviorElement element )
		return element.getInstanceAt( this.getInstanceIndex() ) cast Instance
	end
	
	
	
	/** Get behavior with slot name in element class or null if absent. */
	static public func ECBMotionTransferIK getBehaviorIn(BehaviorElementClass eclass, String slotName)
		return eclass.findBehavior(block ECBMotionTransferIK each
			return each.getTransfer().getName().equals(slotName)
		end) cast ECBMotionTransferIK
	end
	
	/** Get list of all behaviors in element. */
	static public func Array getAllBehaviorsIn(BehaviorElementClass eclass)
		return eclass.collectBehaviors(block ECBMotionTransferIK each
			return true
		end)
	end
	
	/** Get instance with slot name in element or null if absent. */
	static public func Instance getInstanceIn(BehaviorElement element, String slotName)
		return element.findInstance(block Instance each
			return each.getECBehavior().getTransfer().getName().equals(slotName)
		end) cast Instance
	end
	
	/** Get list of all instances in element. */
	static public func Array getAllInstancesIn(BehaviorElement element)
		return element.collectInstances(block Instance each
			return true
		end)
	end
	
	
	
	/** Create Behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
