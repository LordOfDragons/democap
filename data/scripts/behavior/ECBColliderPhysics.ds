/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2022, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.Behaviors

pin Democap.Characters

pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * Behavior controlling physics parameter of controllers. Element class sets if colliders
 * should be set to dynamic physics response or kinematic physics response. User can
 * change this behavior for example when constructing own objects.
 * 
 * This behavior takes care of enabling/disabling the physics behavior on an array of
 * ECBehaviorCollider depending on the current playback/recording state. During recording
 * physics behavior is enabled. Otherwise physics is disabled. If the user enabled live
 * physics then physics will be also enabled outside recording unless playing back.
 * 
 * Furthermore this behavior copies component bones to physics bones upon switching
 * states to ensure the result is correct.
 * 
 * The weight of the entire element can be set. This is used as the total mass of all
 * colliders. The mass of each collider is scaled uniformly to match the desired value.
 */
class ECBColliderPhysics extends DefaultECBehavior
	/** Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		class RecordStateChanged extends RecordScene.DefaultListener
			protected var Instance pInstance
			
			public func new(Instance instance)
				pInstance = instance
			end
			
			public func void prepareRecording(RecordScene recordScene)
				pInstance.onRecordStateChanged()
			end
			
			public func void startRecording(RecordScene recordScene)
				pInstance.onRecordStateChanged()
			end
			
			public func void stopRecording(RecordScene recordScene)
				pInstance.onRecordStateChanged()
			end
		end
		
		class PlaybackStateChanged extends PlaybackScene.DefaultListener
			protected var Instance pInstance
			
			public func new(Instance instance)
				pInstance = instance
			end
			
			public func void pausePlayback(PlaybackScene playbackScene)
				pInstance.onPlaybackStateChanged()
			end
			
			public func void startPlayback(PlaybackScene playbackScene)
				pInstance.onPlaybackStateChanged()
			end
			
			public func void stopPlayback(PlaybackScene playbackScene)
				pInstance.onPlaybackStateChanged()
			end
		end
		
		
		private var ECBColliderPhysics pECBehavior
		private var Array pColliders // ECBehaviorCollider.Instance
		private var bool pUsePhysics
		private var bool pLivePhysics
		private var bool pTouchActor
		private var bool pPhysicsEnabled
		private var bool pUseLocalGravity
		private var Vector pGravity
		private var float pWeight
		private var bool pCanGrabActor
		private var RecordStateChanged pRecordStateChanged
		private var PlaybackStateChanged pPlaybackStateChanged
		private var ECBCapturedAnimations.Instance pCapturedAnimations
		
		
		
		/** Create behavior instance. */
		public func new(ECBColliderPhysics ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			
			pColliders = ecbehavior.colliders.map(block ECBehaviorCollider each
				return each.instance(element)
			end)
			
			pRecordStateChanged = RecordStateChanged.new(this)
			GameApp.getGameApp().getRecordScene().addListener(pRecordStateChanged)
			
			pPlaybackStateChanged = PlaybackStateChanged.new(this)
			GameApp.getGameApp().getPlaybackScene().addListener(pPlaybackStateChanged)
		end
		
		/** Dispose of behavior instance. */
		public func void dispose()
			if pRecordStateChanged != null
				GameApp.getGameApp().getRecordScene().removeListener(pRecordStateChanged)
				pRecordStateChanged = null
			end
			if pPlaybackStateChanged != null
				GameApp.getGameApp().getPlaybackScene().removeListener(pPlaybackStateChanged)
				pPlaybackStateChanged = null
			end
			
			pColliders = null
			pCapturedAnimations = null
			super.dispose()
		end
		
		/** Init behavior instance. */
		public func void init(StubElement stub)
			var CodecPropertyString codec = getElement().getClass().getCodecPropertyString()
			
			pUsePhysics = pECBehavior.usePhysics.getValue(stub)
			pLivePhysics = pECBehavior.livePhysics.getValue(stub)
			pTouchActor = pECBehavior.touchActor.getValue(stub)
			pWeight = pECBehavior.weight.getValue(stub)
			pUseLocalGravity = pECBehavior.useLocalGravity.getValue(stub)
			pGravity = pECBehavior.gravity.getVector(stub, codec)
			pCanGrabActor = pECBehavior.canGrabActor.getValue(stub)
			
			if pECBehavior.capturedAnimations != null
				pCapturedAnimations = pECBehavior.capturedAnimations.instance(getElement())
			end
			
			updateMass()
			updatePhysicsState(true)
			updateCollisionFilter()
		end
		
		
		
		/** Behavior. */
		public func ECBColliderPhysics getECBehavior()
			return pECBehavior
		end
		
		/** Captured animations or null. */
		public func ECBCapturedAnimations.Instance getCapturedAnimations()
			return pCapturedAnimations
		end
		
		
		
		/** Use physics. */
		public func bool getUsePhysics()
			return pUsePhysics
		end
		
		/** Set use physics. */
		public func void setUsePhysics(bool usePhysics)
			if usePhysics == pUsePhysics
				return
			end
			
			pUsePhysics = usePhysics
			updatePhysicsState(false)
		end
		
		/** Live physics. */
		public func bool getLivePhysics()
			return pLivePhysics
		end
		
		/** Set live physics. */
		public func void setLivePhysics(bool livePhysics)
			if livePhysics == pLivePhysics
				return
			end
			
			pLivePhysics = livePhysics
			updatePhysicsState(false)
		end
		
		/** Weight. */
		public func float getWeight()
			return pWeight
		end
		
		/** Set weight. */
		public func void setWeight(float weight)
			weight = DEMath.max(weight, 0.001)
			if DEMath.fabs(weight - pWeight) < 0.001
				return
			end
			
			pWeight = weight
			updateMass()
		end
		
		/** Touch actor. */
		public func bool getTouchActor()
			return pTouchActor
		end
		
		/** Set touch actor. */
		public func void setTouchActor(bool touchActor)
			if touchActor == pTouchActor
				return
			end
			
			pTouchActor = touchActor
			updateCollisionFilter()
		end
		
		/** Use gravity. */
		public func bool getUseLocalGravity()
			return pUseLocalGravity
		end
		
		/** Set use gravity. */
		public func void setUseLocalGravity(bool useGravity)
			if useGravity == pUseLocalGravity
				return
			end
			
			pUseLocalGravity = useGravity
			updatePhysicsState(true)
		end
		
		/** Gravity. */
		public func Vector getGravity()
			return pGravity
		end
		
		/** Set gravity. */
		public func void setGravity(Vector gravity)
			if gravity.equals(pGravity)
				return
			end
			
			pGravity = gravity
			updatePhysicsState(true)
		end
		
		/** Can physics grab. */
		public func bool getCanGrabActor()
			return pCanGrabActor
		end
		
		/** Set can physics grab. */
		public func void setCanGrabActor(bool canGrabActor)
			pCanGrabActor = canGrabActor
		end
		
		
		
		/** Recording state changed. */
		public func void onRecordStateChanged()
			updatePhysicsState(false)
		end
		
		/** Playback state changed. */
		public func void onPlaybackStateChanged()
			updatePhysicsState(false)
		end
		
		/** Reset dynamic bone. */
		public func void resetDynamicBones()
			pColliders.forEach(block ECBehaviorCollider.Instance each
				if each.getCollider() castable ColliderRig
					var ColliderRig collider = each.getCollider() cast ColliderRig
					var Rig rig = collider.getRig()
					if rig != null
						var DMatrix matrixCollider = collider.getMatrix()
						var int i, count = rig.getBoneCount()
						for i = 0 to count
							if rig.boneGetDynamic(i)
								var DMatrix matrixBone = \
									Matrix.newTranslation(rig.boneGetCentralMassPoint(i)).toDMatrix()\
									* rig.getBoneMatrix(i).toDMatrix()\
									* matrixCollider
								collider.boneSetPosition(i, matrixBone.getPosition())
								collider.boneSetOrientation(i, matrixBone.toQuaternion())
								collider.boneSetLinearVelocity(i, Vector.new())
								collider.boneSetAngularVelocity(i, Vector.new())
							end
						end
					end
					
					if each.getCollider() castable ColliderComponent
						(each.getCollider() cast ColliderComponent).copyStatesToComponent()
					end
				end
			end)
		end
		
		/** Reset dynamic bone velocities. */
		public func void resetDynamicBoneVelocities()
			pColliders.forEach(block ECBehaviorCollider.Instance each
				if each.getCollider() castable ColliderRig
					var ColliderRig collider = each.getCollider() cast ColliderRig
					var Rig rig = collider.getRig()
					if rig != null
						var int i, count = rig.getBoneCount()
						for i = 0 to count
							if rig.boneGetDynamic(i)
								collider.boneSetLinearVelocity(i, Vector.new())
								collider.boneSetAngularVelocity(i, Vector.new())
							end
						end
					end
				end
			end)
		end
		
		
		
		/** Update mass. */
		protected func void updateMass()
			var Array colliders = pColliders.map(block ECBehaviorCollider.Instance each
				return each.getCollider()
			end).collect(block Collider each
				return each != null
			end)
			
			var float totalMass = colliders.inject(0.0, block float mass, Collider collider
				return mass + collider.getMass()
			end) cast float
			
			if totalMass < 0.001
				return
			end
			
			var float factor = pWeight / totalMass
			colliders.forEach(block Collider each
				each.setMass(each.getMass() * factor)
			end)
		end
		
		/** Update physics state. */
		protected func void updatePhysicsState(bool force)
			// there are 4 possible states to cover:
			// - recording
			// - prepare to record
			// - playing back (includes playback paused)
			// - neither recording nor playing back
			// 
			// live physics is only used if use physics is true.
			// 
			// if ECBCapturedAnimations is present physics will be only enabled
			// if recording is enabled.
			var ECBCapturable.Instance capturable = GameApp.getGameApp().getCapturableTracker().getElement()
			var bool isCaptured = capturable != null and capturable.getElement() == getElement()
			
			var bool canRecord = isCaptured or pCapturedAnimations == null or pCapturedAnimations.getRecord()
			var bool physicsEnabled
			
			if GameApp.getGameApp().getRecordScene().isRecording()
				physicsEnabled = pUsePhysics and canRecord
				
			elif GameApp.getGameApp().getRecordScene().isPreparing()
				physicsEnabled = pUsePhysics and canRecord and pLivePhysics
				
			elif not GameApp.getGameApp().getPlaybackScene().isStopped()
				physicsEnabled = false
				
			else // playing back or pausued
				physicsEnabled = pUsePhysics and pLivePhysics
			end
			
			if physicsEnabled != pPhysicsEnabled or force
				pPhysicsEnabled = physicsEnabled
				
				if physicsEnabled
					enablePhysics()
					
				else
					disablePhysics()
				end
			end
		end
		
		/** Update collision filter. */
		protected func void updateCollisionFilter()
			pColliders.forEach(block ECBehaviorCollider.Instance each
				var Collider collider = each.getCollider()
				if collider == null
					return null
				end
				
				var CollisionFilter cf = collider.getCollisionFilter()
				var LayerMask cffilter = LayerMask.new(cf.getFilter())
				
				if pTouchActor
					cffilter.setBit(BaseGameApp.CollisionFilterBit.actor)
					
				else
					cffilter.clearBit(BaseGameApp.CollisionFilterBit.actor)
				end
				
				collider.setCollisionFilter(CollisionFilter.new(cf.getCategory(), cffilter))
			end)
		end
		
		/** Enable physics. */
		protected func void enablePhysics()
			pColliders.forEach(block ECBehaviorCollider.Instance each
				enablePhysics(each)
			end)
		end
		
		protected func void enablePhysics(ECBehaviorCollider.Instance behavior)
			var Collider collider = behavior.getCollider()
			
			collider.setResponseType(CollisionResponse.dynamic)
			
			if pUseLocalGravity
				collider.setGravity(pGravity)
				collider.setUseLocalGravity(true)
				
			else
				collider.setUseLocalGravity(false)
			end
			
			if collider castable ColliderComponent
				(collider cast ColliderComponent).copyStatesFromComponent()
			end
		end
		
		/** Disable physics. */
		protected func void disablePhysics()
			pColliders.forEach(block ECBehaviorCollider.Instance each
				disablePhysics(each)
			end)
		end
		
		/** Disable physics. */
		protected func void disablePhysics(ECBehaviorCollider.Instance behavior)
			var Collider collider = behavior.getCollider()
			
			collider.setResponseType(CollisionResponse.kinematic)
			collider.setGravity(Vector.new())
			collider.setUseLocalGravity(true)
		end
		
		
		
		/** Read from file. */
		public func void readFromFile(PersistencyEnvironment env, FileReader reader)
			select reader.readByte()
			case 0
				var PersistencyFlags flags = PersistencyFlags.new(3, reader)
				pUsePhysics = flags.getAt(0)
				pLivePhysics = flags.getAt(1)
				pPhysicsEnabled = flags.getAt(2)
				
				pWeight = reader.readFloat()
				
			case 1
				var PersistencyFlags flags = PersistencyFlags.new(6, reader)
				pUsePhysics = flags.getAt(0)
				pLivePhysics = flags.getAt(1)
				pPhysicsEnabled = flags.getAt(2)
				pTouchActor = flags.getAt(3)
				pUseLocalGravity = flags.getAt(4)
				pCanGrabActor = flags.getAt(5)
				
				pWeight = reader.readFloat()
				pGravity = Vector.readFromFile(reader)
				
			else
				throw EInvalidParam.new("unsupported version")
			end
			
			updateMass()
			updatePhysicsState(true)
			updateCollisionFilter()
		end
		
		/** Write to file. */
		public func void writeToFile(PersistencyEnvironment env, FileWriter writer)
			writer.writeByte(1) // version
			
			var PersistencyFlags flags = PersistencyFlags.new(6)
			flags.setAt(0, pUsePhysics)
			flags.setAt(1, pLivePhysics)
			flags.setAt(2, pPhysicsEnabled)
			flags.setAt(3, pTouchActor)
			flags.setAt(4, pUseLocalGravity)
			flags.setAt(5, pCanGrabActor)
			flags.writeToFile(writer)
			
			writer.writeFloat(pWeight)
			pGravity.writeToFile(writer)
		end
	end
	
	
	
	public var ECBCapturedAnimations capturedAnimations
	
	public var Array colliders
	public var ECPBoolean usePhysics
	public var ECPBoolean livePhysics
	public var ECPBoolean touchActor
	public var ECPBoolean useLocalGravity
	public var ECPBoolean canGrabActor
	public var ECPVector gravity
	public var ECPFloat weight
	
	
	
	/** Create behavior and add it to element class. */
	public func new(BehaviorElementClass eclass, ECBehaviorCollider collider) super(eclass)
		var String prefix = "colliderPhysics."
		
		colliders = Array.new()
		if collider != null
			colliders.add(collider)
		end
		
		usePhysics = ECPBoolean.new(prefix + "usePhysics", false)
		eclass.addProperty(usePhysics)
		
		livePhysics = ECPBoolean.new(prefix + "livePhysics", false)
		eclass.addProperty(livePhysics)
		
		touchActor = ECPBoolean.new(prefix + "touchActor", true)
		eclass.addProperty(touchActor)
		
		useLocalGravity = ECPBoolean.new(prefix + "useLocalGravity", false)
		eclass.addProperty(useLocalGravity)
		
		gravity = ECPVector.new(prefix + "gravity")
		eclass.addProperty(gravity)
		
		weight = ECPFloat.new(prefix + "weight", 1)
		eclass.addProperty(weight)
		
		canGrabActor = ECPBoolean.new(prefix + "canGrabActor", true)
		eclass.addProperty(canGrabActor)
		
		eclass.addBehavior(this)
	end
	
	/** Dispose of behavior. */
	public func void dispose()
		colliders = null
		capturedAnimations = null
		super.dispose()
	end
	
	
	
	/** Get instance in element from owner element class. */
	public func Instance instance(BehaviorElement element)
		return element.getInstanceAt(this.getInstanceIndex()) cast Instance
	end
	
	/** Get instance with slot name in element or null if absent. */
	static public func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	
	
	/** Actor can grab element. */
	static public func bool actorCanGrab(BehaviorElement element)
		var Instance instance = ECBColliderPhysics.getInstanceIn(element)
		return instance == null or instance.getCanGrabActor()
	end
	
	
	
	/** Create behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
