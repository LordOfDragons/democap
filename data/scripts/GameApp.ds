/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters
pin Democap.Commands
pin Democap.Elements
pin Democap.Gui
pin Democap.MotionTransferSystem
pin Democap.Worlds

pin Dragengine.Commands
pin Dragengine.Gui.Layouts
pin Dragengine.Gui.Events
pin Dragengine.Scenery
pin Dragengine.Utils



/**
 * Game Application.
 */
class GameApp extends BaseGameApp
	/** Collision filter bits. Extends BaseGameApp.CollisionFilterBit. */
	class CollisionFilterBit extends BaseGameApp.CollisionFilterBit
		/** Interaction. */
		public static fixed var int interaction = custom
	end
	
	/** World layer bits. Extends BaseGameApp.WorldLayerBit. */
	class WorldLayerBit extends BaseGameApp.WorldLayerBit
		/** Elements with this bit set show also in remove views. */
		public static fixed var int remoteView = custom
	end
	
	
	public static var int versionMajor = 1
	public static var int versionMinor = 0 // 0..99
	public static var int versionPatch = 0 // 0..9
	
	private var String pPathCaptureAnimations
	private var String pPathProjects
	private var String pPathObjects
	
	private var ActorProfiles pActorProfiles
	private var ActorProfile pActiveActorProfile
	private var ActorProfile pDefaultActorProfile
	private var CharacterProfiles pCharacterProfiles
	private var LoadableWorlds pLoadableWorlds
	private var SessionSettings pSessionSettings
	
	private var MotionTransferFactories pMotionTransferFactories
	private var LoadActorProfile pLoadActorProfile
	private var LoadCharacterProfile pLoadCharacterProfile
	private var LoadStageDirections pLoadStageDirections
	private var MutableID pNextElementClassID
	private var TrackControllerCaps pTrackControllerCaps
	
	private var WorldSpawnCharacter pWorldSpawnCharacter
	private var Camera pVRCamera
	private var VRCameraDirector pVRCameraDirector
	private var ElementClassList pECListHandles
	private var ECBSelectable.Tracker pSelectionTracker
	private var ECBCapturable.Tracker pCapturableTracker
	private var ElementClassList pECListSceneObjects
	private var Dictionary pInteractionBubbleButtonFactories
	
	private var Project pProject
	private var Scene pScene
	private var PanelMain pPanelMain
	private var PlaybackScene pPlaybackScene
	private var RecordScene pRecordScene
	
	private var Array pPatternsProject
	
	private var Array pListeners
	
	private var bool pGameArgsEnableVR
	private var String pGameArgsLoadProject
	
	private var DNServer pServer
	private var HmdDisabledWorld pHmdDisabledWorld
	
	
	/**
	 * Create Game Application.
	 */
	public func new()
		pathDesktopGuiTheme = "/content/gui/main.guitheme.xml"
		pPathCaptureAnimations = "/capture/animations"
		pPathProjects = "/config/projects"
		pPathObjects = "/content/models/objects"
// 		defaultConsoleBufferSize = 100
		
		pPatternsProject = Array.newWith(FileExtension.new("DEMoCap Project", Array.newWith(".demcp"), ".demcp"))
	end
	
	
	
	/** Path to overlay capture animations directory. */
	public func String getPathCaptureAnimations()
		return pPathCaptureAnimations
	end
	
	/** Path to projects directory. */
	public func String getPathProjects()
		return pPathProjects
	end
	
	/** Path to objects directory. */
	public func String getPathObjects()
		return pPathObjects
	end
	
	/** Get app instance for convenience. */
	static public func GameApp getGameApp()
		return getApp() cast GameApp
	end
	
	
	
	/** Main panel. */
	public func PanelMain getPanelMain()
		return pPanelMain
	end
	
	
	
	/** Actor profiles. */
	public func ActorProfiles getActorProfiles()
		return pActorProfiles
	end
	
	/** Active actor profile or null. */
	public func ActorProfile getActiveActorProfile()
		return pActiveActorProfile
	end
	
	/** Set active actor profile or null. */
	public func void setActiveActorProfile(ActorProfile profile)
		pActiveActorProfile = profile
	end
	
	/** Default actor profile or null. */
	public func ActorProfile getDefaultActorProfile()
		return pDefaultActorProfile
	end
	
	/** Character profiles. */
	public func CharacterProfiles getCharacterProfiles()
		return pCharacterProfiles
	end
	
	/** Loadable worlds. */
	public func LoadableWorlds getLoadableWorlds()
		return pLoadableWorlds
	end
	
	/** VR camera. */
	public func Camera getVRCamera()
		return pVRCamera
	end
	
	/** VR camera director. */
	public func VRCameraDirector getVRCameraDirector()
		return pVRCameraDirector
	end
	
	/** Session settings. */
	public func SessionSettings getSessionSettings()
		return pSessionSettings
	end
	
	
	
	/** Next unique element class ID generator. */
	public func MutableID getNextElementClassID()
		return pNextElementClassID
	end
	
	/** Motion transfer factories. */
	public func MotionTransferFactories getMotionTransferFactories()
		return pMotionTransferFactories
	end
	
	/** Load/save actor profile. */
	public func LoadActorProfile getLoadActorProfile()
		return pLoadActorProfile
	end
	
	/** Load/save character profile. */
	public func LoadCharacterProfile getLoadCharacterProfile()
		return pLoadCharacterProfile
	end
	
	/** Load/save stage directions. */
	public func LoadStageDirections getLoadStageDirections()
		return pLoadStageDirections
	end
	
	/** Track hand controller capabilities. */
	public func TrackControllerCaps getTrackControllerCaps()
		return pTrackControllerCaps
	end
	
	/** World spawn character. */
	public func WorldSpawnCharacter getWorldSpawnCharacter()
		return pWorldSpawnCharacter
	end
	
	/** Handles element class list. */
	public func ElementClassList getECListHandles()
		return pECListHandles
	end
	
	/** Scene object element class list. */
	public func ElementClassList getECListSceneObjects()
		return pECListSceneObjects
	end
	
	/** Selection tracker. */
	public func ECBSelectable.Tracker getSelectionTracker()
		return pSelectionTracker
	end
	
	/** Captured tracker. */
	public func ECBCapturable.Tracker getCapturableTracker()
		return pCapturableTracker
	end
	
	/** Interaction bubble button factories as Dictionary of String key and ECBInteractionBubble.ButtonFactory value. */
	public func Dictionary getInteractionBubbleButtonFactories()
		return pInteractionBubbleButtonFactories
	end
	
	/** Server. */
	public func DNServer getServer()
		return pServer
	end
	
	
	/** Project. */
	public func Project getProject()
		return pProject
	end
	
	/** Set project. */
	public func void setProject(Project project)
		if project == pProject
			return
		end
		
		setScene(null) // saves project
		var Project disposeProject = pProject
		
		pProject = project
		
		pListeners.forEach(block GameListener each
			each.projectChanged(this)
		end)
		
		if disposeProject != null
			disposeProject.dispose()
		end
	end
	
	/** Scene. */
	public func Scene getScene()
		return pScene
	end
	
	/** Set scene. */
	public func void setScene(Scene scene)
		if scene == pScene
			return
		end
		
		pRecordScene.stop(true)
		pPlaybackScene.stop()
		pSelectionTracker.clear()
		pCapturableTracker.clear()
		
		if pScene != null
			pScene.getFileUsage().setLocked(true)
			
			try
				cancelLoadGameWorld()
				
				if getWindowGameWorld().getGameWorld() != null
					pScene.saveWorld(getWindowGameWorld().getGameWorld())
					pWorldSpawnCharacter.setGameWorld(null)
					getWindowGameWorld().setGameWorld(null)
				end
				
			catch Exception e
				getConsole().addError("setGameApp.setScene", e)
				pWorldSpawnCharacter.setGameWorld(null)
				getWindowGameWorld().setGameWorld(null)
				pScene.getFileUsage().setLocked(false)
				throw
			end
			
			pScene.getFileUsage().setLocked(false)
			pProject.save()
		end
		
		pScene = scene
		
		if scene != null
			scene.loadWorld(pProject)
		end
		
		pListeners.forEach(block GameListener each
			each.sceneChanged(this)
		end)
	end
	
	/** Playback scene. */
	public func PlaybackScene getPlaybackScene()
		return pPlaybackScene
	end
	
	/** Record scene. */
	public func RecordScene getRecordScene()
		return pRecordScene
	end
	
	/** File dialog patterns for project files as Array of FileExtension. */
	public func Array getPatternsProject()
		return pPatternsProject
	end
	
	public func HmdDisabledWorld getHmdDisabledWorld()
		return pHmdDisabledWorld
	end
	
	
	/** Add listener. */
	public func void addListener(GameListener listener)
		if listener == null
			throw ENullPointer.new("listener")
		end
		pListeners.add(listener)
	end
	
	/** Remove listener. */
	public func void removeListener(GameListener listener)
		pListeners.remove(listener)
	end
	
	/** Notify listeners saved animations changed. */
	public func void notifySavedAnimationsChanged()
		pListeners.forEach(block GameListener each
			each.savedAnimationsChanged(this)
		end)
	end
	
	
	
	/** Initialize game. */
	public func void initGame()
		pListeners = Array.new()
		pPlaybackScene = PlaybackScene.new()
		pRecordScene = RecordScene.new()
		
		// has to come before super call since createAndAddElementClasses() uses it
		pECListHandles = ElementClassList.new()
		pECListSceneObjects = ElementClassList.new()
		pInteractionBubbleButtonFactories = Dictionary.new()
		
		super.initGame()
		
		// debug
		FileUsageManager.debugUsage = getSettings().getBoolAt("Debug/FileUsageManager/Enable", false)
		CharacterConfiguration.debugAnimatorDefinition = \
			getSettings().getBoolAt("Debug/CharacterConfiguration/LogAnimatorDefinition", false)
		
		// only enable this in debug build
		getLoaders().getPersistency().setDebugEnableCanaryValue(true)
		
		// has to come after super call since class list is filled not earlier
		addInteractionBubbleButtonFactories()
		addECListHandles()
		addECListSceneObjects()
		
		pSessionSettings = SessionSettings.new()
		pTrackControllerCaps = TrackControllerCaps.new()
		getBindingManager().addListener(pTrackControllerCaps)
		pTrackControllerCaps.updateCapabilities(getBindingManager())
		
		pDefaultActorProfile = ActorProfile.new("Default")
		
		pMotionTransferFactories = MotionTransferFactories.new()
		addMotionTransferFactories()
		
		pNextElementClassID = MutableID.new(1)
		pLoadActorProfile = LoadActorProfile.new(getConsole())
		pLoadCharacterProfile = LoadCharacterProfile.new(getConsole())
		pLoadStageDirections = LoadStageDirections.new(getConsole())
		pSelectionTracker = ECBSelectable.Tracker.new()
		pCapturableTracker = ECBCapturable.Tracker.new()
		
		pActorProfiles = ActorProfiles.new("/config/actors")
		pCharacterProfiles = CharacterProfiles.new("/config/characters")
		
		pLoadableWorlds = LoadableWorlds.new("/content/worlds")
		
		pWorldSpawnCharacter = WorldSpawnCharacter.new()
		
		pServer = DNServer.new()
		
		// modify game world window. add main panel to the right side and 
		pPanelMain = PanelMain.new(getDesktop(), false)
		getWindowGameWorld().getPanelBorder().addWidget(pPanelMain, BorderLayout.Area.right)
		
		// do not capture input. this allows the window to be used like regular windows
		InputSystem.setCaptureInputDevices(false)
		
		// parse game arguments
		parseGameArguments()
		
		// show Drag[en]gine logo then launch the application
		//WindowLogo.showDragengineLogo(this.getDesktop(), BlockActionListener.new(\
		if pGameArgsEnableVR
			launchApplication()
			
		else
			WindowLogo.showImageLogo(this.getDesktop(), Image.new("/content/images/splashscreen.jpg"),\
			BlockActionListener.new(block ActionEvent event
				launchApplication()
			end))
		end
	end
	
	/**
	 * Prevent console window from being created. We will create our own.
	 */
	protected func WindowConsole createWindowConsole()
		return null
	end
	
	/**
	 * Launch example application.
	 */
	public func void launchApplication()
		//getWindowGameWorld().addWidget(ShoutConsole.new(getConsole()))
		
		// first run handling
		var int version = versionMajor * 1000 + versionMinor * 10 + versionPatch
		if getSettings().getIntAt("firstRun", 0) < version
			firstRun()
			getSettings().setAt("firstRun", version)
			saveSettings()
		end
		
		// create hmd disabled world. this starts loading the resources asynchronously
		pHmdDisabledWorld = HmdDisabledWorld.new()
		
		// set input processor to forward mouse and keyboard input to the desktop widget
		// while processing all other inputs using bindings. adding, removing and changing
		// device events are forwarded to both input processors.
		setSplitInputProcessor()
		
		// load stuff
		pActorProfiles.loadAll()
		
		if pActorProfiles.getCount() > 0
			setActiveActorProfile(pActorProfiles.getAt(0))
		end
		
		pCharacterProfiles.loadAll()
		pLoadableWorlds.scanWorlds()
		
		// create VR camera
		pVRCamera = Camera.new()
		pVRCamera.setFov(80)
		pVRCamera.setViewDistance(300)
		pVRCamera.setLowestIntensity(20)
		pVRCamera.setHighestIntensity(20)
		pVRCamera.setAdaptionTime(30)
		pVRCamera.setLayerMask(LayerMask.newWith(WorldLayerBit.default, WorldLayerBit.remoteView))
		
		// create VR camera director
		pVRCameraDirector = VRCameraDirector.new()
		pVRCameraDirector.setViewDistance(300)
		pVRCameraDirector.setLowestIntensity(20)
		pVRCameraDirector.setHighestIntensity(20)
		pVRCameraDirector.setAdaptionTime(30)
		pVRCameraDirector.setVRCamera(pVRCamera)
		
		// add support to navigate the view. requires hud panel to be either set invisible
		// or to not allow hovering. doing the later in case a hud is required later on
		getPanelHud().setPreventHover(true)
		
		var WorldRenderer worldRenderer = getWindowGameWorld().getWorldRenderer()
		worldRenderer.addMouseListener(RotateCameraMouseListener.new(\
			pVRCameraDirector, InputEventMouseButton.right, InputEventModifier.none))
		
		worldRenderer.addMouseListener(PanCameraMouseListener.new(\
			pVRCameraDirector, InputEventMouseButton.right, InputEventModifier.shift))
		
		worldRenderer.addMouseListener(MoveCameraMouseListener.new(\
			pVRCameraDirector, InputEventMouseButton.right, InputEventModifier.control))
		
		worldRenderer.addMouseListener(ZoomCameraMouseListener.new(\
			pVRCameraDirector, InputEventMouseButton.right,\
			InputEventModifier.shift | InputEventModifier.control))
		
		worldRenderer.addMouseListener(InteractMouseListener.new())
		
		// load auto save project if present
		if pGameArgsLoadProject != null
			try
				setProject(Project.load(pGameArgsLoadProject))
				
			catch Exception e
				getConsole().addError("open project failed: " + pGameArgsLoadProject, e)
				WindowDialog.message(getWindowGameWorld(), "Open Project",\
					"Failed opening project\n" + pGameArgsLoadProject + "\n" + e, null, null, null)
			end
		end
		
		var String pathAutoSaveProject = File.new(pPathProjects, "autosave.demcp").getPath()
		if pProject == null
			if FileSystem.existsFile(pathAutoSaveProject)
				try
					setProject(Project.load(pathAutoSaveProject))
					
				catch Exception e
					getConsole().addError("Failed loading auto save project", e)
				end
			end
		end
		
		if pProject == null
			var Project project = Project.new(pathAutoSaveProject)
			project.getScenes().add(Scene.new("Scene"))
			project.save()
			setProject(project)
		end
		
		if pProject.getPostLoadActivateScene() != null
			setScene(pProject.getScenes().getNamed(pProject.getPostLoadActivateScene()))
			
		else
			setScene(pProject.getScenes().getAt(0))
		end
		
		// switch on VR if requested using game arguments
		if pGameArgsEnableVR
			pSessionSettings.getModelEnableVR().setToggled(true)
		end
	end
	
	/** First run. */
	protected func void firstRun()
		// copy initial content to overlay directory
		var File basePath = File.new(pCharacterProfiles.getDirectory())
		
		FileSystem.searchFiles("/content/initial/config/characters", false, block String path, FileType type
			if type == FileType.file
				FileWriter.new((basePath + File.new(path).getName()).getPath()).writeData(FileReader.new(path))
			end
			return true
		end)
	end
	
	/** Create element classes and add them to element class list. */
	protected func void createAndAddElementClasses()
		super.createAndAddElementClasses()
		
		var ElementClassList eclist = getElementClassList()
		eclist.add(LoadingCharacterClass.new())
		eclist.add(MoCapActorClass.new())
		eclist.add(VRMenuClass.new())
		eclist.add(VRWristMenuClass.new("VRWristMenuRight", true))
		eclist.add(VRWristMenuClass.new("VRWristMenuLeft", false))
		eclist.add(MirrorLargeClass.new())
		eclist.add(CharacterPreviewClass.new())
		eclist.add(ActorMarkerClass.new())
		eclist.add(StaticPropClass.new())
		eclist.add(DynamicPropClass.new())
		eclist.add(VideoCameraClass.new())
		eclist.add(CapturedCharacterClass.new())
		eclist.add(GrabObjectClass.new())
		eclist.add(InteractHandleMoveClass.new())
		eclist.add(InteractHandleRotateClass.new())
		eclist.add(InteractHandleMoveHMDClass.new())
		eclist.add(InteractHandleHideClass.new())
		eclist.add(InteractHandleRemoveClass.new())
		eclist.add(InteractHandleTeleportClass.new())
		eclist.add(InteractHandleActorMarkerClass.new())
		eclist.add(InteractionBubbleClass.new())
		
		var LoadSave.LoadElementClass loadEClass = getLoaders().getElementClass()
		loadEClass.addXmlElementClasses(eclist, "/content/models", true)
		loadEClass.addXmlElementClasses(eclist, "/content/worlds", true)
		loadEClass.addXmlElementClasses(eclist, pPathProjects, true)
	end
	
	/** Add handle element classes. */
	protected func void addECListHandles()
		getElementClassList().forEachCastable(block BehaviorElementClass each
			if ECBInteractHandle.getBehaviorIn(each) != null
				pECListHandles.add(each)
			end
		end)
	end
	
	/** Add scene object element classes. */
	protected func void addECListSceneObjects()
		getElementClassList().forEachCastable(block BehaviorElementClass each
			var ECBSceneObject sceneObject = ECBSceneObject.getBehaviorIn(each)
			if sceneObject != null and sceneObject.addActorOffset.getVector() != null
				pECListSceneObjects.add(each)
			end
		end)
	end
	
	/** Add interaction bubble button factories. */
	protected func void addInteractionBubbleButtonFactories()
		pInteractionBubbleButtonFactories.setAt("remove", IBRemove.Factory.new())
		pInteractionBubbleButtonFactories.setAt("hide", IBHide.Factory.new())
		pInteractionBubbleButtonFactories.setAt("teleport", IBTeleport.Factory.new())
		pInteractionBubbleButtonFactories.setAt("record", IBRecord.Factory.new())
		pInteractionBubbleButtonFactories.setAt("capture", IBCapture.Factory.new())
		pInteractionBubbleButtonFactories.setAt("ghost", IBGhost.Factory.new())
		pInteractionBubbleButtonFactories.setAt("duplicate", IBDuplicate.Factory.new())
	end
	
	/** Add commands. */
	protected func void createAndAddCommands()
		var CommandManager commands = getCommandManager()
		CommandsBAAMovement.addCommands(commands, getPlayerControlledActor())
// 		CommandsBAAInteract.addCommands(commands, getPlayerControlledActor())
		CommandsAAControllerInput.addCommands(commands, getPlayerControlledActor())
	end
	
	/**
	 * Create helper containing default bindings.
	 */
	public func DefaultBindingHelper defaultBindings()
		var DefaultBindingHelper helper = super.defaultBindings()
		
		if helper.hasVRHand(true)
			helper.vrHandBindStick(true, InputDeviceAxisType.stick, 0, "analogLookLR", "")
		end
		if helper.hasVRHand(false)
			helper.vrHandBindStick(false, InputDeviceAxisType.stick, 0, "analogMoveLR", "analogMoveFB")
		end
		
		CommandsAAControllerInput.addDefaultBindings(helper)
		
		// remove mouse and keyboard bindings since we redirect them
		if helper.getMouse() != null
			helper.removeAllDeviceBindings(helper.getMouse())
		end
		if helper.getKeyboard() != null
			helper.removeAllDeviceBindings(helper.getKeyboard())
		end
		
		return helper
	end
	
	/**
	 * Create motion transfer factories.
	 */
	protected func void addMotionTransferFactories()
		pMotionTransferFactories.add(MotionTransferChild.Factory.new())
		pMotionTransferFactories.add(MotionTransferIK.Factory.new())
		pMotionTransferFactories.add(MotionTransferFingers.Factory.new())
		pMotionTransferFactories.add(MotionTransferEyes.Factory.new())
		pMotionTransferFactories.add(MotionTransferFace.Factory.new())
		pMotionTransferFactories.add(MotionTransferSlot.Factory.new())
		pMotionTransferFactories.add(MotionTransferBend.Factory.new())
		pMotionTransferFactories.add(MotionTransferCopy.Factory.new())
		pMotionTransferFactories.add(MotionTransferRotation.Factory.new())
		pMotionTransferFactories.add(MotionTransferSecondary.Factory.new())
		pMotionTransferFactories.add(MotionTransferAnimation.Factory.new())
		
		pMotionTransferFactories.add(MotionTransferAutoHuman.Factory.new())
		pMotionTransferFactories.add(MotionTransferAutoFPV.Factory.new())
	end
	
	/**
	 * Cleaning up.
	 */
	public func void cleanUp()
		saveSettings()
		
		if pServer != null
			pServer.stopListening()
		end
		
		setProject(null) // has to come first since this saves the project... at least for now
		
		if getWindowGameWorld() != null
			getWindowGameWorld().setGameWorld(null) // avoid problems while cleaning up
		end
		if pPanelMain != null
			pPanelMain.safeDispose()
			pPanelMain = null
		end
		if pWorldSpawnCharacter != null
			pWorldSpawnCharacter.dispose()
			pWorldSpawnCharacter = null
		end
		
		pLoadableWorlds = null
		
		if pCharacterProfiles != null
			pCharacterProfiles.dispose()
			pCharacterProfiles = null
		end
		
		pActiveActorProfile = null
		
		if pDefaultActorProfile != null
			pDefaultActorProfile.dispose()
			pDefaultActorProfile = null
		end
		
		if pActorProfiles != null
			pActorProfiles.dispose()
			pActorProfiles = null
		end
		
		pServer = null
		pSelectionTracker = null
		pCapturableTracker = null
		pLoadStageDirections = null
		pLoadCharacterProfile = null
		pLoadActorProfile = null
		pSessionSettings = null
		pVRCameraDirector = null
		pECListHandles = null
		pECListSceneObjects = null
		pListeners = null
		pPlaybackScene = null
		pRecordScene = null
		
		if pHmdDisabledWorld != null
			pHmdDisabledWorld.dispose()
			pHmdDisabledWorld = null
		end
		
		super.cleanUp()
	end
	
	/** Finished loading game world. */
	public func void finishLoadGameWorld()
		super.finishLoadGameWorld()
		
		if pVRCamera.getParentWorld() != null
			pVRCamera.getParentWorld().removeCamera(pVRCamera)
		end
		
		pWorldSpawnCharacter.setGameWorld(getWindowGameWorld().getGameWorld())
		
		if pSessionSettings.getModelEnableHMD().getToggled()
			getWindowGameWorld().getGameWorld().getWorld().addCamera(pVRCamera)
			
		else
			pHmdDisabledWorld.getWorld().addCamera(pVRCamera)
		end
		
		pListeners.forEach(block GameListener each
			each.gameWorldChanged(this)
		end)
		
		pPlaybackScene.updatePlaytime()
		pSessionSettings.updateModelHudCamera()
	end
	
	/** Set split input processor. */
	public func void setSplitInputProcessor()
		setInputProcessor(SplitInputProcessor.new(getBindingManager(), getDesktop()))
	end
	
	/** Render window size changed. */
	public func void onResizeRenderWindow()
		super.onResizeRenderWindow()
		
		// resize console?
	end
	
	/** Parse game arguments. */
	protected func void parseGameArguments()
		var int i, count = getArgumentCount()
		var String arg
		
		for i = 0 to count
			arg = getArgumentAt(i)
			
			if arg.equals("--enable-vr")
				pGameArgsEnableVR = true
				
			elif pGameArgsLoadProject == null
				pGameArgsLoadProject = arg
				
			else
				getConsole().addMessage("Unknown game argument '" + arg + "'")
			end
		end
	end
end
