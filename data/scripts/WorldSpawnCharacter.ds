/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap

pin Democap.Characters
pin Democap.Behaviors
pin Democap.Elements

pin Dragengine.CameraDirectors
pin Dragengine.Gui
pin Dragengine.Scenery
pin Dragengine.Preloading
pin Dragengine.Utils



/**
 * Task ensuring active character is present in game world. Also stores the VR Menu and
 * other gadgets potentially used by the player.
 */
class WorldSpawnCharacter
	/** Listener. */
	public interface Listener
		/** Character configuration changed. */
		func void characterChanged(WorldSpawnCharacter wsc)
		
		/** Charatcer actor is ready to be used. */
		func void actorReady(WorldSpawnCharacter wsc)
		
		/** Charatcer actor is not ready to be used anymore. */
		func void actorNotReady(WorldSpawnCharacter wsc)
		
		/** Game world changed. */
		func void gameWorldChanged(WorldSpawnCharacter wsc)
	end
	
	/** Default implementation of listener. */
	public class DefaultListener implements Listener
		public func new()
		end
		
		/** Character configuration changed. */
		public func void characterChanged(WorldSpawnCharacter wsc)
		end
		
		/** Charatcer actor is ready to be used. */
		public func void actorReady(WorldSpawnCharacter wsc)
		end
		
		/** Charatcer actor is not ready to be used anymore. */
		public func void actorNotReady(WorldSpawnCharacter wsc)
		end
		
		/** Game world changed. */
		public func void gameWorldChanged(WorldSpawnCharacter wsc)
		end
	end
	
	/** Character listener. */
	protected class UpdateCharacter extends DefaultCharacterListener
		private var WorldSpawnCharacter pOwner
		
		public func new(WorldSpawnCharacter owner)
			pOwner = owner
		end
		
		public func void calibrated(CharacterProfile profile, CharacterConfiguration config)
			pOwner.recreateActor()
		end
		
		public func void reset(CharacterProfile profile, CharacterConfiguration config)
			pOwner.recreateActor()
		end
	end
	
	enum State
		prepareElementClass
		createActor
		actorReady
		actorBroken
		recreateActor
	end
	
	
	
	private var GameWorld pGameWorld
	private var SpawnPoint pSpawnPoint
	private var CharacterConfiguration pCharacter
	private var MoCapActor pActor
	private var UpdateCharacter pUpdateCharacter
	private var DVector pLastActorPosition
	private var Quaternion pLastActorOrientation
	private var bool pLastActorSelected
	private var BehaviorElement pVRMenu
	private var BehaviorElement pWristMenuRight
	private var BehaviorElement pWristMenuLeft
	private var BehaviorElement pMirrorLarge
	private var ElementClass pMoCapActorClass
	private var State pState
	private var Array pListeners
	
	
	
	/** Create. */
	public func new()
		pState = State.prepareElementClass
		pUpdateCharacter = UpdateCharacter.new(this)
		pMoCapActorClass = GameApp.getGameApp().getElementClassList().getNamed("MoCapActor")
		pListeners = Array.new()
	end
	
	/** Dispose. */
	public func void dispose()
		if pWristMenuLeft != null
			pWristMenuLeft.safeDispose()
			pWristMenuLeft = null
		end
		if pWristMenuRight != null
			pWristMenuRight.safeDispose()
			pWristMenuRight = null
		end
		if pVRMenu != null
			pVRMenu.safeDispose()
			pVRMenu = null
		end
		if pMirrorLarge != null
			pMirrorLarge.safeDispose()
			pMirrorLarge = null
		end
		
		pListeners.removeAll()
		
		disposeActor()
		pUpdateCharacter = null
	end
	
	
	
	/** Game world or null. */
	public func GameWorld getGameWorld()
		return pGameWorld
	end
	
	/** Set game world or null. */
	public func void setGameWorld(GameWorld gameWorld)
		if gameWorld == pGameWorld
			return
		end
		
		// remove VR menus from game world. they will be reused
		if pVRMenu != null
			pVRMenu.removeFromGameWorldIfPresent()
		end
		if pWristMenuRight != null
			pWristMenuRight.removeFromGameWorldIfPresent()
		end
		if pWristMenuLeft != null
			pWristMenuLeft.removeFromGameWorldIfPresent()
		end
		
		// remove large mirror from game world. it will be reused
		if pMirrorLarge != null
			pMirrorLarge.removeFromGameWorldIfPresent()
		end
		
		// dispose of the actor. we could move the actor to the new game world but better
		// start with a fresh copy
		disposeActor()
		pState = State.actorBroken
		
		pSpawnPoint = null
		pLastActorPosition = null
		pLastActorOrientation = null
		pLastActorSelected = false
		
		// set game world
		pGameWorld = gameWorld
		
		if gameWorld != null
			// find spawn point
			pSpawnPoint = gameWorld.getSpawnPoints().getNamed("player")
			
			// add VR menus creating them if required
			if pVRMenu == null
				pVRMenu = createVRMenu()
			end
			pVRMenu.setVisible(false)
			pVRMenu.setTouchable(false)
			gameWorld.addElement(pVRMenu)
			
			if pWristMenuRight == null
				pWristMenuRight = createWristMenu(true)
			end
			gameWorld.addElement(pWristMenuRight)
			
			if pWristMenuLeft == null
				pWristMenuLeft = createWristMenu(false)
			end
			gameWorld.addElement(pWristMenuLeft)
			
			// add large mirror creating it if required
			if pMirrorLarge == null
				pMirrorLarge = createMirrorLarge()
			end
			pMirrorLarge.setVisible(false)
			pMirrorLarge.setTouchable(false)
			gameWorld.addElement(pMirrorLarge)
			
			// move the camera to a good starting position showing the character
			var VRCameraDirector director = GameApp.getGameApp().getVRCameraDirector()
			
			if director != null
				var DMatrix matrix = DMatrix.new()
				if pSpawnPoint != null
					matrix = pSpawnPoint.getMatrix()
				end
				
				var Vector angles = (Matrix.newRotation(-20, 180, 0) * matrix.getRotation().toMatrix()).getEulerAngles()
				director.setPivot(matrix * DVector.new(0, 1.4, 1))
				director.setAzimuth(angles.getY())
				director.setElevation(-angles.getX())
			end
			
			pState = State.prepareElementClass
		end
		
		pListeners.forEach(block Listener each
			each.gameWorldChanged(this)
		end)
	end
	
	/** Spawn point or null. */
	public func SpawnPoint getSpawnPoint()
		return pSpawnPoint
	end
	
	/** Character or null. */
	public func CharacterConfiguration getCharacter()
		return pCharacter
	end
	
	/** Set character or null. */
	public func void setCharacter(CharacterConfiguration character)
		if character == pCharacter
			return
		end
		
		if pCharacter != null
			pCharacter.getProfile().removeListener(pUpdateCharacter)
		end
		recreateActor()
		
		pCharacter = character
		
		if character != null
			character.getProfile().addListener(pUpdateCharacter)
		end
		
		pListeners.forEach(block Listener each
			each.characterChanged(this)
		end)
	end
	
	/** Recreate actor. */
	public func void recreateActor()
		// disposing of the character is delayed since this call can potentially happen while
		// the mocap actor processes user input during thinking or post thinking. disposing
		// elements during that time can have hard to debug exceptions
		pState = State.recreateActor
	end
	
	/** Actor or null. */
	public func MoCapActor getActor()
		return pActor
	end
	
	
	
	/** VR Menu or null if not created yet. */
	public func BehaviorElement getVRMenu()
		return pVRMenu
	end
	
	/** Right hand wrist menu Menu or null if not created yet. */
	public func BehaviorElement getWristMenuRight()
		return pWristMenuRight
	end
	
	/** Left hand wrist menu or null if not created yet. */
	public func BehaviorElement getWristMenuLeft()
		return pWristMenuLeft
	end
	
	/** Large mirror or null if not created yet. */
	public func BehaviorElement getMirrorLarge()
		return pMirrorLarge
	end
	
	
	
	/** Add listener. */
	public func void addListener(Listener listener)
		if listener == null
			throw ENullPointer.new("listener")
		end
		pListeners.add(listener)
	end
	
	/** Remove listener. */
	public func void removeListener(Listener listener)
		pListeners.remove(listener)
	end
	
	
	
	/** Frame update. */
	public func void update()
		if pState == State.actorReady
			if pGameWorld == null or pCharacter == null
				disposeActor()
				pState = State.actorBroken
			end
		end
		
		if pState == State.recreateActor
			disposeActor()
			
			if pGameWorld == null or pCharacter == null
				pState = State.actorBroken
				
			else
				pState = State.prepareElementClass
			end
		end
		
		if pState == State.prepareElementClass
			if pGameWorld == null or pCharacter == null
				pState = State.actorBroken
				return
			end
			
			// TODO show an "actor loading" mesh or billboard. mesh is better though
			
			try
				pCharacter.getElementClass() // starts preloading if required 
				if not pCharacter.isElementClassPreloading()
					pState = State.createActor
				end
				
			catch Exception e
				GameApp.getGameApp().getConsole().addError("prepare actor element class failed", e)
				pState = State.actorBroken
			end
		end
		
		if pState == State.createActor
			if pGameWorld == null or pCharacter == null
				pState = State.actorBroken
				return
			end
			
			try
				createActor()
				pState = State.actorReady
				
			catch Exception e
				GameApp.getGameApp().getConsole().addError("creating actor failed", e)
				pState = State.actorBroken
				disposeActor()
			end
		end
	end
	
	/** Dispose actor if present. */
	protected func void disposeActor()
		if pActor == null
			return
		end
		
		GameApp.getGameApp().getConsole().addMessage("WorldSpawnCharacter: dispose actor")
		pLastActorPosition = pActor.getPosition()
		pLastActorOrientation = pActor.getOrientation()
		pLastActorSelected = pActor.selectable.isSelected()
		
		try
			pActor.safeDispose()
			
		catch Exception e
			GameApp.getGameApp().getConsole().addError("dispose actor failed", e)
		end
		pActor = null
		
		pListeners.forEach(block Listener each
			each.actorNotReady(this)
		end)
	end
	
	/** Create actor. */
	protected func void createActor()
		GameApp.getGameApp().getConsole().addMessage("WorldSpawnCharacter: create actor")
		// ensure spawn point is present
		if pSpawnPoint == null
			throw EInvalidParam.new("Spawn point 'player' not found in game world")
		end
		
		// spawn player actor
		var StubElement stub
		
		if pCharacter != null
			stub = pCharacter.createStubElement()
			
		else
			stub = StubElement.new(pMoCapActorClass) // no generated ID on purpose
		end
		
		pActor = stub.createElement() cast MoCapActor
		pSpawnPoint.spawn(pGameWorld, pActor)
		
		if pLastActorPosition != null
			pActor.setGeometry(pLastActorPosition, pLastActorOrientation)
			
			// if physics attachments are used init collider bone states from component.
			// this is required since collider bone states are in world space and do not
			// move if the actor moves due to teleportation
			var Collider collider = pActor.getCollider().getCollider()
			if collider.getResponseType() == CollisionResponse.dynamic\
			and collider castable ColliderComponent
				(collider cast ColliderComponent).copyStatesFromComponent()
			end
			
			pLastActorPosition = null
			pLastActorOrientation = null
		end
		
		// select actor if required
		if pLastActorSelected
			pLastActorSelected = false
			
			pActor.selectable.selectElement()
		end
		
		// take control of actor
		pActor.getPlayerControllable().takeControl()
		
		pListeners.forEach(block Listener each
			each.actorReady(this)
		end)
	end
	
	/** Create VR menu. */
	protected func BehaviorElement createVRMenu()
		var ElementClass eclass = GameApp.getGameApp().getElementClassList().getNamed("VRMenu")
		var StubElement stub = StubElement.new(eclass) // no generated ID on purpose
		
		// add properties if required
		
		return stub.createElement() cast BehaviorElement
	end
	
	/** Create wrist menu. */
	protected func BehaviorElement createWristMenu(bool rightHand)
		var ElementClass eclass = GameApp.getGameApp().getElementClassList().getNamed(\
			rightHand if "VRWristMenuRight" else "VRWristMenuLeft")
		var StubElement stub = StubElement.new(eclass) // no generated ID on purpose
		
		// add properties if required
		
		return stub.createElement() cast BehaviorElement
	end
	
	/** Create large mirror. */
	protected func BehaviorElement createMirrorLarge()
		var ElementClass eclass = GameApp.getGameApp().getElementClassList().getNamed("MirrorLarge")
		var StubElement stub = StubElement.new(eclass) // no generated ID on purpose
		
		// add properties if required
		
		return stub.createElement() cast BehaviorElement
	end
end
