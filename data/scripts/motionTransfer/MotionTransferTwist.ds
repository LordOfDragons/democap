/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2022, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer twist bone chain.
 * 
 * Defines root bone and target bone name. This defines the bone chain to manipulate.
 * The target bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 1 or more bones.
 * 
 * Defines two tracker slots to be used to get rotation from. The target tracker
 * position is transformed into the base tracker. The base bone indicates the bone
 * coordinate system to link to the base tracker. This defines the base coordinate
 * system in which the position of the target tracker is converted to a rotation
 * along twist axis. This rotation is split across all bones in the chain. The amount
 * of transfered rotation can be scaled.
 */
class MotionTransferTwist extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "twist"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferTwist.new(factoryID())
		end
		
		public func String displayName()
			return "Twist Bone Chain"
		end
	end
	
	
	
	private var String pTargetBone
	private var String pTargetBaseBone
	private var String pTipBone
	private var String pBaseBone
	private var MotionTransferTracker pTargetTracker
	private var MotionTransferTracker pBaseTracker
	private var float pTwistScale
	private var float pTwistShape
	private var Vector pTwistAxisRotation
	
	private var Array pCalibrateBones
	private var Matrix pCalibrateTwistAxisMatrix
	private var Array pCalibrateTwistWeights
	private var CurveBezier pCalibrateTwistCurve
	private var Array pCalibrateTwistAxes
	private var Vector pCalibrateTwistBoneAxisRotation
	private var Matrix pCalibrateTwistTransform
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTargetBone = ""
		pTargetBaseBone = ""
		pTipBone = ""
		pBaseBone = ""
		pTargetTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pTwistScale = 1
		pTwistShape = 0.5
		pTwistAxisRotation = Vector.new()
		pCalibrateBones = Array.new()
		pCalibrateTwistAxisMatrix = Matrix.new()
		pCalibrateTwistWeights = Array.new()
		pCalibrateTwistCurve = CurveBezier.newDefaultLinear()
		pCalibrateTwistAxes = Array.new()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateTwistTransform = Matrix.new()
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferTwist transfer) super(transfer)
		pTargetBone = transfer.pTargetBone
		pTargetBaseBone = transfer.pTargetBaseBone
		pTipBone = transfer.pTipBone
		pBaseBone = transfer.pBaseBone
		pTargetTracker = MotionTransferTracker.new(transfer.pTargetTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pTwistScale = transfer.pTwistScale
		pTwistShape = transfer.pTwistShape
		pTwistAxisRotation = transfer.pTwistAxisRotation
		pCalibrateBones = Array.new(transfer.pCalibrateBones)
		pCalibrateTwistAxisMatrix = transfer.pCalibrateTwistAxisMatrix
		pCalibrateTwistWeights = Array.new(transfer.pCalibrateTwistWeights)
		pCalibrateTwistCurve = CurveBezier.new(transfer.pCalibrateTwistCurve)
		pCalibrateTwistAxes = Array.new(transfer.pCalibrateTwistAxes)
		pCalibrateTwistBoneAxisRotation = transfer.pCalibrateTwistBoneAxisRotation
		pCalibrateTwistTransform = transfer.pCalibrateTwistTransform
	end
	
	
	
	/** Target bone name. */
	public func String getTargetBone()
		return pTargetBone
	end
	
	/** Set target bone name. */
	public func void setTargetBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBone = bone
	end
	
	/** Target base bone name. */
	public func String getTargetBaseBone()
		return pTargetBaseBone
	end
	
	/** Set target base bone name. */
	public func void setTargetBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBaseBone = bone
	end
	
	/** Tip bone name. */
	public func String getTipBone()
		return pTipBone
	end
	
	/** Set tip bone name. */
	public func void setTipBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTipBone = bone
	end
	
	/** Base bone name. */
	public func String getBaseBone()
		return pBaseBone
	end
	
	/** Set base bone name. */
	public func void setBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pBaseBone = bone
	end
	
	/** Target tracker. */
	public func MotionTransferTracker getTargetTracker()
		return pTargetTracker
	end
	
	/** Base tracker. */
	public func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Twist scale. */
	public func float getTwistScale()
		return pTwistScale
	end
	
	/** Set twist scale. */
	public func void setTwistScale(float scale)
		pTwistScale = scale
	end
	
	/**
	 * Twist shape in the range from 0 to 1. 0 twists only at the base bone. 1 twists only
	 * at the tip bone. 0.5 twists all bones equally. Values in between gradually blend between.
	 */
	public func float getTwistShape()
		return pTwistShape
	end
	
	/**
	 * Set twist shape in the range from 0 to 1. 0 twists only at the base bone. 1 twists only
	 * at the tip bone. 0.5 twists all bones equally. Values in between gradually blend between.
	 */
	public func void setTwistShape(float shape)
		pTwistShape = DEMath.clamp(shape, 0.0, 1.0)
	end
	
	/** Rotation of twist axis in component space. */
	public func Vector getTwistAxisRotation()
		return pTwistAxisRotation
	end
	
	/** Set rotation of twist axis in component space. */
	public func void setTwistAxisRotation(Vector rotation)
		if rotation == null
			throw ENullPointer.new("rotation")
		end
		pTwistAxisRotation = rotation
	end
	
	
	
	/** Calibrate twist axis matrix (inverse twist axis matrix in base matrix). */
	public func Matrix getCalibrateTwistAxisMatrix()
		return pCalibrateTwistAxisMatrix
	end
	
	/** Calibrate twist bone axis rotation. */
	public func Vector getCalibrateTwistBoneAxisRotation()
		return pCalibrateTwistBoneAxisRotation
	end
	
	/** Calibrate twist transform. */
	public func Matrix getCalibrateTwistTransform()
		return pCalibrateTwistTransform
	end
	
	/** Calibrate twist curve in X direction. */
	public func CurveBezier getCalibrateTwistCurve()
		return pCalibrateTwistCurve
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass, ModifiedRig modifyRig)
		// add behavior
		var ECBMotionTransferTwist behavior = ECBMotionTransferTwist.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTarget, slotBase
		if not pTargetTracker.getSlot().empty()
			slotTarget = config.getTrackerSlots().getNamed(pTargetTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotBase = config.getTrackerSlots().getNamed(pBaseTracker.getSlot())
		end
		
		if slotTarget == null or slotBase == null or pCalibrateBones.getCount() == 0 \
		or pBaseBone.empty() or pTipBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		var String rootBone = pCalibrateBones.getAt(-1) cast String
		
		var int i, count, baseIndex
		
		// twist
		count = pCalibrateBones.getCount()
		
		// twist
		if count > 0 and DEMath.fabs(pTwistScale) > 0.001
			var ADRuleBoneTransformator rule
			var String name = getName() + ".twist"
			var float maxAngle = 180
			
			var ADController controllerTwist = ADController.new()
			controllerTwist.setName(behavior.getControllerNameTwist())
			controllerTwist.setMinimum(-maxAngle)
			controllerTwist.setMaximum(maxAngle)
			adef.addController(controllerTwist)
			
			var ADLink link = ADLink.new()
			link.setController(controllerTwist)
			adef.addLink(link)
			
			var float angle = pTwistScale * maxAngle / count
			baseIndex = count - 1
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var Vector axis = pCalibrateTwistAxes.getAt(i) cast Vector
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(-angle)
				rule.setMaximumAngle(angle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
				rule.addBone(bone)
				adef.addRule(rule)
			end
		end
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
		end
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pCalibrateBones.removeAll()
		pTargetTracker.resetTransform()
		pBaseTracker.resetTransform()
		pCalibrateTwistAxisMatrix = Matrix.new()
		pCalibrateTwistWeights.removeAll()
		pCalibrateTwistCurve.removeAllPoints()
		pCalibrateTwistAxes.removeAll()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateTwistTransform = Matrix.new()
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		findBoneChain(component.getRig(), pTipBone, pBaseBone, pCalibrateBones)
		
		pTargetTracker.resolveRealSlot(config)
		pTargetTracker.setTransform(component, pTargetBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(component, pTargetBaseBone)
		
		var int i, count = pCalibrateBones.getCount()
		
		// calibrate zero rotation
		var int indexBase = -1, indexTarget = -1, indexTip = -1
		if not pBaseBone.empty()
			indexBase = component.indexOfBoneNamed(pBaseBone)
			if not pTargetBone.empty()
				indexTarget = component.indexOfBoneNamed(pTargetBone)
			end
			indexTip = component.indexOfBoneNamed(pTipBone)
		end
		
		var Matrix baseMatrix = pBaseTracker.getTransformMatrix()
		if pBaseTracker.getRealSlot() != null
			baseMatrix = baseMatrix * pBaseTracker.getRealSlot().getCalibrateMatrix()
		end
		
		var Matrix targetMatrix = pTargetTracker.getTransformMatrix()
		if pTargetTracker.getRealSlot() != null
			targetMatrix = targetMatrix * pTargetTracker.getRealSlot().getCalibrateMatrix()
		end
		
		var Matrix twistAxisMatrix = Matrix.newRotation(pTwistAxisRotation)
		var Matrix baseMatrixInv = baseMatrix.getInverse()
		pCalibrateTwistAxisMatrix = (twistAxisMatrix * baseMatrixInv.getRotation()).getInverse()
		
		if indexBase != -1 and indexTip != -1
			var Vector position = (targetMatrix * baseMatrixInv * pCalibrateTwistAxisMatrix).getPosition()
			
			// twist weights
			pCalibrateTwistWeights.removeAll()
			
			var Array curveOffset = Array.newWith(0.0)
			var float curveLength = 0
			
			for i = count - 1 downto 1
				var String bone1 = pCalibrateBones.getAt(i - 1) cast String
				var int indexBone1 = component.indexOfBoneNamed(bone1)
				if indexBone1 == -1
					curveOffset.add(curveLength)
					continue
				end
				
				var String bone2 = pCalibrateBones.getAt(i) cast String
				var int indexBone2 = component.indexOfBoneNamed(bone2)
				if indexBone2 == -1
					curveOffset.add(curveLength)
					continue
				end
				
				var Vector position1 = component.boneGetMatrix(indexBone1).getPosition()
				var Vector position2 = component.boneGetMatrix(indexBone2).getPosition()
				
				curveLength += (position2 - position1).getLength()
				curveOffset.add(curveLength)
			end
			
			curveLength = DEMath.max(curveLength, 0.01) // avoid div by zero
			
			var Array weights = curveOffset.map(block float each
				return calcTwistWeight(pTwistShape, each / curveLength)
			end)
			
			var float sumWeights = weights.inject(0.0, block float accum, float each
				return accum + each
			end) cast float
			
			weights.forEachReverse(block float each
				pCalibrateTwistWeights.add(each / sumWeights)
			end)
			
			pCalibrateTwistCurve.removeAllPoints()
			pCalibrateTwistCurve.addPoint(-180, -180)
			pCalibrateTwistCurve.addPoint(180, 180)
			
			// calculate twist axes
			var Vector axis = Matrix.newRotation(pTwistAxisRotation).getViewVector()
			var int baseIndex = count - 1
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				if indexBone != -1
					pCalibrateTwistAxes.add(component.boneGetInverseMatrix(indexBone).transformNormal(axis))
					
				else
					pCalibrateTwistAxes.add(Vector.new(0, 0, 1))
				end
			end
			
			var Matrix invTargetMat
			
			if indexTarget != -1
				invTargetMat = component.boneGetInverseMatrix(indexTarget)
				
			elif pTargetTracker.getRealSlot() != null and pBaseTracker.getRealSlot() != null
				invTargetMat = targetMatrix.getInverse()
			end
			
			if invTargetMat != null
				pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pTwistAxisRotation)\
					* invTargetMat.normalize().getRotation()).getEulerAngles()
			end
			
			// (target * base^-1)^-1 => base * target^-1
			pCalibrateTwistTransform = baseMatrix * targetMatrix.getInverse()
		end
	end
	
	/** Calculate twist weight. */
	public func float calcTwistWeight(float shape, float offset)
		// the twist curve is calculate as a piecewise linear curve with 4 segments using
		// these connection curves at shape value 0, 0.25, 0.5, 0.75 and 1:
		// |..     ../     ---     \..    ..|
		// |..  ,  ./.  ,  ...  ,  .\.  , ..|
		// |..     /..     ...     ..\    ..|
		// 
		// hence at 0 value the base bone has full weight, at 1 value the tip bone has full
		// weight and at 0.5 all bones have equal weight. the values in between are blends
		// moving between these 3 state
		
		// value 0 and 1 can result in division by zero in on of the cases below hence clamped
		shape = DEMath.min(DEMath.max(shape, 0.01), 0.99)
		
		if shape < 0.25
			return DEMath.max(1.0 - offset * 0.25 / shape, 0.0)
			
		elif shape < 0.5
			return 1.0 - offset * ((0.5 - shape) / 0.25)
			
		elif shape < 0.75
			return 1.0 - (1.0 - offset) * ((shape - 0.5) / 0.25)
			
		else
			return DEMath.max(1.0 - ((1.0 - offset) * 0.25) / (1.0 - shape), 0.0)
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferTwist.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("targetBone")
				setTargetBone(element.getFirstCData())
				
			elif tagName.equals("targetBaseBone")
				setTargetBaseBone(element.getFirstCData())
				
			elif tagName.equals("tipBone")
				setTipBone(element.getFirstCData())
				
			elif tagName.equals("baseBone")
				setBaseBone(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("twistScale")
				setTwistScale(element.getFirstCDataFloat())
				
			elif tagName.equals("twistShape")
				setTwistShape(element.getFirstCDataFloat())
				
			elif tagName.equals("twistAxisRotation")
				setTwistAxisRotation(loader.readVector(element))
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	public func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("twistAxisMatrix")
				pCalibrateTwistAxisMatrix = GameApp.getGameApp().getLoadCharacterProfile().readMatrix(element)
				
			elif tagName.equals("twistWeight")
				pCalibrateTwistWeights.add(element.getFirstCDataFloat())
				
			elif tagName.equals("twistCurve")
				pCalibrateTwistCurve = loader.readCurveBezier(element)
				
			elif tagName.equals("twistAxis")
				pCalibrateTwistAxes.add(loader.readVector(element))
				
			elif tagName.equals("twistBoneAxisRotation")
				pCalibrateTwistBoneAxisRotation = loader.readVector(element)
				
			elif tagName.equals("twistTransform")
				pCalibrateTwistTransform = GameApp.getGameApp().getLoadCharacterProfile().readMatrix(element)
			end
		end)
	end
	
	/** Post load initialize. */
	public func void postLoadInit(CharacterConfiguration config)
		pTargetTracker.resolveRealSlot(config)
		pBaseTracker.resolveRealSlot(config)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("targetBone", pTargetBone)
		tag.addDataTag("targetBaseBone", pTargetBaseBone)
		tag.addDataTag("tipBone", pTipBone)
		tag.addDataTag("baseBone", pBaseBone)
		pTargetTracker.save(loader, tag.addTag("targetTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		tag.addDataTag("twistScale", pTwistScale)
		tag.addDataTag("twistShape", pTwistShape)
		loader.writeVector(tag, "twistAxisRotation", pTwistAxisRotation)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	public func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		var LoadCharacterProfile lcp = GameApp.getGameApp().getLoadCharacterProfile()
		
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTargetTracker.saveCalibrated(loader, tag.addTag("targetTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("baseTracker"))
		lcp.writeMatrix(tag, "twistAxisMatrix", pCalibrateTwistAxisMatrix)
		pCalibrateTwistWeights.forEach(block float each
			tag.addDataTag("twistWeight", each)
		end)
		loader.writeCurveBezier(tag, "twistCurve", pCalibrateTwistCurve)
		pCalibrateTwistAxes.forEach(block Vector each
			loader.writeVector(tag, "twistAxis", each)
		end)
		loader.writeVector(tag, "twistBoneAxisRotation", pCalibrateTwistBoneAxisRotation)
		lcp.writeMatrix(tag, "twistTransform", pCalibrateTwistTransform)
	end
end
