/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer rotating bone chain.
 * 
 * Defines root bone and target bone name. This defines the bone chain to manipulate.
 * The target bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 1 or more bones.
 * 
 * Defines two tracker slots to be used to get rotation from. The target tracker
 * position is transformed into the base tracker. The base bone indicates the bone
 * coordinate system to link to the base tracker. This defines the base coordinate
 * system in which the position of the target tracker is converted to a rotation
 * along each axis. This rotation is split across all bones in the chain. The amount
 * of transfered rotation can be scaled.
 */
class MotionTransferBend extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		func new()
		end
		
		func String factoryID()
			return "bend"
		end
		
		func MotionTransfer createMotionTransfer()
			return MotionTransferBend.new(factoryID())
		end
		
		func String displayName()
			return "@UI.BendBoneChain"
		end
	end
	
	
	var String pTargetBone, pTargetBaseBone, pTipBone, pBaseBone
	var MotionTransferTracker pTargetTracker, pBaseTracker, pStabilizeTracker
	var Vector2 pScaleRotation
	var float pBendShape
	var bool pFitCurveToTarget, pUseRotation
	var float pTwistPropagation, pTwistScale
	var int pTwistBoneCount
	var Vector pBendAxisRotation
	var String pBendMoveX, pBendMoveY
	var Vector2 pBendMoveRangeX, pBendMoveRangeY
	var bool pLockZDistance
	
	var ADController pADControllerBendX, pADControllerBendY, pADControllerTwist
	
	var Array pCalibrateBones
	var Matrix pCalibrateBendAxisMatrix
	var Vector pCalibrateZeroRotation
	var Array pCalibrateBendAxesX, pCalibrateBendAxesY, pCalibrateBendWeights
	var CurveBezier pCalibrateBendCurveX, pCalibrateBendCurveY
	var Array pCalibrateTwistAxes
	var Vector pCalibrateTwistBoneAxisRotation
	var Matrix pCalibrateTwistTransform
	var float pCalibrateLockedZDistance
	
	var Vector pCalibrateStabilizeAxis
	var Matrix pCalibrateBendAxisMatrixStabilize
	var Vector pCalibrateZeroRotationStabilize
	//var Vector pCalibrateStableBaseOffset
	
	
	/** Create motion transfer. */
	func new(String factoryID) super(factoryID)
		pTargetBone = ""
		pTargetBaseBone = ""
		pTipBone = ""
		pBaseBone = ""
		pTargetTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pStabilizeTracker = MotionTransferTracker.new()
		pScaleRotation = Vector2.new(1, 1)
		pBendShape = 0.5
		pFitCurveToTarget = false
		pUseRotation = false
		pTwistPropagation = 0
		pTwistScale = 1
		pTwistBoneCount = 0
		pBendAxisRotation = Vector.new()
		pBendMoveX = ""
		pBendMoveY = ""
		pBendMoveRangeX = Vector2.new(-90, 90)
		pBendMoveRangeY = Vector2.new(-90, 90)
		pLockZDistance = false
		pCalibrateBones = Array.new()
		pCalibrateBendAxisMatrix = Matrix.new()
		pCalibrateZeroRotation = Vector.new()
		pCalibrateStabilizeAxis = Vector.new()
		pCalibrateBendAxisMatrixStabilize = Matrix.new()
		pCalibrateZeroRotationStabilize = Vector.new()
		//pCalibrateStableBaseOffset = Vector.new()
		pCalibrateBendAxesX = Array.new()
		pCalibrateBendAxesY = Array.new()
		pCalibrateBendWeights = Array.new()
		pCalibrateBendCurveX = CurveBezier.newDefaultLinear()
		pCalibrateBendCurveY = CurveBezier.newDefaultLinear()
		pCalibrateTwistAxes = Array.new()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateTwistTransform = Matrix.new()
	end
	
	/** Create copy of motion transfer. */
	func new(MotionTransferBend transfer) super(transfer)
		pTargetBone = transfer.pTargetBone
		pTargetBaseBone = transfer.pTargetBaseBone
		pTipBone = transfer.pTipBone
		pBaseBone = transfer.pBaseBone
		pTargetTracker = MotionTransferTracker.new(transfer.pTargetTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pStabilizeTracker = MotionTransferTracker.new(transfer.pStabilizeTracker)
		pScaleRotation = transfer.pScaleRotation
		pBendShape = transfer.pBendShape
		pFitCurveToTarget = transfer.pFitCurveToTarget
		pUseRotation = transfer.pUseRotation
		pTwistPropagation = transfer.pTwistPropagation
		pTwistScale = transfer.pTwistScale
		pTwistBoneCount = transfer.pTwistBoneCount
		pBendAxisRotation = transfer.pBendAxisRotation
		pBendMoveX = transfer.pBendMoveX
		pBendMoveY = transfer.pBendMoveY
		pBendMoveRangeX = transfer.pBendMoveRangeX
		pBendMoveRangeY = transfer.pBendMoveRangeY
		pLockZDistance = transfer.pLockZDistance
		pCalibrateBones = Array.new(transfer.pCalibrateBones)
		pCalibrateBendAxisMatrix = transfer.pCalibrateBendAxisMatrix
		pCalibrateZeroRotation = transfer.pCalibrateZeroRotation
		pCalibrateStabilizeAxis = transfer.pCalibrateStabilizeAxis
		pCalibrateBendAxisMatrixStabilize = transfer.pCalibrateBendAxisMatrixStabilize
		pCalibrateZeroRotationStabilize = transfer.pCalibrateZeroRotationStabilize
		//pCalibrateStableBaseOffset = transfer.pCalibrateStableBaseOffset
		pCalibrateBendAxesX = Array.new(transfer.pCalibrateBendAxesX)
		pCalibrateBendAxesY = Array.new(transfer.pCalibrateBendAxesY)
		pCalibrateBendWeights = Array.new(transfer.pCalibrateBendWeights)
		pCalibrateBendCurveX = CurveBezier.new(transfer.pCalibrateBendCurveX)
		pCalibrateBendCurveY = CurveBezier.new(transfer.pCalibrateBendCurveY)
		pCalibrateTwistAxes = Array.new(transfer.pCalibrateTwistAxes)
		pCalibrateTwistBoneAxisRotation = transfer.pCalibrateTwistBoneAxisRotation
		pCalibrateTwistTransform = transfer.pCalibrateTwistTransform
	end
	
	
	
	/** Target bone name. */
	func String getTargetBone()
		return pTargetBone
	end
	
	/** Set target bone name. */
	func void setTargetBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBone = bone
	end
	
	/** Target base bone name. */
	func String getTargetBaseBone()
		return pTargetBaseBone
	end
	
	/** Set target base bone name. */
	func void setTargetBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBaseBone = bone
	end
	
	/** Tip bone name. */
	func String getTipBone()
		return pTipBone
	end
	
	/** Set tip bone name. */
	func void setTipBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTipBone = bone
	end
	
	/** Base bone name. */
	func String getBaseBone()
		return pBaseBone
	end
	
	/** Set base bone name. */
	func void setBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pBaseBone = bone
	end
	
	/** Target tracker. */
	func MotionTransferTracker getTargetTracker()
		return pTargetTracker
	end
	
	/** Base tracker. */
	func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Stabilize tracker. */
	func MotionTransferTracker getStabilizeTracker()
		return pStabilizeTracker
	end
	
	/** Scale rotation. */
	func Vector2 getScaleRotation()
		return pScaleRotation
	end
	
	/** Set scale rotation. */
	func void setScaleRotation(Vector2 scale)
		if scale == null
			throw ENullPointer.new("scale")
		end
		pScaleRotation = scale
	end
	
	/**
	 * Bend shape in the range from 0 to 1. 0 bends only at the base bone. 1 bends only at the
	 * tip bone. 0.5 bends all bones equally. Values in between gradually blend between.
	 */
	func float getBendShape()
		return pBendShape
	end
	
	/**
	 * Set bend shape in the range from 0 to 1. 0 bends only at the base bone. 1 bends only at the
	 * tip bone. 0.5 bends all bones equally. Values in between gradually blend between.
	 */
	func void setBendShape(float shape)
		pBendShape = DEMath.clamp(shape, 0.0, 1.0)
	end
	
	/**
	 * Fit curve to target. If true calculates the bending angle required for the curve to touch
	 * the target position. Use this only if the target position is located or beyond the curve
	 * end point otherwise wrong results are calculated.
	 */
	func bool getFitCurveToTarget()
		return pFitCurveToTarget
	end
	
	/**
	 * Set to fit curve to target. If true calculates the bending angle required for the curve
	 * to touch the target position. Use this only if the target position is located or beyond
	 * the curve end point otherwise wrong results are calculated.
	 */
	func void setFitCurveToTarget(bool fitCurveToTarget)
		pFitCurveToTarget = fitCurveToTarget
	end
	
	/** Use rotation of target relative to base instead of position to calculate bending angle. */
	func bool getUseRotation()
		return pUseRotation
	end
	
	/** Use rotation of target relative to base instead of position to calculate bending angle. */
	func void setUseRotation(bool useRotation)
		pUseRotation = useRotation
	end
	
	/** Percentage amount of twist propagated from tip bone to first bone after root bone. */
	func float getTwistPropagation()
		return pTwistPropagation
	end
	
	/** Set percentage amount of twist propagated from tip bone to first bone after root bone. */
	func void setTwistPropagation(float amount)
		pTwistPropagation = DEMath.max(amount, 0.0)
	end
	
	/** Scaling of twist angle before application. */
	func float getTwistScale()
		return pTwistScale
	end
	
	/** Set scaling of twist angle before application. */
	func void setTwistScale(float scale)
		pTwistScale = scale
	end
	
	/** Count of bones along chain to apply twist to starting at first bone after tip bone. */
	func int getTwistBoneCount()
		return pTwistBoneCount
	end
	
	/** Set count of bones along chain to apply twist to starting at first bone after tip bone. */
	func void setTwistBoneCount(int count)
		if count < 0
			throw EInvalidParam.new("count < 0")
		end
		pTwistBoneCount = count
	end
	
	/** Rotation of bend axis in component space. */
	func Vector getBendAxisRotation()
		return pBendAxisRotation
	end
	
	/** Set rotation of bend axis in component space. */
	func void setBendAxisRotation(Vector rotation)
		if rotation == null
			throw ENullPointer.new("rotation")
		end
		pBendAxisRotation = rotation
	end
	
	/** Animation move to use for X axis bending or empty string. */
	func String getBendMoveX()
		return pBendMoveX
	end
	
	/** Set animation move to use for X axis bending or empty string. */
	func void setBendMoveX(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pBendMoveX = move
	end
	
	/** Animation move to use for Y axis bending or empty string. */
	func String getBendMoveY()
		return pBendMoveY
	end
	
	/** Set animation move to use for Y axis bending or empty string. */
	func void setBendMoveY(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pBendMoveY = move
	end
	
	/**
	 * Range in degrees of bending X rotation to map to move based bending.
	 * X coordinate is negative range, Y coordinate is positive range.
	 */
	func Vector2 getBendMoveRangeX()
		return pBendMoveRangeX
	end
	
	/**
	 * Set range in degrees of bending X rotation to map to move based bending.
	 * X coordinate is negative range, Y coordinate is positive range.
	 */
	func void setBendMoveRangeX(Vector2 range)
		if range == null
			throw ENullPointer.new("range")
		end
		pBendMoveRangeX = range
	end
	
	/**
	 * Range in degrees of bending Y rotation to map to move based bending.
	 * X coordinate is negative range, Y coordinate is positive range.
	 */
	func Vector2 getBendMoveRangeY()
		return pBendMoveRangeY
	end
	
	/**
	 * Set range in degrees of bending Y rotation to map to move based bending.
	 * X coordinate is negative range, Y coordinate is positive range.
	 */
	func void setBendMoveRangeY(Vector2 range)
		if range == null
			throw ENullPointer.new("range")
		end
		pBendMoveRangeY = range
	end
	
	/** Lock Z distance for non-rotation bending calculation. */
	func bool getLockZDistance()
		return pLockZDistance
	end
	
	/** Set lock Z distance for non-rotation bending calculation. */
	func void setLockZDistance(bool lock)
		pLockZDistance = lock
	end
	
	
	
	/** Calibrate bend axis matrix (inverse bend axis matrix in base matrix). */
	func Matrix getCalibrateBendAxisMatrix()
		return pCalibrateBendAxisMatrix
	end
	
	/** Calibrate zero rotation. */
	func Vector getCalibrateZeroRotation()
		return pCalibrateZeroRotation
	end
	
	/** Calibrate stabilize axis. */
	func Vector getCalibrateStabilizeAxis()
		return pCalibrateStabilizeAxis
	end
	
	/** Calibrate bend axis matrix (inverse bend axis matrix in base matrix) stabilize. */
	func Matrix getCalibrateBendAxisMatrixStabilize()
		return pCalibrateBendAxisMatrixStabilize
	end
	
	/** Calibrate zero rotation stabilize. */
	func Vector getCalibrateZeroRotationStabilize()
		return pCalibrateZeroRotationStabilize
	end
	
	/** Calibrate stabilize base offset. */
	/*func Vector getCalibrateStableBaseOffset()
		return pCalibrateStableBaseOffset
	end*/
	
	/** Calibrate twist bone axis rotation. */
	func Vector getCalibrateTwistBoneAxisRotation()
		return pCalibrateTwistBoneAxisRotation
	end
	
	/** Calibrate twist transform. */
	func Matrix getCalibrateTwistTransform()
		return pCalibrateTwistTransform
	end
	
	/** Calibrate bend curve in X direction. */
	func CurveBezier getCalibrateBendCurveX()
		return pCalibrateBendCurveX
	end
	
	/** Calibrate bend curve in Y direction. */
	func CurveBezier getCalibrateBendCurveY()
		return pCalibrateBendCurveY
	end
	
	/** Calibrate locked z distance. */
	func float getCalibrateLockedZDistance()
		return pCalibrateLockedZDistance
	end
	
	
	
	/** Init element clas. */
	func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass, ModifiedRig modifyRig)
		pTargetTracker.finishCalibrate()
		pBaseTracker.finishCalibrate()
		pStabilizeTracker.finishCalibrate()
		
		pADControllerBendX = null
		pADControllerBendY = null
		pADControllerTwist = null
		
		// add behavior
		var ECBMotionTransferBend behavior = ECBMotionTransferBend.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTarget, slotBase, slotStabilize
		if not pTargetTracker.getSlot().empty()
			slotTarget = config.getTrackerSlots().getNamed(pTargetTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotBase = config.getTrackerSlots().getNamed(pBaseTracker.getSlot())
		end
		if not pStabilizeTracker.getSlot().empty()
			slotStabilize = config.getTrackerSlots().getNamed(pStabilizeTracker.getSlot())
		end
		
		if slotTarget == null or slotBase == null or pCalibrateBones.getCount() == 0 \
		or pBaseBone.empty() or pTipBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		// var String rootBone = pCalibrateBones.getAt(-1) cast String
		var float fullRotation = 180
		
		pADControllerBendX = ADController.new()
		pADControllerBendX.setName(behavior.getControllerNameBendX())
		pADControllerBendX.setMinimum(-fullRotation)
		pADControllerBendX.setMaximum(fullRotation)
		adef.addController(pADControllerBendX)
		
		pADControllerBendY = ADController.new()
		pADControllerBendY.setName(behavior.getControllerNameBendY())
		pADControllerBendY.setMinimum(-fullRotation)
		pADControllerBendY.setMaximum(fullRotation)
		adef.addController(pADControllerBendY)
		
		var ADLink linkBendX = ADLink.new()
		linkBendX.setController(pADControllerBendX)
		adef.addLink(linkBendX)
		
		var ADLink linkBendY = ADLink.new()
		linkBendY.setController(pADControllerBendY)
		adef.addLink(linkBendY)
		
		var ADLink linkMoveBendX
		if not pBendMoveX.empty()
			linkMoveBendX = ADLink.new()
			linkMoveBendX.setController(pADControllerBendX)
			
			var Vector2 factor = pBendMoveRangeX / (fullRotation * 2)
			var CurveBezier curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0.5 + factor.getX(), 0)
			curve.addPoint(0.5 + factor.getY(), 1)
			linkMoveBendX.setCurve(curve)
			adef.addLink(linkMoveBendX)
		end
		
		var ADLink linkMoveBendY
		if not pBendMoveY.empty()
			linkMoveBendY = ADLink.new()
			linkMoveBendY.setController(pADControllerBendY)
			
			var Vector2 factor = pBendMoveRangeY / (fullRotation * 2)
			var CurveBezier curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0.5 + factor.getX(), 0)
			curve.addPoint(0.5 + factor.getY(), 1)
			linkMoveBendY.setCurve(curve)
			adef.addLink(linkMoveBendY)
		end
		
		var int i, count, baseIndex
		
		// bending
		var String nameBendX = getName() + ".bendX"
		var String nameBendY = getName() + ".bendY"
		
		count = pCalibrateBones.getCount()
		baseIndex = count - 1
		
		if linkMoveBendX != null
			var ADRuleAnimationDifference rule = ADRuleAnimationDifference.new()
			rule.setName(nameBendX)
			rule.setReferenceMoveName(pBendMoveX)
			rule.setLeadingMoveName(pBendMoveX)
			rule.setEnableSize(true)
			rule.setEnableVertexPositionSet(false)
			rule.setReferenceMoveTime(0.5)
			rule.addTargetLink(ADRuleTargetLink.new(ARAnimationDifferenceTarget.leadingMoveTime, linkMoveBendX))
			/*
			for i = 0 to count
				rule.addBone(pCalibrateBones.getAt(baseIndex - i) cast String)
			end
			*/
			adef.addRule(rule)
		end
		
		if linkMoveBendY != null
			var ADRuleAnimationDifference rule = ADRuleAnimationDifference.new()
			rule.setName(nameBendY)
			rule.setReferenceMoveName(pBendMoveY)
			rule.setLeadingMoveName(pBendMoveY)
			rule.setEnableSize(true)
			rule.setEnableVertexPositionSet(false)
			rule.setReferenceMoveTime(0.5)
			rule.addTargetLink(ADRuleTargetLink.new(ARAnimationDifferenceTarget.leadingMoveTime, linkMoveBendY))
			/*
			for i = 0 to count
				rule.addBone(pCalibrateBones.getAt(baseIndex - i) cast String)
			end
			*/
			adef.addRule(rule)
		end
		
		if linkMoveBendX == null or linkMoveBendY == null
			var ADRuleBoneTransformator rule
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var float weight = pCalibrateBendWeights.getAt(baseIndex - i) cast float
				var float boneRotation = fullRotation * weight
				
				if linkMoveBendX == null
					rule = ADRuleBoneTransformator.new()
					rule.setName(nameBendX)
					rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
					rule.setUseAxis(true)
					rule.setAxis(pCalibrateBendAxesX.getAt(i) cast Vector)
					rule.setMinimumAngle(-boneRotation)
					rule.setMaximumAngle(boneRotation)
					rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkBendX))
					rule.addBone(bone)
					adef.addRule(rule)
				end
				
				if linkMoveBendY == null
					rule = rule = ADRuleBoneTransformator.new()
					rule.setName(nameBendY)
					rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
					rule.setUseAxis(true)
					rule.setAxis(pCalibrateBendAxesY.getAt(i) cast Vector)
					rule.setMinimumAngle(-boneRotation)
					rule.setMaximumAngle(boneRotation)
					rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkBendY))
					rule.addBone(bone)
					adef.addRule(rule)
				end
			end
		end
		
		// twist
		count = DEMath.min(DEMath.max(pTwistBoneCount, 1), pCalibrateBones.getCount())
		var ADRuleBoneTransformator rule
		var String name = getName() + ".twist"
		var float maxAngle = 180
		
		pADControllerTwist = ADController.new()
		pADControllerTwist.setName(behavior.getControllerNameTwist())
		pADControllerTwist.setMinimum(-maxAngle)
		pADControllerTwist.setMaximum(maxAngle)
		adef.addController(pADControllerTwist)
		
		var ADLink link = ADLink.new()
		link.setController(pADControllerTwist)
		adef.addLink(link)
		
		var float angle = pTwistPropagation * maxAngle / count
		if pTwistPropagation <= 0.01
			angle = 0
		end
		
		var float tipAngle = maxAngle - angle * ( count - 1 )
		
		baseIndex = count - 1
		
		for i = 0 to count
			if i > 0 and pTwistPropagation <= 0.01
				continue
			end
			
			var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
			var Vector axis = pCalibrateTwistAxes.getAt(i) cast Vector
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(name)
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
			rule.setUseAxis(true)
			rule.setAxis(axis)
			
			if i > 0
				rule.setMinimumAngle(-angle)
				rule.setMaximumAngle(angle)
				
			else
				rule.setMinimumAngle(-tipAngle)
				rule.setMaximumAngle(tipAngle)
			end
			
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
			rule.addBone(bone)
			adef.addRule(rule)
		end
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
		end
	end
	
	/** Reset calibration. */
	func void resetCalibration()
		pADControllerBendX = null
		pADControllerBendY = null
		pADControllerTwist = null
		
		pCalibrateBones.removeAll()
		pTargetTracker.resetTransform()
		pBaseTracker.resetTransform()
		pCalibrateBendAxisMatrix = Matrix.new()
		pCalibrateZeroRotation = Vector.new()
		pStabilizeTracker.resetTransform()
		pCalibrateStabilizeAxis = Vector.new()
		pCalibrateBendAxisMatrixStabilize = Matrix.new()
		pCalibrateZeroRotationStabilize = Vector.new()
		//pCalibrateStableBaseOffset = Vector.new()
		pCalibrateBendAxesX.removeAll()
		pCalibrateBendAxesY.removeAll()
		pCalibrateBendWeights.removeAll()
		pCalibrateBendCurveX.removeAllPoints()
		pCalibrateBendCurveY.removeAllPoints()
		pCalibrateTwistAxes.removeAll()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateTwistTransform = Matrix.new()
		pCalibrateLockedZDistance = 0
	end
	
	/** Calibrate character. */
	func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		findBoneChain(component.getRig(), pTipBone, pBaseBone, pCalibrateBones)
		
		if pCalibrateBones.getCount() == 0
			return
		end
		
		pTargetTracker.resolveRealSlot(config)
		pTargetTracker.setTransform(config, component, pTargetBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(config, component, pTargetBaseBone)
		
		pStabilizeTracker.resolveRealSlot(config)
		pStabilizeTracker.setTransform(config, component, "")
		
		// calibrate zero rotation
		pCalibrateZeroRotation = Vector.new()
		pCalibrateStabilizeAxis = Vector.new()
		pCalibrateZeroRotationStabilize = Vector.new()
		//pCalibrateStableBaseOffset = Vector.new()
		
		var int indexBase = -1, indexTarget = -1, indexTip = -1
		if not pBaseBone.empty()
			indexBase = component.indexOfBoneNamed(pBaseBone)
			if not pTargetBone.empty()
				indexTarget = component.indexOfBoneNamed(pTargetBone)
			end
			indexTip = component.indexOfBoneNamed(pTipBone)
		end
		
		var Matrix baseMatrix = pBaseTracker.getTransformMatrix()
		if pBaseTracker.getRealSlot() != null
			baseMatrix = baseMatrix * pBaseTracker.getRealSlot().getCalibrateMatrix()
		end
		
		var Matrix targetMatrix = pTargetTracker.getTransformMatrix()
		if pTargetTracker.getRealSlot() != null
			targetMatrix = targetMatrix * pTargetTracker.getRealSlot().getCalibrateMatrix()
		end
		
		var Matrix bendAxisMatrix = Matrix.newRotation(pBendAxisRotation)
		
		if pStabilizeTracker.getRealSlot() != null and pBaseTracker.getRealSlot() != null\
		and pTargetTracker.getRealSlot() != null
			var Matrix stabilizeMatrix = pStabilizeTracker.getTransformMatrix()\
				* pStabilizeTracker.getRealSlot().getCalibrateMatrix()
			
			pCalibrateStabilizeAxis = pBaseTracker.getRealSlot().getCalibrateMatrixInverse().\
				transformNormal(bendAxisMatrix.getViewVector())
			
			//var Vector stabilizePos = stabilizeMatrix.getPosition()
			var Vector basePos = pBaseTracker.getRealSlot().getCalibratePosition()
			
			var Matrix stabilizeMatrixInv = stabilizeMatrix.getInverse()
			pCalibrateBendAxisMatrixStabilize = (bendAxisMatrix * stabilizeMatrixInv.getRotation()).getInverse()
			
			var Vector position = (stabilizeMatrixInv * pCalibrateBendAxisMatrixStabilize) * basePos
			
			var float radius = Vector2.new(position.getX(), position.getZ()).getLength()
			var float rotY = DEMath.atan2(-position.getX(), position.getZ())
			var float rotX
			
			if DEMath.fabs(rotY) <= 90
				rotX = DEMath.atan2(position.getY(), radius)
				
			else
				rotX = DEMath.atan2(position.getY(), -radius)
				rotY = DEMath.normalize(rotY + 180, -90, 90)
			end
			
			pCalibrateZeroRotationStabilize = Vector.new(-rotX, -rotY, 0)
			/*if getName().equals("AutoHuman: Neck Shift")
				GameApp.getApp().getConsole().addMessage("INIT(S): " + Array.newWith(rotX, rotY, position))
			end*/
			
			/*
			var Vector axis = basePos - stabilizePos
			if not axis.isZero()
				pCalibrateStabilizeAxis = pBaseTracker.getRealSlot().\
					getCalibrateMatrixInverse().transformNormal(axis.normalize())
			end
			*/
		end
		
		/*
		if pStabilizeTracker.getRealSlot() != null and pBaseTracker.getRealSlot() != null and not pUseRotation
			var Vector stabilizePos = (pStabilizeTracker.getTransformMatrix()\
				* pStabilizeTracker.getRealSlot().getCalibrateMatrix()).getPosition()
			
			var Vector basePos = pBaseTracker.getRealSlot().getCalibratePosition()
				pCalibrateStableBaseOffset = baseMatrix.getPosition() - basePos
			end
			baseMatrix = Matrix.newWorld(baseMatrix.getPosition(), stabilizeMatrix.toQuaternion())
			
			// zero rotation
			var Matrix stabilizeMatrixInv = stabilizeMatrix.getInverse()
			pCalibrateBendAxisMatrixStabilize = (bendAxisMatrix * stabilizeMatrixInv.getRotation()).getInverse()
			
			var Vector position = (stabilizeMatrixInv * pCalibrateBendAxisMatrixStabilize) * basePos
			
			var float radius = Vector2.new(position.getX(), position.getZ()).getLength()
			var float rotY = DEMath.atan2(-position.getX(), position.getZ())
			var float rotX
			
			if DEMath.fabs(rotY) <= 90
				rotX = DEMath.atan2(position.getY(), radius)
				
			else
				rotX = DEMath.atan2(position.getY(), -radius)
				rotY = DEMath.normalize(rotY + 180, -90, 90)
			end
			
			pCalibrateZeroRotationStabilize = Vector.new(-rotX, -rotY, 0)
			if getName().equals("AutoHuman: Neck Shift")
				GameApp.getApp().getConsole().addMessage("INIT(S): " + Array.newWith(rotX, rotY, position))
			end
		end
		*/
		
		var Matrix baseMatrixInv = baseMatrix.getInverse()
		pCalibrateBendAxisMatrix = (bendAxisMatrix * baseMatrixInv.getRotation()).getInverse()
		pCalibrateLockedZDistance = 0
		
		if indexBase != -1 and indexTip != -1
			// zero rotation
			var Matrix bendMatrix = targetMatrix * baseMatrixInv * pCalibrateBendAxisMatrix
			var Vector position = bendMatrix.getPosition()
			
			if pUseRotation
				pCalibrateZeroRotation = (bendAxisMatrix * targetMatrix.getRotation().getInverse()).getEulerAngles()
				
			else
				// rotation.x = atan2(y, abs((x, z)))
				// rotation.y = atan2(-x, z)
				// rotation.z = 0
				// calibration = -rotation
				//             = (-atan2(y, abs((x, z))), -atan2(-x, z), 0)
				//             = (atan2(-y, abs((x, z))), atan2(x, z), 0)
				
				/*
				pCalibrateZeroRotation = Vector.new(\
					DEMath.atan2(-position.getY(), Vector2.new(position.getX(), position.getZ()).getLength()),\
					DEMath.atan2(position.getX(), position.getZ()), 0)
				*/
				
				var float radius = Vector2.new(position.getX(), position.getZ()).getLength()
				var float rotY = DEMath.atan2(-position.getX(), position.getZ())
				var float rotX
				
				if DEMath.fabs(rotY) <= 90
					rotX = DEMath.atan2(position.getY(), radius)
					
				else
					rotX = DEMath.atan2(position.getY(), -radius)
					rotY = DEMath.normalize(rotY + 180, -90, 90)
				end
				
				pCalibrateZeroRotation = Vector.new(-rotX, -rotY, 0)
				pCalibrateLockedZDistance = position.getZ()
				/*if getName().equals("AutoHuman: Neck Shift")
					GameApp.getApp().getConsole().addMessage("INIT: " + Array.newWith(rotX, rotY, position))
				end*/
			end
			
			// bend axes
			var Vector axisX = bendAxisMatrix.getRightVector()
			var Vector axisY = bendAxisMatrix.getUpVector()
			var int count = pCalibrateBones.getCount()
			var int i, baseIndex = count - 1
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				
				if indexBone != -1
					var Matrix boneMatrix = component.boneGetInverseMatrix(indexBone).normalize()
					pCalibrateBendAxesX.add(boneMatrix.transformNormal(axisX))
					pCalibrateBendAxesY.add(boneMatrix.transformNormal(axisY))
					
				else
					pCalibrateBendAxesX.add(Vector.new(1, 0, 0))
					pCalibrateBendAxesY.add(Vector.new(0, 1, 0))
				end
			end
			
			// zero rotation
			
			// bend weights
			pCalibrateBendWeights.removeAll()
			
			var Array curveOffset = Array.newWith(0.0)
			var float curveLength = 0
			
			for i = count - 1 downto 1
				var String bone1 = pCalibrateBones.getAt(i - 1) cast String
				var int indexBone1 = component.indexOfBoneNamed(bone1)
				if indexBone1 == -1
					curveOffset.add(curveLength)
					continue
				end
				
				var String bone2 = pCalibrateBones.getAt(i) cast String
				var int indexBone2 = component.indexOfBoneNamed(bone2)
				if indexBone2 == -1
					curveOffset.add(curveLength)
					continue
				end
				
				var Vector position1 = component.boneGetMatrix(indexBone1).getPosition()
				var Vector position2 = component.boneGetMatrix(indexBone2).getPosition()
				
				curveLength += (position2 - position1).getLength()
				curveOffset.add(curveLength)
			end
			
			curveLength = DEMath.max(curveLength, 0.01) // avoid div by zero
			
			var Array weights = curveOffset.map(block float each
				return calcBendWeight(pBendShape, each / curveLength)
			end)
			
			var float sumWeights = weights.inject(0.0, block float accum, float each
				return accum + each
			end) cast float
			
			weights.forEachReverse(block float each
				pCalibrateBendWeights.add(each / sumWeights)
			end)
			
			// bend target rotations. we need to calculate this using an endpoint on the curve
			if pFitCurveToTarget
				var int bendTargetResolution = 13 // 12 segments
				// var float bendRotationStep = 180.0 / pCalibrateBones.getCount()
				var Array bendTargetX = Array.new(bendTargetResolution, position)
				var Array bendTargetY = Array.new(bendTargetResolution, position)
				var Array bendRotation = Array.new()
				var int j
				
				for i = 0 to bendTargetResolution
					bendRotation.add(DEMath.linearStep(i, 0, bendTargetResolution - 1, -180, 180))
				end
				
				for i = 0 to count
					var String bone = pCalibrateBones.getAt(i) cast String
					var int indexBone = component.indexOfBoneNamed(bone)
					if indexBone == -1
						continue
					end
					
					var Vector bonePosition = (component.boneGetMatrix(indexBone)\
						* baseMatrixInv * pCalibrateBendAxisMatrix).getPosition()
					var Matrix boneMatrix1 = Matrix.newTranslation(-bonePosition)
					var Matrix boneMatrix2 = Matrix.newTranslation(bonePosition)
					var float rotationWeight = pCalibrateBendWeights.getAt(i) cast float
					
					for j = 0 to bendTargetResolution
						var float rotation = rotationWeight * bendRotation.getAt(j) cast float
						
						bendMatrix = boneMatrix1 * Matrix.newRotationX(rotation) * boneMatrix2
						bendTargetX.setAt(j, bendMatrix * bendTargetX.getAt(j) cast Vector)
						
						bendMatrix = boneMatrix1 * Matrix.newRotationY(rotation) * boneMatrix2
						bendTargetY.setAt(j, bendMatrix * bendTargetY.getAt(j) cast Vector)
					end
				end
				
				pCalibrateBendCurveX.removeAllPoints()
				pCalibrateBendCurveY.removeAllPoints()
				
				var Matrix matrixZeroRotX = Matrix.newRotationX(-pCalibrateZeroRotation.getX())
				var Matrix matrixZeroRotY = Matrix.newRotationY(-pCalibrateZeroRotation.getY())
				
				for i = 0 to bendTargetResolution
					var float rotation = bendRotation.getAt(i) cast float
				
					var Vector target = matrixZeroRotX * bendTargetX.getAt(i) cast Vector
					pCalibrateBendCurveX.addPoint(DEMath.atan2(target.getY(), target.getZ()), rotation)
					
					target = matrixZeroRotY * bendTargetY.getAt(i) cast Vector
					pCalibrateBendCurveY.addPoint(-DEMath.atan2(target.getX(), target.getZ()), rotation)
				end
				
			else
				pCalibrateBendCurveX.removeAllPoints()
				pCalibrateBendCurveX.addPoint(-180, -180)
				pCalibrateBendCurveX.addPoint(180, 180)
				
				pCalibrateBendCurveY.removeAllPoints()
				pCalibrateBendCurveY.addPoint(-180, -180)
				pCalibrateBendCurveY.addPoint(180, 180)
			end
		end
		
		// calculate twist axes
		var int count = DEMath.min(DEMath.max(pTwistBoneCount, 1), pCalibrateBones.getCount())
		var Vector axis = Matrix.newRotation(pBendAxisRotation).getViewVector()
		var int i, baseIndex = count - 1
		
		for i = 0 to count
			var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
			var int indexBone = component.indexOfBoneNamed(bone)
			if indexBone != -1
				pCalibrateTwistAxes.add(component.boneGetInverseMatrix(indexBone).normalize().transformNormal(axis))
				
			else
				pCalibrateTwistAxes.add(Vector.new(0, 0, 1))
			end
		end
		
		var Matrix invTargetMat
		
		if indexTarget != -1
			invTargetMat = component.boneGetInverseMatrix(indexTarget).normalize()
			
		elif pTargetTracker.getRealSlot() != null and pBaseTracker.getRealSlot() != null
			invTargetMat = targetMatrix.getInverse()
		end
		
		if invTargetMat != null
			pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pBendAxisRotation)\
				* invTargetMat.getRotation()).getEulerAngles()
		end
		
		// (target * base^-1)^-1 => base * target^-1
		pCalibrateTwistTransform = baseMatrix * targetMatrix.getInverse()
	end
	
	/** Calculate bend weight. */
	func float calcBendWeight(float shape, float offset)
		// the bend curve is calculate as a piecewise linear curve with 4 segments using
		// these connection curves at shape value 0, 0.25, 0.5, 0.75 and 1:
		// |..     ../     ---     \..    ..|
		// |..  ,  ./.  ,  ...  ,  .\.  , ..|
		// |..     /..     ...     ..\    ..|
		// 
		// hence at 0 value the base bone has full weight, at 1 value the tip bone has full
		// weight and at 0.5 all bones have equal weight. the values in between are blends
		// moving between these 3 state
		
		// value 0 and 1 can result in division by zero in on of the cases below hence clamped
		shape = DEMath.min(DEMath.max(shape, 0.01), 0.99)
		
		if shape < 0.25
			return DEMath.max(1.0 - offset * 0.25 / shape, 0.0)
			
		elif shape < 0.5
			return 1.0 - offset * ((0.5 - shape) / 0.25)
			
		elif shape < 0.75
			return 1.0 - (1.0 - offset) * ((shape - 0.5) / 0.25)
			
		else
			return DEMath.max(1.0 - ((1.0 - offset) * 0.25) / (1.0 - shape), 0.0)
		end
	end
	
	/** Create copy of motion transfer. */
	func MotionTransfer createCopy()
		return MotionTransferBend.new(this)
	end
	
	/** Load from XML. */
	func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("targetBone")
				setTargetBone(element.getFirstCData())
				
			elif tagName.equals("targetBaseBone")
				setTargetBaseBone(element.getFirstCData())
				
			elif tagName.equals("tipBone")
				setTipBone(element.getFirstCData())
				
			elif tagName.equals("baseBone")
				setBaseBone(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("stabilizeTracker")
				pStabilizeTracker.load(loader, element)
				
			elif tagName.equals("scaleRotation")
				setScaleRotation(loader.readVector2(element))
				
			elif tagName.equals("bendShape")
				setBendShape(element.getFirstCDataFloat())
				
			elif tagName.equals("fitCurveToTarget")
				setFitCurveToTarget(element.getFirstCDataBool())
				
			elif tagName.equals("useRotation")
				setUseRotation(element.getFirstCDataBool())
				
			elif tagName.equals("twistPropagation")
				setTwistPropagation(element.getFirstCDataFloat())
				
			elif tagName.equals("twistScale")
				setTwistScale(element.getFirstCDataFloat())
				
			elif tagName.equals("twistBoneCount")
				setTwistBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("bendAxisRotation")
				setBendAxisRotation(loader.readVector(element))
				
			elif tagName.equals("bendMoveX")
				setBendMoveX(element.getFirstCData())
				
			elif tagName.equals("bendMoveY")
				setBendMoveY(element.getFirstCData())
				
			elif tagName.equals("bendMoveRangeX")
				pBendMoveRangeX = loader.readVector2(element)
				
			elif tagName.equals("bendMoveRangeY")
				pBendMoveRangeY = loader.readVector2(element)

			elif tagName.equals("bendMoveRange")
				// backwards compatibility
				var Vector2 range = loader.readVector2(element)
				pBendMoveRangeX = Vector2.new(-range.getX(), range.getX())
				pBendMoveRangeY = Vector2.new(-range.getY(), range.getY())
				
			elif tagName.equals("lockZDistance")
				pLockZDistance = element.getFirstCDataBool()
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("bendAxisMatrix")
				pCalibrateBendAxisMatrix = GameApp.getGameApp().getLoadCharacterProfile().readMatrix(element)
				
			elif tagName.equals("zeroRotation")
				pCalibrateZeroRotation = loader.readVector(element)
				
			elif tagName.equals("stabilizeTracker")
				pStabilizeTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("stabilizeAxis")
				pCalibrateStabilizeAxis = loader.readVector(element)
				
			elif tagName.equals("bendAxisMatrixStabilize")
				pCalibrateBendAxisMatrixStabilize = GameApp.getGameApp().getLoadCharacterProfile().readMatrix(element)
				
			elif tagName.equals("zeroRotationStabilize")
				pCalibrateZeroRotationStabilize = loader.readVector(element)
				
			//elif tagName.equals("stableBaseOffset")
			//	pCalibrateStableBaseOffset = loader.readVector(element)
				
			elif tagName.equals("bendAxisX")
				pCalibrateBendAxesX.add(loader.readVector(element))
				
			elif tagName.equals("bendAxisY")
				pCalibrateBendAxesY.add(loader.readVector(element))
				
			elif tagName.equals("bendWeight")
				pCalibrateBendWeights.add(element.getFirstCDataFloat())
				
			elif tagName.equals("bendCurveX")
				pCalibrateBendCurveX = loader.readCurveBezier(element)
				
			elif tagName.equals("bendCurveY")
				pCalibrateBendCurveY = loader.readCurveBezier(element)
				
			elif tagName.equals("twistAxis")
				pCalibrateTwistAxes.add(loader.readVector(element))
				
			elif tagName.equals("twistBoneAxisRotation")
				pCalibrateTwistBoneAxisRotation = loader.readVector(element)
				
			elif tagName.equals("twistTransform")
				pCalibrateTwistTransform = GameApp.getGameApp().getLoadCharacterProfile().readMatrix(element)
				
			elif tagName.equals("lockedZDistance")
				pCalibrateLockedZDistance = element.getFirstCDataFloat()
			end
		end)
	end
	
	/** Post load initialize. */
	func void postLoadInit(CharacterConfiguration config)
		pTargetTracker.resolveRealSlot(config)
		pBaseTracker.resolveRealSlot(config)
		pStabilizeTracker.resolveRealSlot(config)
	end
	
	/** Save to XML. */
	func void save(BaseXmlLoader loader, EasyXMLElement tag, bool calibrated)
		tag.addDataTag("name", getName())
		tag.addDataTag("targetBone", pTargetBone)
		tag.addDataTag("targetBaseBone", pTargetBaseBone)
		tag.addDataTag("tipBone", pTipBone)
		tag.addDataTag("baseBone", pBaseBone)
		pTargetTracker.save(loader, tag.addTag("targetTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		pStabilizeTracker.save(loader, tag.addTag("stabilizeTracker"))
		loader.writeVector2(tag, "scaleRotation", pScaleRotation)
		tag.addDataTag("bendShape", pBendShape)
		tag.addDataTag("fitCurveToTarget", pFitCurveToTarget)
		tag.addDataTag("useRotation", pUseRotation)
		tag.addDataTag("twistPropagation", pTwistPropagation)
		tag.addDataTag("twistScale", pTwistScale)
		tag.addDataTag("twistBoneCount", pTwistBoneCount)
		loader.writeVector(tag, "bendAxisRotation", pBendAxisRotation)
		tag.addDataTag("bendMoveX", pBendMoveX)
		tag.addDataTag("bendMoveY", pBendMoveY)
		loader.writeVector2(tag, "bendMoveRangeX", pBendMoveRangeX)
		loader.writeVector2(tag, "bendMoveRangeY", pBendMoveRangeY)
		tag.addDataTag("lockZDistance", pLockZDistance)
		
		if calibrated
			saveCalibrated(loader, tag.addTag("calibrated"))
		end
	end
	
	func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		var LoadCharacterProfile lcp = GameApp.getGameApp().getLoadCharacterProfile()
		
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTargetTracker.saveCalibrated(loader, tag.addTag("targetTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("baseTracker"))
		lcp.writeMatrix(tag, "bendAxisMatrix", pCalibrateBendAxisMatrix)
		loader.writeVector(tag, "zeroRotation", pCalibrateZeroRotation)
		pStabilizeTracker.saveCalibrated(loader, tag.addTag("stabilizeTracker"))
		loader.writeVector(tag, "stabilizeAxis", pCalibrateStabilizeAxis)
		lcp.writeMatrix(tag, "bendAxisMatrixStabilize", pCalibrateBendAxisMatrixStabilize)
		loader.writeVector(tag, "zeroRotationStabilize", pCalibrateZeroRotationStabilize)
		//loader.writeVector(tag, "stableBaseOffset", pCalibrateStableBaseOffset)
		pCalibrateBendAxesX.forEach(block Vector each
			loader.writeVector(tag, "bendAxisX", each)
		end)
		pCalibrateBendAxesY.forEach(block Vector each
			loader.writeVector(tag, "bendAxisY", each)
		end)
		pCalibrateBendWeights.forEach(block float each
			tag.addDataTag("bendWeight", each)
		end)
		loader.writeCurveBezier(tag, "bendCurveX", pCalibrateBendCurveX)
		loader.writeCurveBezier(tag, "bendCurveY", pCalibrateBendCurveY)
		pCalibrateTwistAxes.forEach(block Vector each
			loader.writeVector(tag, "twistAxis", each)
		end)
		loader.writeVector(tag, "twistBoneAxisRotation", pCalibrateTwistBoneAxisRotation)
		lcp.writeMatrix(tag, "twistTransform", pCalibrateTwistTransform)
		tag.addDataTag("lockedZDistance", pCalibrateLockedZDistance)
	end
end
