/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer rotating bone chain.
 * 
 * Defines root bone and target bone name. This defines the bone chain to manipulate.
 * The target bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 1 or more bones.
 * 
 * Defines two tracker slots to be used to get rotation from. The target tracker
 * position is transformed into the base tracker. The base bone indicates the bone
 * coordinate system to link to the base tracker. This defines the base coordinate
 * system in which the position of the target tracker is converted to a rotation
 * along each axis. This rotation is split across all bones in the chain. The amount
 * of transfered rotation can be scaled.
 */
class MotionTransferBend extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "bend"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferBend.new(factoryID())
		end
		
		public func String displayName()
			return "Bend Bone Chain"
		end
	end
	
	
	
	private var String pTargetBone
	private var String pTipBone
	private var String pBaseBone
	private var MotionTransferTracker pTargetTracker
	private var MotionTransferTracker pBaseTracker
	private var Vector2 pScaleRotation
	private var float pTwistPropagation
	private var int pTwistBoneCount
	private var Vector pTwistAxisRotation
	
	private var ADController pADControllerBendX
	private var ADController pADControllerBendY
	private var ADController pADControllerTwist
	
	private var Array pCalibrateBones
	private var Vector2 pCalibrateZeroRotation
	private var Array pCalibrateBendAxesX
	private var Array pCalibrateBendAxesY
	private var Vector pCalibrateTwistRotation
	private var Array pCalibrateTwistAxes
	private var Vector pCalibrateTwistBoneAxisRotation
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTargetBone = ""
		pTipBone = ""
		pBaseBone = ""
		pTargetTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pScaleRotation = Vector2.new(1, 1)
		pTwistPropagation = 0
		pTwistBoneCount = 0
		pTwistAxisRotation = Vector.new()
		pCalibrateBones = Array.new()
		pCalibrateZeroRotation = Vector2.new()
		pCalibrateBendAxesX = Array.new()
		pCalibrateBendAxesY = Array.new()
		pCalibrateTwistRotation = Vector.new()
		pCalibrateTwistAxes = Array.new()
		pCalibrateTwistBoneAxisRotation = Vector.new()
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferBend transfer) super(transfer)
		pTargetBone = transfer.pTargetBone
		pTipBone = transfer.pTipBone
		pBaseBone = transfer.pBaseBone
		pTargetTracker = MotionTransferTracker.new(transfer.pTargetTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pScaleRotation = transfer.pScaleRotation
		pTwistPropagation = transfer.pTwistPropagation
		pTwistBoneCount = transfer.pTwistBoneCount
		pTwistAxisRotation = transfer.pTwistAxisRotation
		pCalibrateBones = Array.new()
		pCalibrateZeroRotation = transfer.pCalibrateZeroRotation
		pCalibrateBendAxesX = Array.new(transfer.pCalibrateBendAxesX)
		pCalibrateBendAxesY = Array.new(transfer.pCalibrateBendAxesY)
		pCalibrateTwistRotation = transfer.pCalibrateTwistRotation
		pCalibrateTwistAxes = Array.new(transfer.pCalibrateTwistAxes)
		pCalibrateTwistBoneAxisRotation = transfer.pCalibrateTwistBoneAxisRotation
	end
	
	
	
	/** Target bone name. */
	public func String getTargetBone()
		return pTargetBone
	end
	
	/** Set target bone name. */
	public func void setTargetBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBone = bone
	end
	
	/** Tip bone name. */
	public func String getTipBone()
		return pTipBone
	end
	
	/** Set tip bone name. */
	public func void setTipBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTipBone = bone
	end
	
	/** Base bone name. */
	public func String getBaseBone()
		return pBaseBone
	end
	
	/** Set base bone name. */
	public func void setBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pBaseBone = bone
	end
	
	/** Target tracker. */
	public func MotionTransferTracker getTargetTracker()
		return pTargetTracker
	end
	
	/** Base tracker. */
	public func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Scale rotation. */
	public func Vector2 getScaleRotation()
		return pScaleRotation
	end
	
	/** Set scale rotation. */
	public func void setScaleRotation(Vector2 scale)
		if scale == null
			throw ENullPointer.new("scale")
		end
		pScaleRotation = scale
	end
	
	/** Percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func float getTwistPropagation()
		return pTwistPropagation
	end
	
	/** Set percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func void setTwistPropagation(float amount)
		pTwistPropagation = DEMath.max(amount, 0.0)
	end
	
	/** Count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func int getTwistBoneCount()
		return pTwistBoneCount
	end
	
	/** Set count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func void setTwistBoneCount(int count)
		if count < 0
			throw EInvalidParam.new("count < 0")
		end
		pTwistBoneCount = count
	end
	
	/** Rotation of twist axis relative to tip bone. */
	public func Vector getTwistAxisRotation()
		return pTwistAxisRotation
	end
	
	/** Set rotation of twist axis relative to tip bone. */
	public func void setTwistAxisRotation(Vector rotation)
		if rotation == null
			throw ENullPointer.new("rotation")
		end
		pTwistAxisRotation = rotation
	end
	
	
	
	/** Calibrate zero rotation. */
	public func Vector2 getCalibrateZeroRotation()
		return pCalibrateZeroRotation
	end
	
	/** Calibrate twist rotation. */
	public func Vector getCalibrateTwistRotation()
		return pCalibrateTwistRotation
	end
	
	/** Calibrate twist bone axis rotation. */
	public func Vector getCalibrateTwistBoneAxisRotation()
		return pCalibrateTwistBoneAxisRotation
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass)
		pADControllerBendX = null
		pADControllerBendY = null
		pADControllerTwist = null
		
		// add behavior
		var ECBMotionTransferBend behavior = ECBMotionTransferBend.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTarget, slotBase
		if not pTargetTracker.getSlot().empty()
			slotTarget = config.getTrackerSlots().getNamed(pTargetTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotBase = config.getTrackerSlots().getNamed(pBaseTracker.getSlot())
		end
		
		if slotTarget == null or slotBase == null or pCalibrateBones.getCount() == 0 \
		or pBaseBone.empty() or pTipBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		var String rootBone = pCalibrateBones.getAt(-1) cast String
		
		var float fullRotation = 180
		var float rotationStep = fullRotation / pCalibrateBones.getCount()
		
		pADControllerBendX = ADController.new()
		pADControllerBendX.setName(behavior.getControllerNameBendX())
		pADControllerBendX.setMinimum(-fullRotation)
		pADControllerBendX.setMaximum(fullRotation)
		adef.addController(pADControllerBendX)
		
		pADControllerBendY = ADController.new()
		pADControllerBendY.setName(behavior.getControllerNameBendY())
		pADControllerBendY.setMinimum(-fullRotation)
		pADControllerBendY.setMaximum(fullRotation)
		adef.addController(pADControllerBendY)
		
		var ADLink linkBendX = ADLink.new()
		linkBendX.setController(pADControllerBendX)
		adef.addLink(linkBendX)
		
		var ADLink linkBendY = ADLink.new()
		linkBendY.setController(pADControllerBendY)
		adef.addLink(linkBendY)
		
		var int i, count, baseIndex
		
		// bending
		count = pCalibrateBones.getCount()
		var String nameBendX = getName() + ".bendX"
		var String nameBendY = getName() + ".bendY"
		baseIndex = count - 1
		
		for i = 0 to count
			var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
			var ADRuleBoneTransformator rule
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(nameBendX)
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
			rule.setUseAxis(true)
			rule.setAxis(pCalibrateBendAxesX.getAt(i) cast Vector)
			rule.setMinimumAngle(-rotationStep)
			rule.setMaximumAngle(rotationStep)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkBendX))
			rule.addBone(bone)
			adef.addRule(rule)
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(nameBendY)
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
			rule.setUseAxis(true)
			rule.setAxis(pCalibrateBendAxesY.getAt(i) cast Vector)
			rule.setMinimumAngle(-rotationStep)
			rule.setMaximumAngle(rotationStep)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkBendY))
			rule.addBone(bone)
			adef.addRule(rule)
		end
		
		// twist
		if pTwistBoneCount > 0 and pTwistPropagation > 0.01
			count = DEMath.min(pTwistBoneCount, pCalibrateBones.getCount())
			var ADRuleBoneTransformator rule
			var String name = getName() + ".twist"
			var float maxAngle = 180
			
			pADControllerTwist = ADController.new()
			pADControllerTwist.setName(behavior.getControllerNameTwist())
			pADControllerTwist.setMinimum(-maxAngle)
			pADControllerTwist.setMaximum(maxAngle)
			adef.addController(pADControllerTwist)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerTwist)
			adef.addLink(link)
			
			var float angle = pTwistPropagation * maxAngle / count
			baseIndex = count - 1
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var Vector axis = pCalibrateTwistAxes.getAt(i) cast Vector
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(-angle)
				rule.setMaximumAngle(angle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
				rule.addBone(bone)
				adef.addRule(rule)
			end
		end
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
		end
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pCalibrateBones.removeAll()
		pTargetTracker.resetTransform()
		pBaseTracker.resetTransform()
		pCalibrateZeroRotation = Vector2.new()
		pCalibrateBendAxesX.removeAll()
		pCalibrateBendAxesY.removeAll()
		pCalibrateTwistRotation = Vector.new()
		pCalibrateTwistAxes.removeAll()
		pCalibrateTwistBoneAxisRotation = Vector.new()
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		findBoneChain(component.getRig(), pTipBone, pBaseBone, pCalibrateBones)
		
		pTargetTracker.resolveRealSlot(config)
		pTargetTracker.setTransform(component, pTargetBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(component, pBaseBone)
		
		// calibrate zero rotation
		pCalibrateZeroRotation = Vector2.new()
		
		var int indexBase = -1, indexTarget = -1, indexTip = -1
		if not pBaseBone.empty()
			indexBase = component.indexOfBoneNamed(pBaseBone)
			if not pTargetBone.empty()
				indexTarget = component.indexOfBoneNamed(pTargetBone)
			end
			indexTip = component.indexOfBoneNamed(pTipBone)
		end
		
		if indexBase != -1 and indexTip != -1
			var Matrix baseMatrix = Matrix.newRT(pBaseTracker.getOffsetRotation(), \
				pBaseTracker.getOffsetPosition()) * component.boneGetMatrix(indexBase)
			
			var Matrix targetMatrix = Matrix.newRT(pTargetTracker.getOffsetRotation(), \
				pTargetTracker.getOffsetPosition())
			
			if indexTarget != -1
				targetMatrix = targetMatrix * component.boneGetMatrix(indexTarget)
				
			elif pTargetTracker.getRealSlot() != null
				targetMatrix = targetMatrix * pTargetTracker.getRealSlot().getTargetMatrix()
			end
			
			var Vector position = (targetMatrix * baseMatrix.getInverse()).getPosition()
			
			pCalibrateZeroRotation = Vector2.new(\
				DEMath.atan2(position.getY(), position.getZ()),\
				-DEMath.atan2(position.getX(), position.getZ()))
			
			// bend axes
			var Vector axisX = baseMatrix.getRightVector()
			var Vector axisY = baseMatrix.getUpVector()
			var int count = pCalibrateBones.getCount()
			var int i, baseIndex = count - 1
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				
				if indexBone != -1
					var Matrix boneMatrix = component.boneGetInverseMatrix(indexBone)
					pCalibrateBendAxesX.add(boneMatrix.transformNormal(axisX))
					pCalibrateBendAxesY.add(boneMatrix.transformNormal(axisY))
					
				else
					pCalibrateBendAxesX.add(Vector.new(1, 0, 0))
					pCalibrateBendAxesY.add(Vector.new(0, 0, 1))
				end
			end
			
			// twist rotation. the rotation angle is unimportant since we only examine relative rotation
			var Matrix twistTransform = (baseMatrix * targetMatrix.getInverse()).normalize()
			var Vector twistAxis = twistTransform.getViewVector()
			var Vector twistUp = twistTransform.getUpVector()
			
			pCalibrateTwistRotation = Matrix.newVU(twistAxis, twistUp).getInverse().getEulerAngles()
			
		else
			pCalibrateTwistRotation = Vector.new()
		end
		
		// calculate twist axes
		if pTwistBoneCount > 0 and pTwistPropagation > 0.01
			var int count = DEMath.min(pTwistBoneCount, pCalibrateBones.getCount())
			var Vector axis = Matrix.newRotation(pTwistAxisRotation).getViewVector()
			var int i, baseIndex = count - 1
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				if indexBone != -1
					pCalibrateTwistAxes.add(component.boneGetInverseMatrix(indexBone).transformNormal(axis))
					
				else
					pCalibrateTwistAxes.add(Vector.new(0, 0, 1))
				end
			end
			
			if indexTarget != -1
				pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pTwistAxisRotation) \
					* component.boneGetInverseMatrix(indexTarget)).getEulerAngles()
				
			elif pTargetTracker.getRealSlot() != null
				pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pTwistAxisRotation) \
					* pTargetTracker.getRealSlot().getTargetMatrix().getInverse()).getEulerAngles()
			end
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferBend.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("targetBone")
				setTargetBone(element.getFirstCData())
				
			elif tagName.equals("tipBone")
				setTipBone(element.getFirstCData())
				
			elif tagName.equals("baseBone")
				setBaseBone(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("scaleRotation")
				setScaleRotation(loader.readVector2(element))
				
			elif tagName.equals("twistPropagation")
				setTwistPropagation(element.getFirstCDataFloat())
				
			elif tagName.equals("twistBoneCount")
				setTwistBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("twistAxisRotation")
				setTwistAxisRotation(loader.readVector(element))
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	public func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("calibrateZeroRotation")
				pCalibrateZeroRotation = loader.readVector2(element)
				
			elif tagName.equals("bendAxisX")
				pCalibrateBendAxesX.add(loader.readVector(element))
				
			elif tagName.equals("bendAxisY")
				pCalibrateBendAxesY.add(loader.readVector(element))
				
			elif tagName.equals("twistRotation")
				pCalibrateTwistRotation = loader.readVector(element)
				
			elif tagName.equals("twistAxis")
				pCalibrateTwistAxes.add(loader.readVector(element))
				
			elif tagName.equals("twistBoneAxisRotation")
				pCalibrateTwistBoneAxisRotation = loader.readVector(element)
			end
		end)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("targetBone", pTargetBone)
		tag.addDataTag("tipBone", pTipBone)
		tag.addDataTag("baseBone", pBaseBone)
		pTargetTracker.save(loader, tag.addTag("targetTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		loader.writeVector2(tag, "scaleRotation", pScaleRotation)
		tag.addDataTag("twistPropagation", pTwistPropagation)
		tag.addDataTag("twistBoneCount", pTwistBoneCount)
		loader.writeVector(tag, "twistAxisRotation", pTwistAxisRotation)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	public func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTargetTracker.saveCalibrated(loader, tag.addTag("targetTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("baseTracker"))
		loader.writeVector2(tag, "calibrateZeroRotation", pCalibrateZeroRotation)
		pCalibrateBendAxesX.forEach(block Vector each
			loader.writeVector(tag, "bendAxisX", each)
		end)
		pCalibrateBendAxesY.forEach(block Vector each
			loader.writeVector(tag, "bendAxisY", each)
		end)
		loader.writeVector(tag, "twistRotation", pCalibrateTwistRotation)
		pCalibrateTwistAxes.forEach(block Vector each
			loader.writeVector(tag, "twistAxis", each)
		end)
		loader.writeVector(tag, "twistBoneAxisRotation", pCalibrateTwistBoneAxisRotation)
	end
end
