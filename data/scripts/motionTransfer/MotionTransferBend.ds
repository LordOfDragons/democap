/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer rotating bone chain.
 * 
 * Defines root bone and target bone name. This defines the bone chain to manipulate.
 * The target bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 1 or more bones.
 * 
 * Defines two tracker slots to be used to get rotation from. The target tracker
 * position is transformed into the base tracker. The base bone indicates the bone
 * coordinate system to link to the base tracker. This defines the base coordinate
 * system in which the position of the target tracker is converted to a rotation
 * along each axis. This rotation is split across all bones in the chain. The amount
 * of transfered rotation can be scaled.
 */
class MotionTransferBend extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "bend"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferBend.new(factoryID())
		end
		
		public func String displayName()
			return "Bend Bone Chain"
		end
	end
	
	
	
	private var String pTargetBone
	private var String pTargetBaseBone
	private var String pTipBone
	private var String pBaseBone
	private var MotionTransferTracker pTargetTracker
	private var MotionTransferTracker pBaseTracker
	private var Vector2 pScaleRotation
	private var float pBendShape
	private var bool pFitCurveToTarget
	private var bool pUseRotation
	private var float pTwistPropagation
	private var float pTwistScale
	private var int pTwistBoneCount
	private var Vector pBendAxisRotation
	
	private var ADController pADControllerBendX
	private var ADController pADControllerBendY
	private var ADController pADControllerTwist
	
	private var Array pCalibrateBones
	private var Matrix pCalibrateBendAxisMatrix
	private var Vector pCalibrateZeroRotation
	private var Array pCalibrateBendAxesX
	private var Array pCalibrateBendAxesY
	private var Array pCalibrateBendWeights
	private var CurveBezier pCalibrateBendCurveX
	private var CurveBezier pCalibrateBendCurveY
	private var Array pCalibrateTwistAxes
	private var Vector pCalibrateTwistBoneAxisRotation
	private var Matrix pCalibrateTwistTransform
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTargetBone = ""
		pTargetBaseBone = ""
		pTipBone = ""
		pBaseBone = ""
		pTargetTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pScaleRotation = Vector2.new(1, 1)
		pBendShape = 0.5
		pFitCurveToTarget = false
		pUseRotation = false
		pTwistPropagation = 0
		pTwistScale = 1
		pTwistBoneCount = 0
		pBendAxisRotation = Vector.new()
		pCalibrateBones = Array.new()
		pCalibrateBendAxisMatrix = Matrix.new()
		pCalibrateZeroRotation = Vector.new()
		pCalibrateBendAxesX = Array.new()
		pCalibrateBendAxesY = Array.new()
		pCalibrateBendWeights = Array.new()
		pCalibrateBendCurveX = CurveBezier.newDefaultLinear()
		pCalibrateBendCurveY = CurveBezier.newDefaultLinear()
		pCalibrateTwistAxes = Array.new()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateTwistTransform = Matrix.new()
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferBend transfer) super(transfer)
		pTargetBone = transfer.pTargetBone
		pTargetBaseBone = transfer.pTargetBaseBone
		pTipBone = transfer.pTipBone
		pBaseBone = transfer.pBaseBone
		pTargetTracker = MotionTransferTracker.new(transfer.pTargetTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pScaleRotation = transfer.pScaleRotation
		pBendShape = transfer.pBendShape
		pFitCurveToTarget = transfer.pFitCurveToTarget
		pUseRotation = transfer.pUseRotation
		pTwistPropagation = transfer.pTwistPropagation
		pTwistScale = transfer.pTwistScale
		pTwistBoneCount = transfer.pTwistBoneCount
		pBendAxisRotation = transfer.pBendAxisRotation
		pCalibrateBones = Array.new(transfer.pCalibrateBones)
		pCalibrateBendAxisMatrix = transfer.pCalibrateBendAxisMatrix
		pCalibrateZeroRotation = transfer.pCalibrateZeroRotation
		pCalibrateBendAxesX = Array.new(transfer.pCalibrateBendAxesX)
		pCalibrateBendAxesY = Array.new(transfer.pCalibrateBendAxesY)
		pCalibrateBendWeights = Array.new(transfer.pCalibrateBendWeights)
		pCalibrateBendCurveX = CurveBezier.new(transfer.pCalibrateBendCurveX)
		pCalibrateBendCurveY = CurveBezier.new(transfer.pCalibrateBendCurveY)
		pCalibrateTwistAxes = Array.new(transfer.pCalibrateTwistAxes)
		pCalibrateTwistBoneAxisRotation = transfer.pCalibrateTwistBoneAxisRotation
		pCalibrateTwistTransform = transfer.pCalibrateTwistTransform
	end
	
	
	
	/** Target bone name. */
	public func String getTargetBone()
		return pTargetBone
	end
	
	/** Set target bone name. */
	public func void setTargetBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBone = bone
	end
	
	/** Target base bone name. */
	public func String getTargetBaseBone()
		return pTargetBaseBone
	end
	
	/** Set target base bone name. */
	public func void setTargetBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBaseBone = bone
	end
	
	/** Tip bone name. */
	public func String getTipBone()
		return pTipBone
	end
	
	/** Set tip bone name. */
	public func void setTipBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTipBone = bone
	end
	
	/** Base bone name. */
	public func String getBaseBone()
		return pBaseBone
	end
	
	/** Set base bone name. */
	public func void setBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pBaseBone = bone
	end
	
	/** Target tracker. */
	public func MotionTransferTracker getTargetTracker()
		return pTargetTracker
	end
	
	/** Base tracker. */
	public func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Scale rotation. */
	public func Vector2 getScaleRotation()
		return pScaleRotation
	end
	
	/** Set scale rotation. */
	public func void setScaleRotation(Vector2 scale)
		if scale == null
			throw ENullPointer.new("scale")
		end
		pScaleRotation = scale
	end
	
	/**
	 * Bend shape in the range from 0 to 1. 0 bends only at the base bone. 1 bends only at the
	 * tip bone. 0.5 bends all bones equally. Values in between gradually blend between.
	 */
	public func float getBendShape()
		return pBendShape
	end
	
	/**
	 * Set bend shape in the range from 0 to 1. 0 bends only at the base bone. 1 bends only at the
	 * tip bone. 0.5 bends all bones equally. Values in between gradually blend between.
	 */
	public func void setBendShape(float shape)
		pBendShape = DEMath.clamp(shape, 0.0, 1.0)
	end
	
	/**
	 * Fit curve to target. If true calculates the bending angle required for the curve to touch
	 * the target position. Use this only if the target position is located or beyond the curve
	 * end point otherwise wrong results are calculated.
	 */
	public func bool getFitCurveToTarget()
		return pFitCurveToTarget
	end
	
	/**
	 * Set to fit curve to target. If true calculates the bending angle required for the curve
	 * to touch the target position. Use this only if the target position is located or beyond
	 * the curve end point otherwise wrong results are calculated.
	 */
	public func void setFitCurveToTarget(bool fitCurveToTarget)
		pFitCurveToTarget = fitCurveToTarget
	end
	
	/** Use rotation of target relative to base instead of position to calculate bending angle. */
	public func bool getUseRotation()
		return pUseRotation
	end
	
	/** Use rotation of target relative to base instead of position to calculate bending angle. */
	public func void setUseRotation(bool useRotation)
		pUseRotation = useRotation
	end
	
	/** Percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func float getTwistPropagation()
		return pTwistPropagation
	end
	
	/** Set percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func void setTwistPropagation(float amount)
		pTwistPropagation = DEMath.max(amount, 0.0)
	end
	
	/** Scaling of twist angle before application. */
	public func float getTwistScale()
		return pTwistScale
	end
	
	/** Set scaling of twist angle before application. */
	public func void setTwistScale(float scale)
		pTwistScale = scale
	end
	
	/** Count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func int getTwistBoneCount()
		return pTwistBoneCount
	end
	
	/** Set count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func void setTwistBoneCount(int count)
		if count < 0
			throw EInvalidParam.new("count < 0")
		end
		pTwistBoneCount = count
	end
	
	/** Rotation of bend axis in component space. */
	public func Vector getBendAxisRotation()
		return pBendAxisRotation
	end
	
	/** Set rotation of bend axis in component space. */
	public func void setBendAxisRotation(Vector rotation)
		if rotation == null
			throw ENullPointer.new("rotation")
		end
		pBendAxisRotation = rotation
	end
	
	
	
	/** Calibrate bend axis matrix (inverse bend axis matrix in base matrix). */
	public func Matrix getCalibrateBendAxisMatrix()
		return pCalibrateBendAxisMatrix
	end
	
	/** Calibrate zero rotation. */
	public func Vector getCalibrateZeroRotation()
		return pCalibrateZeroRotation
	end
	
	/** Calibrate twist bone axis rotation. */
	public func Vector getCalibrateTwistBoneAxisRotation()
		return pCalibrateTwistBoneAxisRotation
	end
	
	/** Calibrate twist transform. */
	public func Matrix getCalibrateTwistTransform()
		return pCalibrateTwistTransform
	end
	
	/** Calibrate bend curve in X direction. */
	public func CurveBezier getCalibrateBendCurveX()
		return pCalibrateBendCurveX
	end
	
	/** Calibrate bend curve in Y direction. */
	public func CurveBezier getCalibrateBendCurveY()
		return pCalibrateBendCurveY
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass, ModifiedRig modifyRig)
		pADControllerBendX = null
		pADControllerBendY = null
		pADControllerTwist = null
		
		// add behavior
		var ECBMotionTransferBend behavior = ECBMotionTransferBend.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTarget, slotBase
		if not pTargetTracker.getSlot().empty()
			slotTarget = config.getTrackerSlots().getNamed(pTargetTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotBase = config.getTrackerSlots().getNamed(pBaseTracker.getSlot())
		end
		
		if slotTarget == null or slotBase == null or pCalibrateBones.getCount() == 0 \
		or pBaseBone.empty() or pTipBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		var String rootBone = pCalibrateBones.getAt(-1) cast String
		var float fullRotation = 180
		
		pADControllerBendX = ADController.new()
		pADControllerBendX.setName(behavior.getControllerNameBendX())
		pADControllerBendX.setMinimum(-fullRotation)
		pADControllerBendX.setMaximum(fullRotation)
		adef.addController(pADControllerBendX)
		
		pADControllerBendY = ADController.new()
		pADControllerBendY.setName(behavior.getControllerNameBendY())
		pADControllerBendY.setMinimum(-fullRotation)
		pADControllerBendY.setMaximum(fullRotation)
		adef.addController(pADControllerBendY)
		
		var ADLink linkBendX = ADLink.new()
		linkBendX.setController(pADControllerBendX)
		adef.addLink(linkBendX)
		
		var ADLink linkBendY = ADLink.new()
		linkBendY.setController(pADControllerBendY)
		adef.addLink(linkBendY)
		
		var int i, count, baseIndex
		
		// bending
		count = pCalibrateBones.getCount()
		var String nameBendX = getName() + ".bendX"
		var String nameBendY = getName() + ".bendY"
		baseIndex = count - 1
		
		for i = 0 to count
			var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
			var float weight = pCalibrateBendWeights.getAt(baseIndex - i) cast float
			var float boneRotation = fullRotation * weight
			var ADRuleBoneTransformator rule
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(nameBendX)
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
			rule.setUseAxis(true)
			rule.setAxis(pCalibrateBendAxesX.getAt(i) cast Vector)
			rule.setMinimumAngle(-boneRotation)
			rule.setMaximumAngle(boneRotation)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkBendX))
			rule.addBone(bone)
			adef.addRule(rule)
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(nameBendY)
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
			rule.setUseAxis(true)
			rule.setAxis(pCalibrateBendAxesY.getAt(i) cast Vector)
			rule.setMinimumAngle(-boneRotation)
			rule.setMaximumAngle(boneRotation)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkBendY))
			rule.addBone(bone)
			adef.addRule(rule)
		end
		
		// twist
		count = DEMath.min(DEMath.max(pTwistBoneCount, 1), pCalibrateBones.getCount())
		var ADRuleBoneTransformator rule
		var String name = getName() + ".twist"
		var float maxAngle = 180
		
		pADControllerTwist = ADController.new()
		pADControllerTwist.setName(behavior.getControllerNameTwist())
		pADControllerTwist.setMinimum(-maxAngle)
		pADControllerTwist.setMaximum(maxAngle)
		adef.addController(pADControllerTwist)
		
		var ADLink link = ADLink.new()
		link.setController(pADControllerTwist)
		adef.addLink(link)
		
		var float angle = pTwistPropagation * maxAngle / count
		if pTwistPropagation <= 0.01
			angle = 0
		end
		
		var float tipAngle = maxAngle - angle * ( count - 1 )
		
		baseIndex = count - 1
		
		for i = 0 to count
			if i > 0 and pTwistPropagation <= 0.01
				continue
			end
			
			var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
			var Vector axis = pCalibrateTwistAxes.getAt(i) cast Vector
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(name)
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
			rule.setUseAxis(true)
			rule.setAxis(axis)
			
			if i > 0
				rule.setMinimumAngle(-angle)
				rule.setMaximumAngle(angle)
				
			else
				rule.setMinimumAngle(-tipAngle)
				rule.setMaximumAngle(tipAngle)
			end
			
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
			rule.addBone(bone)
			adef.addRule(rule)
		end
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
		end
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pCalibrateBones.removeAll()
		pTargetTracker.resetTransform()
		pBaseTracker.resetTransform()
		pCalibrateBendAxisMatrix = Matrix.new()
		pCalibrateZeroRotation = Vector.new()
		pCalibrateBendAxesX.removeAll()
		pCalibrateBendAxesY.removeAll()
		pCalibrateBendWeights.removeAll()
		pCalibrateBendCurveX.removeAllPoints()
		pCalibrateBendCurveY.removeAllPoints()
		pCalibrateTwistAxes.removeAll()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateTwistTransform = Matrix.new()
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		findBoneChain(component.getRig(), pTipBone, pBaseBone, pCalibrateBones)
		
		if pCalibrateBones.getCount() == 0
			return
		end
		
		pTargetTracker.resolveRealSlot(config)
		pTargetTracker.setTransform(component, pTargetBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(component, pTargetBaseBone)
		
		// calibrate zero rotation
		pCalibrateZeroRotation = Vector.new()
		
		var int indexBase = -1, indexTarget = -1, indexTip = -1
		if not pBaseBone.empty()
			indexBase = component.indexOfBoneNamed(pBaseBone)
			if not pTargetBone.empty()
				indexTarget = component.indexOfBoneNamed(pTargetBone)
			end
			indexTip = component.indexOfBoneNamed(pTipBone)
		end
		
		var Matrix baseMatrix = pBaseTracker.getTransformMatrix()
		if pBaseTracker.getRealSlot() != null
			baseMatrix = baseMatrix * pBaseTracker.getRealSlot().getCalibrateMatrix()
		end
		
		var Matrix targetMatrix = pTargetTracker.getTransformMatrix()
		if pTargetTracker.getRealSlot() != null
			targetMatrix = targetMatrix * pTargetTracker.getRealSlot().getCalibrateMatrix()
		end
		
		var Matrix bendAxisMatrix = Matrix.newRotation(pBendAxisRotation)
		var Matrix baseMatrixInv = baseMatrix.getInverse()
		pCalibrateBendAxisMatrix = (bendAxisMatrix * baseMatrixInv.getRotation()).getInverse()
		
		if indexBase != -1 and indexTip != -1
			// zero rotation
			var Matrix bendMatrix = targetMatrix * baseMatrixInv * pCalibrateBendAxisMatrix
			var Vector position = bendMatrix.getPosition()
			
			if pUseRotation
				var int indexBone = component.indexOfBoneNamed(pTipBone)
				if indexBone == -1
					return
				end
				
// 				pCalibrateZeroRotation = (bendAxisMatrix\
// 					* component.boneGetInverseMatrix(indexBone).getRotation()).getEulerAngles()
				pCalibrateZeroRotation = (bendAxisMatrix\
					* targetMatrix.normalize().getRotation().getInverse()).getEulerAngles()
				
			else
				pCalibrateZeroRotation = Vector.new(\
					DEMath.atan2(position.getY(), position.getZ()),\
					-DEMath.atan2(position.getX(), position.getZ()), 0)
			end
			
			// bend axes
			var Vector axisX = bendAxisMatrix.getRightVector()
			var Vector axisY = bendAxisMatrix.getUpVector()
			var int count = pCalibrateBones.getCount()
			var int i, baseIndex = count - 1
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				
				if indexBone != -1
					var Matrix boneMatrix = component.boneGetInverseMatrix(indexBone)
					pCalibrateBendAxesX.add(boneMatrix.transformNormal(axisX))
					pCalibrateBendAxesY.add(boneMatrix.transformNormal(axisY))
					
				else
					pCalibrateBendAxesX.add(Vector.new(1, 0, 0))
					pCalibrateBendAxesY.add(Vector.new(0, 1, 0))
				end
			end
			
			// zero rotation
			
			// bend weights
			pCalibrateBendWeights.removeAll()
			
			var Array curveOffset = Array.newWith(0.0)
			var float curveLength = 0
			
			for i = count - 1 downto 1
				var String bone1 = pCalibrateBones.getAt(i - 1) cast String
				var int indexBone1 = component.indexOfBoneNamed(bone1)
				if indexBone1 == -1
					curveOffset.add(curveLength)
					continue
				end
				
				var String bone2 = pCalibrateBones.getAt(i) cast String
				var int indexBone2 = component.indexOfBoneNamed(bone2)
				if indexBone2 == -1
					curveOffset.add(curveLength)
					continue
				end
				
				var Vector position1 = component.boneGetMatrix(indexBone1).getPosition()
				var Vector position2 = component.boneGetMatrix(indexBone2).getPosition()
				
				curveLength += (position2 - position1).getLength()
				curveOffset.add(curveLength)
			end
			
			curveLength = DEMath.max(curveLength, 0.01) // avoid div by zero
			
			var Array weights = curveOffset.map(block float each
				return calcBendWeight(pBendShape, each / curveLength)
			end)
			
			var float sumWeights = weights.inject(0.0, block float accum, float each
				return accum + each
			end) cast float
			
			weights.forEachReverse(block float each
				pCalibrateBendWeights.add(each / sumWeights)
			end)
			
			// bend target rotations. we need to calculate this using an endpoint on the curve
			if pFitCurveToTarget
				var int bendTargetResolution = 13 // 12 segments
				var float bendRotationStep = 180.0 / pCalibrateBones.getCount()
				var Array bendTargetX = Array.new(bendTargetResolution, position)
				var Array bendTargetY = Array.new(bendTargetResolution, position)
				var Array bendRotation = Array.new()
				var Matrix bendMatrix
				var int j
				
				for i = 0 to bendTargetResolution
					bendRotation.add(DEMath.linearStep(i, 0, bendTargetResolution - 1, -180, 180))
				end
				
				for i = 0 to count
					var String bone = pCalibrateBones.getAt(i) cast String
					var int indexBone = component.indexOfBoneNamed(bone)
					if indexBone == -1
						continue
					end
					
					var Vector bonePosition = (component.boneGetMatrix(indexBone)\
						* baseMatrixInv * pCalibrateBendAxisMatrix).getPosition()
					var Matrix boneMatrix1 = Matrix.newTranslation(-bonePosition)
					var Matrix boneMatrix2 = Matrix.newTranslation(bonePosition)
					var float rotationWeight = pCalibrateBendWeights.getAt(i) cast float
					
					for j = 0 to bendTargetResolution
						var float rotation = rotationWeight * bendRotation.getAt(j) cast float
						
						bendMatrix = boneMatrix1 * Matrix.newRotationX(rotation) * boneMatrix2
						bendTargetX.setAt(j, bendMatrix * bendTargetX.getAt(j) cast Vector)
						
						bendMatrix = boneMatrix1 * Matrix.newRotationY(rotation) * boneMatrix2
						bendTargetY.setAt(j, bendMatrix * bendTargetY.getAt(j) cast Vector)
					end
				end
				
				pCalibrateBendCurveX.removeAllPoints()
				pCalibrateBendCurveY.removeAllPoints()
				
				var Matrix matrixZeroRotX = Matrix.newRotationX(-pCalibrateZeroRotation.getX())
				var Matrix matrixZeroRotY = Matrix.newRotationY(-pCalibrateZeroRotation.getY())
				
				for i = 0 to bendTargetResolution
					var float rotation = bendRotation.getAt(i) cast float
				
					var Vector target = matrixZeroRotX * bendTargetX.getAt(i) cast Vector
					pCalibrateBendCurveX.addPoint(DEMath.atan2(target.getY(), target.getZ()), rotation)
					
					target = matrixZeroRotY * bendTargetY.getAt(i) cast Vector
					pCalibrateBendCurveY.addPoint(-DEMath.atan2(target.getX(), target.getZ()), rotation)
				end
				
			else
				pCalibrateBendCurveX.removeAllPoints()
				pCalibrateBendCurveX.addPoint(-180, -180)
				pCalibrateBendCurveX.addPoint(180, 180)
				
				pCalibrateBendCurveY.removeAllPoints()
				pCalibrateBendCurveY.addPoint(-180, -180)
				pCalibrateBendCurveY.addPoint(180, 180)
			end
		end
		
		// calculate twist axes
		var int count = DEMath.min(DEMath.max(pTwistBoneCount, 1), pCalibrateBones.getCount())
		var Vector axis = Matrix.newRotation(pBendAxisRotation).getViewVector()
		var int i, baseIndex = count - 1
		
		for i = 0 to count
			var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
			var int indexBone = component.indexOfBoneNamed(bone)
			if indexBone != -1
				pCalibrateTwistAxes.add(component.boneGetInverseMatrix(indexBone).transformNormal(axis))
				
			else
				pCalibrateTwistAxes.add(Vector.new(0, 0, 1))
			end
		end
		
		var Matrix invTargetMat
		
		if indexTarget != -1
			invTargetMat = component.boneGetInverseMatrix(indexTarget)
			
		elif pTargetTracker.getRealSlot() != null and pBaseTracker.getRealSlot() != null
			invTargetMat = targetMatrix.getInverse()
		end
		
		if invTargetMat != null
			pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pBendAxisRotation)\
				* invTargetMat.normalize().getRotation()).getEulerAngles()
		end
		
		// (target * base^-1)^-1 => base * target^-1
		pCalibrateTwistTransform = baseMatrix * targetMatrix.getInverse()
	end
	
	/** Calculate bend weight. */
	public func float calcBendWeight(float shape, float offset)
		// the bend curve is calculate as a piecewise linear curve with 4 segments using
		// these connection curves at shape value 0, 0.25, 0.5, 0.75 and 1:
		// |..     ../     ---     \..    ..|
		// |..  ,  ./.  ,  ...  ,  .\.  , ..|
		// |..     /..     ...     ..\    ..|
		// 
		// hence at 0 value the base bone has full weight, at 1 value the tip bone has full
		// weight and at 0.5 all bones have equal weight. the values in between are blends
		// moving between these 3 state
		
		// value 0 and 1 can result in division by zero in on of the cases below hence clamped
		shape = DEMath.min(DEMath.max(shape, 0.01), 0.99)
		
		if shape < 0.25
			return DEMath.max(1.0 - offset * 0.25 / shape, 0.0)
			
		elif shape < 0.5
			return 1.0 - offset * ((0.5 - shape) / 0.25)
			
		elif shape < 0.75
			return 1.0 - (1.0 - offset) * ((shape - 0.5) / 0.25)
			
		else
			return DEMath.max(1.0 - ((1.0 - offset) * 0.25) / (1.0 - shape), 0.0)
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferBend.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("targetBone")
				setTargetBone(element.getFirstCData())
				
			elif tagName.equals("targetBaseBone")
				setTargetBaseBone(element.getFirstCData())
				
			elif tagName.equals("tipBone")
				setTipBone(element.getFirstCData())
				
			elif tagName.equals("baseBone")
				setBaseBone(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("scaleRotation")
				setScaleRotation(loader.readVector2(element))
				
			elif tagName.equals("bendShape")
				setBendShape(element.getFirstCDataFloat())
				
			elif tagName.equals("fitCurveToTarget")
				setFitCurveToTarget(element.getFirstCDataBool())
				
			elif tagName.equals("useRotation")
				setUseRotation(element.getFirstCDataBool())
				
			elif tagName.equals("twistPropagation")
				setTwistPropagation(element.getFirstCDataFloat())
				
			elif tagName.equals("twistScale")
				setTwistScale(element.getFirstCDataFloat())
				
			elif tagName.equals("twistBoneCount")
				setTwistBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("bendAxisRotation")
				setBendAxisRotation(loader.readVector(element))
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	public func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("bendAxisMatrix")
				pCalibrateBendAxisMatrix = GameApp.getGameApp().getLoadCharacterProfile().readMatrix(element)
				
			elif tagName.equals("zeroRotation")
				pCalibrateZeroRotation = loader.readVector(element)
				
			elif tagName.equals("bendAxisX")
				pCalibrateBendAxesX.add(loader.readVector(element))
				
			elif tagName.equals("bendAxisY")
				pCalibrateBendAxesY.add(loader.readVector(element))
				
			elif tagName.equals("bendWeight")
				pCalibrateBendWeights.add(element.getFirstCDataFloat())
				
			elif tagName.equals("bendCurveX")
				pCalibrateBendCurveX = loader.readCurveBezier(element)
				
			elif tagName.equals("bendCurveY")
				pCalibrateBendCurveY = loader.readCurveBezier(element)
				
			elif tagName.equals("twistAxis")
				pCalibrateTwistAxes.add(loader.readVector(element))
				
			elif tagName.equals("twistBoneAxisRotation")
				pCalibrateTwistBoneAxisRotation = loader.readVector(element)
				
			elif tagName.equals("twistTransform")
				pCalibrateTwistTransform = GameApp.getGameApp().getLoadCharacterProfile().readMatrix(element)
			end
		end)
	end
	
	/** Post load initialize. */
	public func void postLoadInit(CharacterConfiguration config)
		pTargetTracker.resolveRealSlot(config)
		pBaseTracker.resolveRealSlot(config)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("targetBone", pTargetBone)
		tag.addDataTag("targetBaseBone", pTargetBaseBone)
		tag.addDataTag("tipBone", pTipBone)
		tag.addDataTag("baseBone", pBaseBone)
		pTargetTracker.save(loader, tag.addTag("targetTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		loader.writeVector2(tag, "scaleRotation", pScaleRotation)
		tag.addDataTag("bendShape", pBendShape)
		tag.addDataTag("fitCurveToTarget", pFitCurveToTarget)
		tag.addDataTag("useRotation", pUseRotation)
		tag.addDataTag("twistPropagation", pTwistPropagation)
		tag.addDataTag("twistScale", pTwistScale)
		tag.addDataTag("twistBoneCount", pTwistBoneCount)
		loader.writeVector(tag, "bendAxisRotation", pBendAxisRotation)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	public func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		var LoadCharacterProfile lcp = GameApp.getGameApp().getLoadCharacterProfile()
		
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTargetTracker.saveCalibrated(loader, tag.addTag("targetTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("baseTracker"))
		lcp.writeMatrix(tag, "bendAxisMatrix", pCalibrateBendAxisMatrix)
		loader.writeVector(tag, "zeroRotation", pCalibrateZeroRotation)
		pCalibrateBendAxesX.forEach(block Vector each
			loader.writeVector(tag, "bendAxisX", each)
		end)
		pCalibrateBendAxesY.forEach(block Vector each
			loader.writeVector(tag, "bendAxisY", each)
		end)
		pCalibrateBendWeights.forEach(block float each
			tag.addDataTag("bendWeight", each)
		end)
		loader.writeCurveBezier(tag, "bendCurveX", pCalibrateBendCurveX)
		loader.writeCurveBezier(tag, "bendCurveY", pCalibrateBendCurveY)
		pCalibrateTwistAxes.forEach(block Vector each
			loader.writeVector(tag, "twistAxis", each)
		end)
		loader.writeVector(tag, "twistBoneAxisRotation", pCalibrateTwistBoneAxisRotation)
		lcp.writeMatrix(tag, "twistTransform", pCalibrateTwistTransform)
	end
end
