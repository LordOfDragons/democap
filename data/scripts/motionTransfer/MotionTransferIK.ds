/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer using Inverse Kinematic.
 * 
 * Defines root bone and target bone name. This defines the bone chain to manipulate.
 * The target bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 2 or more bones.
 * 
 * Defines the tracker slot to be used to set the target bone position before applying
 * inverse kinematic. During calibration the coordinate system of the tracker slot
 * relative to the target bone coordinate system is stored. Custom position and rotation
 * offsets can be applied to fine tune the result if slightly off.
 * 
 * Optionally a guide tracker slot can be defined which is used to guide the orientation
 * of the root bone before applying inverse kinematics. This is used for example to guide
 * the elbow on an arm while shoulder and hand remain at equal position and orientation.
 */
class MotionTransferIK extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "ik"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferIK.new(factoryID())
		end
	end
	
	
	
	private var String pTargetBone
	private var int pBoneCount
	private var MotionTransferTracker pTargetTracker
	private var MotionTransferTracker pGuideTracker
	private var float pReachLimit
	
	private var ADController pADControllerGuidePosition
	private var ADController pADControllerGuideUp
	
	private var ADRuleTrackTo pADRuleGuide
	private var ADRuleInverseKinematic pADRuleIK
	
	private var float pCalibrateReach
	private var float pCalibrateReachScale
	private var String pCalibrateRootBone
	private var ARTrackToAxis pCalibrateGuideTrackAxis
	private var ARTrackToAxis pCalibrateGuideUpAxis
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTargetBone = ""
		pBoneCount = 3
		pTargetTracker = MotionTransferTracker.new()
		pGuideTracker = MotionTransferTracker.new()
		pReachLimit = 1
		pCalibrateReach = 0.6
		pCalibrateReachScale  = 1
		pCalibrateRootBone = ""
		pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
		pCalibrateGuideUpAxis = ARTrackToAxis.posY
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferIK transfer) super(transfer.factoryID())
		pTargetBone = transfer.pTargetBone
		pBoneCount = transfer.pBoneCount
		pTargetTracker = MotionTransferTracker.new(transfer.pTargetTracker)
		pGuideTracker = MotionTransferTracker.new(transfer.pGuideTracker)
		pReachLimit = transfer.pReachLimit
		pCalibrateReach = transfer.pCalibrateReach
		pCalibrateReachScale = transfer.pCalibrateReachScale
		pCalibrateGuideTrackAxis = transfer.pCalibrateGuideTrackAxis
		pCalibrateGuideUpAxis = transfer.pCalibrateGuideUpAxis
	end
	
	
	
	/** Target bone name. */
	public func String getTargetBone()
		return pTargetBone
	end
	
	/** Set target bone name. */
	public func void setTargetBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBone = bone
	end
	
	/** Count of bones in bone chain up to root bone. */
	public func int getBoneCount()
		return pBoneCount
	end
	
	/** Set of bones in bone chain up to root bone. */
	public func void setBoneCount(int count)
		if count < 1
			throw ENullPointer.new("count < 1")
		end
		pBoneCount = count
	end
	
	/** Target tracker. */
	public func MotionTransferTracker getTargetTracker()
		return pTargetTracker
	end
	
	/** Guide tracker. */
	public func MotionTransferTracker getGuideTracker()
		return pGuideTracker
	end
	
	/** Limit reach to percentage of bone chain reach. */
	public func float getReachLimit()
		return pReachLimit
	end
	
	/** Set limit reach to percentage of bone chain reach. */
	public func void setReachLimit(float limit)
		pReachLimit = DEMath.max(limit, 0.1)
	end
	
	
	
	/** Animator definition rule or null. */
	public func ADRuleInverseKinematic getADRuleIK()
		return pADRuleIK
	end
	
	public func ADRuleTrackTo getADRuleGuide()
		return pADRuleGuide
	end
	
	/** Calibrate reach. */
	public func float getCalibrateReach()
		return pCalibrateReach
	end
	
	/** Calibrate guide track axis. */
	public func ARTrackToAxis getCalibrateGuideTrackAxis()
		return pCalibrateGuideTrackAxis
	end
	
	/** Calibrate guide up axis. */
	public func ARTrackToAxis getCalibrateGuideUpAxis()
		return pCalibrateGuideUpAxis
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass)
		pADControllerGuidePosition = null
		pADControllerGuideUp = null
		pADRuleIK = null
		pADRuleGuide = null
		
		// add behavior
		var ECBMotionTransferIK behavior = ECBMotionTransferIK.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTarget, slotGuide
		if not pTargetTracker.getSlot().empty()
			slotTarget = config.getTrackerSlots().getAt(pTargetTracker.getSlot())
		end
		if not pGuideTracker.getSlot().empty()
			slotGuide = config.getTrackerSlots().getAt(pGuideTracker.getSlot())
		end
		
		if slotTarget == null or pCalibrateRootBone.empty() or pTargetBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		
		if slotGuide != null
			pADControllerGuidePosition = ADController.new()
			pADControllerGuidePosition.setName(behavior.getControllerNameGuidePosition())
			adef.addController(pADControllerGuidePosition)
			
			pADControllerGuideUp = ADController.new()
			pADControllerGuideUp.setName(behavior.getControllerNameGuideUp())
			adef.addController(pADControllerGuideUp)
			
			pADRuleGuide = ADRuleTrackTo.new()
			pADRuleGuide.setName(getName() + ".guide")
			pADRuleGuide.setTrackAxis(pCalibrateGuideTrackAxis)
			pADRuleGuide.setUpAxis(pCalibrateGuideUpAxis)
			pADRuleGuide.setUpTarget(ARTrackToUp.controller)
			pADRuleGuide.addBone(pCalibrateRootBone)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerGuidePosition)
			adef.addLink(link)
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARTrackToTarget.position, link))
			
			link = ADLink.new()
			link.setController(pADControllerGuideUp)
			adef.addLink(link)
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARTrackToTarget.up, link))
			
			adef.addRule(pADRuleGuide)
		end
		
		pADRuleIK = ADRuleInverseKinematic.new()
		pADRuleIK.setName(getName())
		pADRuleIK.setAdjustOrientation(true)
		pADRuleIK.setLocalPosition(pTargetTracker.getReverseTransformPosition())
		pADRuleIK.setLocalOrientation(pTargetTracker.getTransformRotation())
		pADRuleIK.setReachBone(pCalibrateRootBone)
		pADRuleIK.setReachRange(pCalibrateReach)
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, slotTarget.getADLinkPosition()))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, slotTarget.getADLinkRotation()))
		pADRuleIK.addBone(pCalibrateRootBone)
		pADRuleIK.addBone(pTargetBone)
		adef.addRule(pADRuleIK)
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pCalibrateRootBone = ""
		pTargetTracker.resetTransform()
		pGuideTracker.resetTransform()
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		pCalibrateRootBone = findRootBone(component.getRig(), pTargetBone, pBoneCount)
		pCalibrateGuideTrackAxis = findGuideTrackAxis(component.getRig(), pTargetBone, pBoneCount)
		pCalibrateGuideUpAxis = guideUpFromGuideTrack(pCalibrateGuideTrackAxis)
		
		pTargetTracker.setTransform(config, component, pTargetBone)
		pGuideTracker.setTransformTrackTo(config, component, pCalibrateRootBone, \
			trackToVectorFromAxis(pCalibrateGuideTrackAxis))
		
		// calculate reach of IK chain to avoid over stretching
		var int indexRoot = -1, indexTarget = -1
		if not pCalibrateRootBone.empty() and not pTargetBone.empty()
			indexRoot = component.indexOfBoneNamed(pCalibrateRootBone)
			indexTarget = component.indexOfBoneNamed(pTargetBone)
		end
		
		if indexRoot != -1 and indexTarget != -1
			var Vector posRoot = component.boneGetMatrix(indexRoot).getPosition()
			var Vector posTarget = component.boneGetMatrix(indexTarget) * pTargetTracker.getReverseTransformPosition()
			pCalibrateReach = (posTarget - posRoot).getLength()
			
			var CharacterTrackerSlot slotTarget = pTargetTracker.getRealSlot()
			if slotTarget != null
				var Vector slotPos = slotTarget.getCalibratePosition()
				var float realReach = (slotPos - posRoot).getLength()
				pCalibrateReachScale = pCalibrateReach / realReach
				
			else
				pCalibrateReachScale = 1
				pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
				pCalibrateGuideUpAxis = ARTrackToAxis.posY
			end
			
		else
			pCalibrateReach = 0.6
			pCalibrateReachScale = 1
		end
		
		GameApp.getGameApp().getConsole().addMessage("MotionTransferIK.calibrate: name='" \
			+ getName() + "' reach=" + pCalibrateReach + " reachScale=" + pCalibrateReachScale \
			+ " guideTrackAxis=" + pCalibrateGuideTrackAxis + " guideUpAxis=" + pCalibrateGuideUpAxis)
	end
	
	/** Find root bone name. */
	protected func String findRootBone(Rig rig, String targetBone, int boneCount)
		var int i, root, index = rig.indexOfBoneNamed(targetBone)
		
		while index != -1 and boneCount-- > 0
			root = index
			index = rig.boneGetParent(index)
		end
		
		return boneCount < 1 if rig.boneGetName(root) else ""
	end
	
	/** Find guide track axis. */
	protected func ARTrackToAxis findGuideTrackAxis(Rig rig, String targetBone, int boneCount)
		if boneCount < 2
			return ARTrackToAxis.posZ
		end
		
		var int i, guide, index = rig.indexOfBoneNamed(targetBone)
		
		while index != -1 and boneCount-- > 1
			guide = index
			index = rig.boneGetParent(index)
		end
		
		if boneCount > 1
			return ARTrackToAxis.posZ
		end
		
		var Vector position = rig.boneGetPosition(guide)
		var Vector absPosition = position.absolute()
		
		if absPosition.getZ() > absPosition.getX() and absPosition.getZ() > absPosition.getY()
			return position.getZ() > 0 if ARTrackToAxis.posZ else ARTrackToAxis.negZ
			
		elif absPosition.getX() > absPosition.getY()
			return position.getX() > 0 if ARTrackToAxis.posX else ARTrackToAxis.negX
			
		else
			return position.getY() > 0 if ARTrackToAxis.posY else ARTrackToAxis.negY
		end
	end
	
	/** Get guide up axis from guide track axis. */
	protected func ARTrackToAxis guideUpFromGuideTrack(ARTrackToAxis axis)
		select pCalibrateGuideTrackAxis
		case ARTrackToAxis.posY, ARTrackToAxis.negY
			return ARTrackToAxis.posZ
			
		else
			return ARTrackToAxis.posY
		end
	end
	
	/** Get track to vector from trackto axis. */
	static public func Vector trackToVectorFromAxis(ARTrackToAxis axis)
		select axis
		case ARTrackToAxis.posZ
			return Vector.new(0, 0, 1)
			
		case ARTrackToAxis.negZ
			return Vector.new(0, 0, -1)
			
		case ARTrackToAxis.posX
			return Vector.new(1, 0, 0)
			
		case ARTrackToAxis.negX
			return Vector.new(-1, 0, 0)
			
		case ARTrackToAxis.posY
			return Vector.new(0, 1, 0)
			
		case ARTrackToAxis.negY
			return Vector.new(0, -1, 0)
			
		else
			throw EInvalidParam.new()
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferIK.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("targetBone")
				setTargetBone(element.getFirstCData())
				
			elif tagName.equals("boneCount")
				setBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.load(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.load(loader, element)
				
			elif tagName.equals("reachLimit")
				pReachLimit = element.getFirstCDataFloat()
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	protected func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("reach")
				pCalibrateReach = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScale")
				pCalibrateReachScale = element.getFirstCDataFloat()
				
			elif tagName.equals("rootBone")
				pCalibrateRootBone = element.getFirstCData()
				
			elif tagName.equals("targetTracker")
				pTargetTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTrackAxis")
				pCalibrateGuideTrackAxis = ARTrackToAxis.named(element.getFirstCData())
				pCalibrateGuideUpAxis = guideUpFromGuideTrack(pCalibrateGuideTrackAxis)
			end
		end)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("targetBone", pTargetBone)
		tag.addDataTag("boneCount", pBoneCount)
		pTargetTracker.save(loader, tag.addTag("targetTracker"))
		pGuideTracker.save(loader, tag.addTag("guideTracker"))
		tag.addDataTag("reachLimit", pReachLimit)
		tag.addDataTag("calibrateReach", pCalibrateReach)
		tag.addDataTag("reachScale", pCalibrateReachScale)
		tag.addDataTag("calibrateRootBone", pCalibrateRootBone)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	protected func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("reach", pCalibrateReach)
		tag.addDataTag("reachScale", pCalibrateReachScale)
		tag.addDataTag("rootBone", pCalibrateRootBone)
		pTargetTracker.saveCalibrated(loader, tag.addTag("targetTracker"))
		pGuideTracker.saveCalibrated(loader, tag.addTag("guideTracker"))
		tag.addDataTag("guideTrackAxis", pCalibrateGuideTrackAxis.name())
	end
end
