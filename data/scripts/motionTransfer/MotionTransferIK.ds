/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer using Inverse Kinematic.
 * 
 * Defines root bone and target bone name. This defines the bone chain to manipulate.
 * The target bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 2 or more bones.
 * 
 * Defines the tracker slot to be used to set the target bone position before applying
 * inverse kinematic. During calibration the coordinate system of the tracker slot
 * relative to the target bone coordinate system is stored. Custom position and rotation
 * offsets can be applied to fine tune the result if slightly off.
 * 
 * Optionally a guide tracker slot can be defined which is used to guide the orientation
 * of the root bone before applying inverse kinematics. This is used for example to guide
 * the elbow on an arm while shoulder and hand remain at equal position and orientation.
 */
class MotionTransferIK extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "ik"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferIK.new(factoryID())
		end
	end
	
	/** Actor reach type. */
	enum ActorReach
		none //<! No actor reach. Use unscaled reach
		arm //<! Use actor arm length as reach
		leg //<! Use actor leg length as reach
	end
	
	
	
	private var String pTargetBone
	private var int pBoneCount
	private var int pBaseChainIndex
	private var MotionTransferTracker pTargetTracker
	private var MotionTransferTracker pGuideTracker
	private var MotionTransferTracker pBaseTracker
	private var ActorReach pActorReach
	private var float pReachLimit
	private var String pMoveBaseIK
	private var String pMoveRetracted
	private var float pTwistPropagation
	
	private var ADController pADControllerTargetPosition
	private var ADController pADControllerTargetOrientation
	private var ADController pADControllerGuidePosition
	private var ADController pADControllerGuideUp
	private var ADController pADControllerTwist
	private var ADController pADControllerRetracted
	
	private var ADRuleTrackTo pADRuleGuide
	private var ADRuleInverseKinematic pADRuleIK
	private var ADRuleAnimation pADRuleBaseIK
	private var ADRuleAnimation pADRuleRetracted
	
	private var Animator pAnimatorPost
	
	private var Array pCalibrateBones
	private var float pCalibrateReach
	private var float pCalibrateReachScale
	private var ARTrackToAxis pCalibrateGuideTrackAxis
	private var ARTrackToAxis pCalibrateGuideUpAxis
	private var Vector pCalibrateTargetOffset
	private var float pCalibrateReachRetracted
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTargetBone = ""
		pBoneCount = 3
		pBaseChainIndex = 0
		pTargetTracker = MotionTransferTracker.new()
		pGuideTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pActorReach = ActorReach.none
		pReachLimit = 1
		pMoveBaseIK = ""
		pMoveRetracted = ""
		pTwistPropagation = 0
		pCalibrateBones = Array.new()
		pCalibrateReach = 0.6
		pCalibrateReachScale  = 1
		pCalibrateReachRetracted = 1
		pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
		pCalibrateGuideUpAxis = ARTrackToAxis.posY
		pCalibrateTargetOffset = Vector.new()
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferIK transfer) super(transfer.factoryID())
		pTargetBone = transfer.pTargetBone
		pBoneCount = transfer.pBoneCount
		pBaseChainIndex = transfer.pBaseChainIndex
		pTargetTracker = MotionTransferTracker.new(transfer.pTargetTracker)
		pGuideTracker = MotionTransferTracker.new(transfer.pGuideTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pActorReach = transfer.pActorReach
		pReachLimit = transfer.pReachLimit
		pMoveBaseIK = transfer.pMoveBaseIK
		pMoveRetracted = transfer.pMoveRetracted
		pTwistPropagation = transfer.pTwistPropagation
		pCalibrateBones = Array.new(transfer.pCalibrateBones)
		pCalibrateReach = transfer.pCalibrateReach
		pCalibrateReachScale = transfer.pCalibrateReachScale
		pCalibrateReachRetracted = transfer.pCalibrateReachRetracted
		pCalibrateGuideTrackAxis = transfer.pCalibrateGuideTrackAxis
		pCalibrateGuideUpAxis = transfer.pCalibrateGuideUpAxis
		pCalibrateTargetOffset = transfer.pCalibrateTargetOffset
	end
	
	
	
	/** Target bone name. */
	public func String getTargetBone()
		return pTargetBone
	end
	
	/** Set target bone name. */
	public func void setTargetBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBone = bone
	end
	
	/** Count of bones in bone chain up to root bone. */
	public func int getBoneCount()
		return pBoneCount
	end
	
	/** Set of bones in bone chain up to root bone. */
	public func void setBoneCount(int count)
		if count < 1
			throw ENullPointer.new("count < 1")
		end
		pBoneCount = count
	end
	
	/** Index of base bone along chain counting from root bone. */
	public func int getBaseChainIndex()
		return pBaseChainIndex
	end
	
	/** Set index of base bone along chain counting from root bone. */
	public func void setBaseChainIndex(int index)
		if index < 0
			throw ENullPointer.new("index < 0")
		end
		pBaseChainIndex = index
	end
	
	/** Target tracker. */
	public func MotionTransferTracker getTargetTracker()
		return pTargetTracker
	end
	
	/** Guide tracker. */
	public func MotionTransferTracker getGuideTracker()
		return pGuideTracker
	end
	
	/** Reach tracker. */
	public func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Actor reach to use to scale reach length. */
	public func ActorReach getActorReach()
		return pActorReach
	end
	
	/** Set actor reach to use to scale reach length. */
	public func void setActorReach(ActorReach actorReach)
		if actorReach == null
			throw ENullPointer.new("actorReach")
		end
		pActorReach = actorReach
	end
	
	/** Limit reach to percentage of bone chain reach. */
	public func float getReachLimit()
		return pReachLimit
	end
	
	/** Set limit reach to percentage of bone chain reach. */
	public func void setReachLimit(float limit)
		pReachLimit = DEMath.max(limit, 0.1)
	end
	
	/** Name of move to use to init base IK state for better results. */
	public func String getMoveBaseIK()
		return pMoveBaseIK
	end
	
	/** Set name of move to use to init base IK state for better results. */
	public func void setMoveBaseIK(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveBaseIK = move
	end
	
	/** Name of move to use to init retracted pose for better results. */
	public func String getMoveRetracted()
		return pMoveRetracted
	end
	
	/** Set name of move to use to init retracted pose for better results. */
	public func void setMoveRetracted(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveRetracted = move
	end
	
	/** Percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func float getTwistPropagation()
		return pTwistPropagation
	end
	
	/** Set percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func void setTwistPropagation(float amount)
		pTwistPropagation = DEMath.clamp(amount, 0.0, 1.0)
	end
	
	
	
	/** Animator definition rule or null. */
	public func ADRuleInverseKinematic getADRuleIK()
		return pADRuleIK
	end
	
	public func ADRuleTrackTo getADRuleGuide()
		return pADRuleGuide
	end
	
	public func ADRuleAnimation getADRuleBaseIK()
		return pADRuleBaseIK
	end
	
	/** Animator applied after main animator is applied. */
	public func Animator getAnimatorPost()
		return pAnimatorPost
	end
	
	/** Calibrate reach. */
	public func float getCalibrateReach()
		return pCalibrateReach
	end
	
	/** Calibrate reach scale. */
	public func float getCalibrateReachScale()
		return pCalibrateReachScale
	end
	
	/** Calibrate target offset. */
	public func Vector getCalibrateTargetOffset()
		return pCalibrateTargetOffset
	end
	
	/** Calibrate guide track axis. */
	public func ARTrackToAxis getCalibrateGuideTrackAxis()
		return pCalibrateGuideTrackAxis
	end
	
	/** Calibrate guide up axis. */
	public func ARTrackToAxis getCalibrateGuideUpAxis()
		return pCalibrateGuideUpAxis
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass)
		pADControllerTargetPosition = null
		pADControllerTargetOrientation = null
		pADControllerGuidePosition = null
		pADControllerRetracted = null
		pADControllerGuideUp = null
		pADControllerTwist = null
		pADRuleIK = null
		pADRuleGuide = null
		pADRuleBaseIK = null
		pADRuleRetracted = null
		pAnimatorPost = null
		
		// add behavior
		var ECBMotionTransferIK behavior = ECBMotionTransferIK.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTarget, slotGuide, slotReach
		if not pTargetTracker.getSlot().empty()
			slotTarget = config.getTrackerSlots().getAt(pTargetTracker.getSlot())
		end
		if not pGuideTracker.getSlot().empty()
			slotGuide = config.getTrackerSlots().getAt(pGuideTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotReach = config.getTrackerSlots().getAt(pBaseTracker.getSlot())
		end
		
		if slotTarget == null or pCalibrateBones.getCount() == 0 or pTargetBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		var String rootBone = pCalibrateBones.getAt(-1) cast String
		var String baseBone = pCalibrateBones.getAt(-(pBaseChainIndex + 1)) cast String
		
// 		if false
// 			var ADRuleBoneTransformator rule = ADRuleBoneTransformator.new()
// 			rule.setName(getName() + ".baseBend1")
// 		end
		
		if not pMoveBaseIK.empty()
			pADRuleBaseIK = ADRuleAnimation.new()
			pADRuleBaseIK.setName(getName() + ".baseIK")
			pADRuleBaseIK.setMoveName(pMoveBaseIK)
			pCalibrateBones.forEach(block String each
				pADRuleBaseIK.addBone(each)
			end)
			adef.addRule(pADRuleBaseIK)
		end
		
		if not pMoveRetracted.empty()
			pADControllerRetracted = ADController.new()
			pADControllerRetracted.setName(behavior.getControllerNameRetracted())
			pADControllerRetracted.setMinimum(pCalibrateReachRetracted)
			pADControllerRetracted.setMaximum(pCalibrateReach)
			adef.addController(pADControllerRetracted)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerRetracted)
			var CurveBezier curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0, 1) // retracted reach (x=0) => blend factor 1 (y=1)
			curve.addPoint(1, 0) // stretched reach (x=1) => blend factor 0 (y=0)
			link.setCurve(curve)
			adef.addLink(link)
			
			pADRuleRetracted = ADRuleAnimation.new()
			pADRuleRetracted.setName(getName() + ".retracted")
			pADRuleRetracted.setMoveName(pMoveRetracted)
			pCalibrateBones.forEach(block String each
				pADRuleRetracted.addBone(each)
			end)
			pADRuleRetracted.addTargetLink(ADRuleTargetLink.new(ARAnimationTarget.blendFactor, link))
			adef.addRule(pADRuleRetracted)
		end
		
		if slotGuide != null and slotGuide.isDeviceAttached()
			pADControllerGuidePosition = ADController.new()
			pADControllerGuidePosition.setName(behavior.getControllerNameGuidePosition())
			adef.addController(pADControllerGuidePosition)
			
			pADControllerGuideUp = ADController.new()
			pADControllerGuideUp.setName(behavior.getControllerNameGuideUp())
			adef.addController(pADControllerGuideUp)
			
			pADRuleGuide = ADRuleTrackTo.new()
			pADRuleGuide.setName(getName() + ".guide")
			pADRuleGuide.setTrackAxis(pCalibrateGuideTrackAxis)
			pADRuleGuide.setUpAxis(pCalibrateGuideUpAxis)
			pADRuleGuide.setUpTarget(ARTrackToUp.controller)
			pADRuleGuide.addBone(pCalibrateBones.getAt(-(pBaseChainIndex + 1)) cast String)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerGuidePosition)
			adef.addLink(link)
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARTrackToTarget.position, link))
			
			link = ADLink.new()
			link.setController(pADControllerGuideUp)
			adef.addLink(link)
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARTrackToTarget.up, link))
			
			adef.addRule(pADRuleGuide)
		end
		
		pADControllerTargetPosition = ADController.new()
		pADControllerTargetPosition.setName(behavior.getControllerNameTargetPosition())
		adef.addController(pADControllerTargetPosition)
		
		pADControllerTargetOrientation = ADController.new()
		pADControllerTargetOrientation.setName(behavior.getControllerNameTargetOrientation())
		adef.addController(pADControllerTargetOrientation)
		
		var ADLink linkTargetPosition = ADLink.new()
		linkTargetPosition.setController(pADControllerTargetPosition)
		adef.addLink(linkTargetPosition)
		
		var ADLink linkTargetOrientation = ADLink.new()
		linkTargetOrientation.setController(pADControllerTargetOrientation)
		adef.addLink(linkTargetOrientation)
		
		pADRuleIK = ADRuleInverseKinematic.new()
		pADRuleIK.setName(getName())
		pADRuleIK.setAdjustOrientation(true)
		pADRuleIK.setReachBone(baseBone)
		pADRuleIK.setReachRange(pCalibrateReach)
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTargetPosition))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkTargetOrientation))
		pADRuleIK.addBone(rootBone)
		pADRuleIK.addBone(pTargetBone)
		adef.addRule(pADRuleIK)
		
		// post animator
		adef = AnimatorDefinition.new("")
		
		var ADRuleStateSnapshot ruleStaSnap = ADRuleStateSnapshot.new()
		ruleStaSnap.setName(getName() + ".currentState")
		ruleStaSnap.setUseLastState(true)
		adef.addRule(ruleStaSnap)
		
		var Set addBones = Set.new()
		
		if pTwistPropagation > 0.01 and pCalibrateBones.getCount() >= pBaseChainIndex + 3
			var int i, count = pCalibrateBones.getCount() - (pBaseChainIndex + 2)
			var ADRuleBoneTransformator rule
			var String name = getName() + ".twist"
			var float maxAngle = 120
			var Vector minRot = Vector.new(0, 0, pTwistPropagation * -maxAngle / count)
			var Vector maxRot = Vector.new(0, 0, pTwistPropagation * maxAngle / count)
			
			pADControllerTwist = ADController.new()
			pADControllerTwist.setName(behavior.getControllerNameTwist())
			pADControllerTwist.setMinimum(-maxAngle)
			pADControllerTwist.setMaximum(maxAngle)
			adef.addController(pADControllerTwist)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerTwist)
			adef.addLink(link)
			
			var int baseIndex = pBaseChainIndex + 2
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(-(baseIndex + i)) cast String
				var String boneNext = pCalibrateBones.getAt(-(baseIndex + i + 1)) cast String
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setMinimumRotation(minRot)
				rule.setMaximumRotation(maxRot)
				rule.setTargetBone(bone)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
				rule.addBone(bone)
				adef.addRule(rule)
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setMinimumRotation(maxRot)
				rule.setMaximumRotation(minRot)
				rule.setTargetBone(bone)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
				rule.addBone(boneNext)
				adef.addRule(rule)
				
				addBones.add(bone)
				addBones.add(boneNext)
			end
		end
		
		if adef.getRuleCount() > 0 and addBones.getCount() > 0
			addBones.forEach(block String each
				adef.addBone(each)
			end)
			
			var CharacterAppearance appearance = config.getProfile().getAppearance()
			var Animator animator = Animator.new()
			animator.setRig(appearance.getRig())
			animator.setAnimation(appearance.getAnimation())
			
			adef.buildAnimator(animator)
			adef.debug(GameApp.getGameApp().getConsole())
			behavior.setAnimatorPost(animator)
		end
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
		end
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pCalibrateReachScale = 1
		pCalibrateReachRetracted = 1
		pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
		pCalibrateGuideUpAxis = ARTrackToAxis.posY
		pCalibrateBones.removeAll()
		pTargetTracker.resetTransform()
		pGuideTracker.resetTransform()
		pBaseTracker.resetTransform()
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		findBoneChain(component.getRig(), pTargetBone, pBoneCount, pCalibrateBones)
		var String rootBone = "", baseBone = ""
		if pCalibrateBones.getCount() > 0
			rootBone = pCalibrateBones.getAt(-1) cast String
			baseBone = pCalibrateBones.getAt(-(pBaseChainIndex + 1)) cast String
		end
		
		pCalibrateGuideTrackAxis = findGuideTrackAxis(component.getRig(), pTargetBone, pBoneCount)
		pCalibrateGuideUpAxis = guideUpFromGuideTrack(pCalibrateGuideTrackAxis)
		
		pTargetTracker.resolveRealSlot(config)
		pTargetTracker.setTransform(component, pTargetBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(component, baseBone)
		
		// calculate reach of IK chain to avoid over stretching
		var int indexRoot = -1, indexBase = -1, indexTarget = -1
		if not rootBone.empty() and not pTargetBone.empty()
			indexRoot = component.indexOfBoneNamed(rootBone)
			indexBase = component.indexOfBoneNamed(baseBone)
			indexTarget = component.indexOfBoneNamed(pTargetBone)
		end
		
		if indexRoot != -1 and indexBase != -1 and indexTarget != -1
			var Vector posRoot = component.boneGetMatrix(indexBase).getPosition()
			var Vector posTarget = component.boneGetMatrix(indexTarget) * pTargetTracker.getReverseTransformPosition()
			pCalibrateReach = (posTarget - posRoot).getLength()
			
			select pActorReach
			case ActorReach.arm
				pCalibrateReachScale = pCalibrateReach / (actorProfile.getArmLength() * config.getCalibrateScale())
				
			case ActorReach.leg
				// reach scale is not working well with legs
// 				pCalibrateReachScale = pCalibrateReach / (actorProfile.getLegLength() * config.getCalibrateScale())
				pCalibrateReachScale = 1
				
			else
				pCalibrateReachScale = 1
			end
			
			var CharacterTrackerSlot slotTarget = pTargetTracker.getRealSlot()
			if slotTarget != null
// 				pCalibrateTargetOffset = posTarget - slotTarget.getCalibratePosition()
				pCalibrateTargetOffset = Vector.new()
				//var Vector slotPos = slotTarget.getCalibratePosition()
				//var float realReach = (slotPos - posRoot).getLength()
				//pCalibrateReachScale = pCalibrateReach / realReach
				
			else
				pCalibrateTargetOffset = Vector.new()
				//pCalibrateReachScale = 1
				//pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
				//pCalibrateGuideUpAxis = ARTrackToAxis.posY
			end
			
		else
			pCalibrateReach = 0.6
			pCalibrateReachScale = 1
			pCalibrateReachRetracted = 1
			pCalibrateTargetOffset = Vector.new()
		end
		
		// calibrate guide tracker. has to come after reach scaling since it uses this value
		pGuideTracker.resolveRealSlot(config)
		
		pGuideTracker.setTransformTrackTo(component, \
			pCalibrateBones.getAt(-(pBaseChainIndex + 1)) cast String, \
			trackToVectorFromAxis(pCalibrateGuideTrackAxis), pCalibrateReachScale)
		
		// calculate retracted reach if used
		if not pMoveRetracted.empty() and indexBase != -1 and indexTarget != -1
			// create a temporary component so we can apply the move and do some measuring
			var Component tcomponent = Component.new(component.getModel(), component.getSkin())
			tcomponent.setRig(component.getRig())
			
			var CharacterAppearance appearance = config.getProfile().getAppearance()
			var Animator tanimator = Animator.new()
			tanimator.setRig(component.getRig())
			tanimator.setAnimation(appearance.getAnimation())
			
			var ARAnimation rule = ARAnimation.new()
			rule.setMoveName(pMoveRetracted)
			tanimator.addRule(rule)
			
			var AnimatorInstance tainst = AnimatorInstance.new()
			tainst.setAnimator(tanimator)
			tainst.setComponent(tcomponent)
			tainst.applyDirect()
			tcomponent.updateBones()
			
			// measure the reach and store it
			var Vector posRoot = tcomponent.boneGetMatrix(indexBase).getPosition()
			var Vector posTarget = tcomponent.boneGetMatrix(indexTarget) * pTargetTracker.getReverseTransformPosition()
			pCalibrateReachRetracted = (posTarget - posRoot).getLength()
		end
		
		GameApp.getGameApp().getConsole().addMessage("MotionTransferIK.calibrate: name='" \
			+ getName() + "' reach=" + pCalibrateReach + " reachScale=" + pCalibrateReachScale \
			+ " guideTrackAxis=" + pCalibrateGuideTrackAxis + " guideUpAxis=" \
			+ pCalibrateGuideUpAxis + " bones=" + pCalibrateBones + " targetOffset=" \
			+ pCalibrateTargetOffset + " retractedReach=" + pCalibrateReachRetracted)
	end
	
	/** Find bone chain. */
	protected func void findBoneChain(Rig rig, String targetBone, int boneCount, Array bones)
		bones.removeAll()
		
		var int index = rig.indexOfBoneNamed(targetBone)
		while index != -1 and boneCount-- > 0
			bones.add(rig.boneGetName(index))
			index = rig.boneGetParent(index)
		end
	end
	
	/** Find guide track axis. */
	protected func ARTrackToAxis findGuideTrackAxis(Rig rig, String targetBone, int boneCount)
		if boneCount < 2
			return ARTrackToAxis.posZ
		end
		
		var int i, guide, index = rig.indexOfBoneNamed(targetBone)
		
		while index != -1 and boneCount-- > 1
			guide = index
			index = rig.boneGetParent(index)
		end
		
		if boneCount > 1
			return ARTrackToAxis.posZ
		end
		
		var Vector position = rig.boneGetPosition(guide)
		var Vector absPosition = position.absolute()
		
		if absPosition.getZ() > absPosition.getX() and absPosition.getZ() > absPosition.getY()
			return position.getZ() > 0 if ARTrackToAxis.posZ else ARTrackToAxis.negZ
			
		elif absPosition.getX() > absPosition.getY()
			return position.getX() > 0 if ARTrackToAxis.posX else ARTrackToAxis.negX
			
		else
			return position.getY() > 0 if ARTrackToAxis.posY else ARTrackToAxis.negY
		end
	end
	
	/** Get guide up axis from guide track axis. */
	protected func ARTrackToAxis guideUpFromGuideTrack(ARTrackToAxis axis)
		select pCalibrateGuideTrackAxis
		case ARTrackToAxis.posY, ARTrackToAxis.negY
			return ARTrackToAxis.posZ
			
		else
			return ARTrackToAxis.posY
		end
	end
	
	/** Get track to vector from trackto axis. */
	static public func Vector trackToVectorFromAxis(ARTrackToAxis axis)
		select axis
		case ARTrackToAxis.posZ
			return Vector.new(0, 0, 1)
			
		case ARTrackToAxis.negZ
			return Vector.new(0, 0, -1)
			
		case ARTrackToAxis.posX
			return Vector.new(1, 0, 0)
			
		case ARTrackToAxis.negX
			return Vector.new(-1, 0, 0)
			
		case ARTrackToAxis.posY
			return Vector.new(0, 1, 0)
			
		case ARTrackToAxis.negY
			return Vector.new(0, -1, 0)
			
		else
			throw EInvalidParam.new()
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferIK.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("targetBone")
				setTargetBone(element.getFirstCData())
				
			elif tagName.equals("boneCount")
				setBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("baseChainIndex")
				setBaseChainIndex(element.getFirstCDataInt())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.load(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("actorReach")
				setActorReach(ActorReach.named(element.getFirstCData()))
				
			elif tagName.equals("reachLimit")
				setReachLimit(element.getFirstCDataFloat())
				
			elif tagName.equals("moveBaseIK")
				setMoveBaseIK(element.getFirstCData())
				
			elif tagName.equals("moveRetracted")
				setMoveRetracted(element.getFirstCData())
				
			elif tagName.equals("twistPropagation")
				setTwistPropagation(element.getFirstCDataFloat())
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	protected func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("reach")
				pCalibrateReach = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScale")
				pCalibrateReachScale = element.getFirstCDataFloat()
				
			elif tagName.equals("targetOffset")
				pCalibrateTargetOffset = loader.readVector(element)
				
			elif tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("reachTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTrackAxis")
				pCalibrateGuideTrackAxis = ARTrackToAxis.named(element.getFirstCData())
				pCalibrateGuideUpAxis = guideUpFromGuideTrack(pCalibrateGuideTrackAxis)
				
			elif tagName.equals("reachRetracted")
				pCalibrateReachRetracted = element.getFirstCDataFloat()
			end
		end)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("targetBone", pTargetBone)
		tag.addDataTag("boneCount", pBoneCount)
		tag.addDataTag("baseChainIndex", pBaseChainIndex)
		pTargetTracker.save(loader, tag.addTag("targetTracker"))
		pGuideTracker.save(loader, tag.addTag("guideTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		tag.addDataTag("actorReach", pActorReach.name())
		tag.addDataTag("reachLimit", pReachLimit)
		tag.addDataTag("moveBaseIK", pMoveBaseIK)
		tag.addDataTag("moveRetracted", pMoveRetracted)
		tag.addDataTag("twistPropagation", pTwistPropagation)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	protected func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("reach", pCalibrateReach)
		tag.addDataTag("reachScale", pCalibrateReachScale)
		loader.writeVector(tag, "targetOffset", pCalibrateTargetOffset)
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTargetTracker.saveCalibrated(loader, tag.addTag("targetTracker"))
		pGuideTracker.saveCalibrated(loader, tag.addTag("guideTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("reachTracker"))
		tag.addDataTag("guideTrackAxis", pCalibrateGuideTrackAxis.name())
		tag.addDataTag("reachRetracted", pCalibrateReachRetracted)
	end
end
