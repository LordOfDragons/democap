/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer using Inverse Kinematic.
 * 
 * Defines root bone and target bone name. This defines the bone chain to manipulate.
 * The target bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 2 or more bones.
 * 
 * Defines the tracker slot to be used to set the target bone position before applying
 * inverse kinematic. During calibration the coordinate system of the tracker slot
 * relative to the target bone coordinate system is stored. Custom position and rotation
 * offsets can be applied to fine tune the result if slightly off.
 * 
 * Optionally a guide tracker slot can be defined which is used to guide the orientation
 * of the root bone before applying inverse kinematics. This is used for example to guide
 * the elbow on an arm while shoulder and hand remain at equal position and orientation.
 */
class MotionTransferIK extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "ik"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferIK.new(factoryID())
		end
	end
	
	
	
	private var String pRootBone
	private var String pTargetBone
	private var MotionTransferTracker pTargetTracker
	private var MotionTransferTracker pGuideTracker
	
	private var ADRuleInverseKinematic pADRuleIK
	
	private var float pCalibrateReach
	private var float pReachScale
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pRootBone = ""
		pTargetBone = ""
		pTargetTracker = MotionTransferTracker.new()
		pGuideTracker = MotionTransferTracker.new()
		pCalibrateReach = 0.6
		pReachScale  = 1
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferIK transfer) super(transfer.factoryID())
		pRootBone = transfer.pRootBone
		pTargetBone = transfer.pTargetBone
		pTargetTracker = MotionTransferTracker.new(transfer.pTargetTracker)
		pGuideTracker = MotionTransferTracker.new(transfer.pGuideTracker)
		pCalibrateReach = transfer.pCalibrateReach
		pReachScale = transfer.pReachScale
	end
	
	
	
	/** Root bone name. */
	public func String getRootBone()
		return pRootBone
	end
	
	/** Set root bone name. */
	public func void setRootBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pRootBone = bone
	end
	
	/** Target bone name. */
	public func String getTargetBone()
		return pTargetBone
	end
	
	/** Set target bone name. */
	public func void setTargetBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTargetBone = bone
	end
	
	/** Target tracker. */
	public func MotionTransferTracker getTargetTracker()
		return pTargetTracker
	end
	
	/** Guide tracker. */
	public func MotionTransferTracker getGuideTracker()
		return pGuideTracker
	end
	
	
	
	/** Animator definition rule or null. */
	public func ADRuleInverseKinematic getADRuleIK()
		return pADRuleIK
	end
	
	/** Calibrate reach. */
	public func float getCalibrateReach()
		return pCalibrateReach
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass)
		// no behavior required
		
		// add rules. requires a valid slot and bone names
		pADRuleIK = null
		
		var CharacterTrackerSlot slotTarget, slotGuide
		if not pTargetTracker.getSlot().empty()
			slotTarget = config.getTrackerSlots().getAt(pTargetTracker.getSlot())
		end
		if not pGuideTracker.getSlot().empty()
			slotGuide = config.getTrackerSlots().getAt(pGuideTracker.getSlot())
		end
		
		if slotTarget == null or pRootBone.empty() or pTargetBone.empty()
			return
		end
		
		if slotGuide != null
			// TODO guide rule orienting root bone to guide
		end
		
		pADRuleIK = ADRuleInverseKinematic.new()
		pADRuleIK.setName(getName())
		pADRuleIK.setAdjustOrientation(true)
		pADRuleIK.setLocalPosition(-pTargetTracker.getTransformPosition())
		pADRuleIK.setLocalOrientation(pTargetTracker.getTransformRotation())
		pADRuleIK.setReachBone(pRootBone)
		pADRuleIK.setReachRange(pCalibrateReach)
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, slotTarget.getADLinkPosition()))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, slotTarget.getADLinkRotation()))
		pADRuleIK.addBone(pRootBone)
		pADRuleIK.addBone(pTargetBone)
		config.getAnimatorDefinition().addRule(pADRuleIK)
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pTargetTracker.resetTransform()
		pGuideTracker.resetTransform()
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		pTargetTracker.setTransform(config, component, pTargetBone)
		pGuideTracker.setTransform(config, component, pRootBone)
		
		// calculate reach of IK chain to avoid over stretching
		var int indexRoot = -1, indexTarget = -1
		if not pRootBone.empty() and not pTargetBone.empty()
			indexRoot = component.indexOfBoneNamed(pRootBone)
			indexTarget = component.indexOfBoneNamed(pTargetBone)
		end
		
		if indexRoot != -1 and indexTarget != -1
			var Vector posRoot = component.boneGetMatrix(indexRoot).getPosition()
			var Vector posTarget = component.boneGetMatrix(indexTarget) * -pTargetTracker.getTransformPosition()
			pCalibrateReach = (posTarget - posRoot).getLength()
			
			var CharacterTrackerSlot slotTarget = pTargetTracker.getRealSlot()
			if slotTarget != null
				//pReachScale = pCalibrateReach / actorProfile.getArmLength()
				var Vector slotPos = slotTarget.getCalibratePosition()
				var float realReach = (slotPos - posRoot).getLength()
				pReachScale = pCalibrateReach / realReach
				
			else
				pReachScale = 1
			end
			
		else
			pCalibrateReach = 0.6
			pReachScale = 1
		end
		
		GameApp.getGameApp().getConsole().addMessage("MotionTransferIK.calibrate: name='" \
			+ getName() + "' reach=" + pCalibrateReach + " reachScale=" + pReachScale)
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferIK.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("rootBone")
				setRootBone(element.getFirstCData())
				
			elif tagName.equals("targetBone")
				setTargetBone(element.getFirstCData())
				
			elif tagName.equals("targetTracker")
				pTargetTracker.load(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.load(loader, element)
				
			elif tagName.equals("calibrateReach")
				pCalibrateReach = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScale")
				pReachScale = element.getFirstCDataFloat()
			end
		end)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("rootBone", pRootBone)
		tag.addDataTag("targetBone", pTargetBone)
		pTargetTracker.save(loader, tag.addTag("targetTracker"))
		pGuideTracker.save(loader, tag.addTag("guideTracker"))
		tag.addDataTag("calibrateReach", pCalibrateReach)
		tag.addDataTag("reachScale", pReachScale)
	end
end
