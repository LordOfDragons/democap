/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer using Inverse Kinematic.
 * 
 * Defines root bone and tip bone name. This defines the bone chain to manipulate.
 * The tip bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 2 or more bones.
 * 
 * Defines the tracker slot to be used to set the tip bone position before applying
 * inverse kinematic. During calibration the coordinate system of the tracker slot
 * relative to the tip bone coordinate system is stored. Custom position and rotation
 * offsets can be applied to fine tune the result if slightly off.
 * 
 * Optionally a guide tracker slot can be defined which is used to guide the orientation
 * of the root bone before applying inverse kinematics. This is used for example to guide
 * the elbow on an arm while shoulder and hand remain at equal position and orientation.
 */
class MotionTransferIK extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "ik"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferIK.new(factoryID())
		end
		
		public func String displayName()
			return "Inverse Kinematic"
		end
	end
	
	/** Actor reach type. */
	enum ActorReach
		none //<! No actor reach. Use unscaled reach
		arm //<! Use actor arm length as reach
		leg //<! Use actor leg length as reach
	end
	
	
	
	private var String pTipBone
	private var String pBaseBone
	private var String pGuideBone
	private var MotionTransferTracker pTipTracker
	private var MotionTransferTracker pGuideTracker
	private var MotionTransferTracker pBaseTracker
	private var ActorReach pActorReach
	private var float pReachLimit
	private var Vector pReachScaling
	private var Vector pReachScalingBack
	private var bool pAdjustPosition
	private var String pMoveBaseIK
	private var String pMoveRetracted
	private var float pTwistPropagation
	private var int pTwistBoneCount
	private var Vector pTwistAxisRotation
	private var float pGuideTwistStrength
	private var bool pRelocateTip
	private var Vector2 pBaseRotateRangeCenter
	private var Vector2 pBaseRotateRangeMinimum
	private var Vector2 pBaseRotateRangeMaximum
	private var Vector2 pBaseRotateAngleMinimum
	private var Vector2 pBaseRotateAngleMaximum
	
	private var ADController pADControllerTipPosition
	private var ADController pADControllerTipOrientation
	private var ADController pADControllerGuideRotation
	private var ADController pADControllerTwist
	private var ADController pADControllerRetracted
	private var ADController pADControllerBlend
	
	private var ADRuleInverseKinematic pADRuleGuide
	private var ADRuleInverseKinematic pADRuleIK
	private var ADRuleAnimation pADRuleBaseIK
	private var ADRuleAnimation pADRuleRetracted
	
	private var Array pCalibrateBones
	private var float pCalibrateReach
	private var float pCalibrateReachScale
	private var Vector pCalibrateReachScaleDirection
	private var Vector pCalibrateReachScaleDirectionBack
	private var Vector pCalibrateReachRotation
	private var float pCalibrateReachRange
	private var Matrix pCalibrateMatrixRelocateTip
	private var float pCalibrateReachRetracted
	private var Array pCalibrateTwistAxes
	private var Vector pCalibrateTwistBoneAxisRotation
	private var float pCalibrateReachScaleFront
	private var float pCalibrateReachScaleDown
	private var float pCalibrateReachScaleUp
	private var bool pCalibrateCanTweakReachScale
	private var String pCalibratePreRotateBone
	private var Vector pCalibrateBaseRotateRotation
	private var String pCalibrateBaseRotateBone
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTipBone = ""
		pBaseBone = ""
		pGuideBone = ""
		pTipTracker = MotionTransferTracker.new()
		pGuideTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pActorReach = ActorReach.none
		pReachLimit = 1
		pReachScaling = Vector.new(1, 1, 1)
		pReachScalingBack = Vector.new(1, 1, 1)
		pAdjustPosition = true
		pMoveBaseIK = ""
		pMoveRetracted = ""
		pTwistPropagation = 0
		pTwistBoneCount = 0
		pTwistAxisRotation = Vector.new()
		pGuideTwistStrength = 0
		pRelocateTip = false
		pBaseRotateRangeCenter = Vector2.new()
		pBaseRotateRangeMinimum = Vector2.new()
		pBaseRotateRangeMaximum = Vector2.new()
		pBaseRotateAngleMinimum = Vector2.new()
		pBaseRotateAngleMaximum = Vector2.new()
		pCalibrateBones = Array.new()
		pCalibrateReach = 0.6
		pCalibrateReachScale = 1
		pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
		pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
		pCalibrateReachRange = 0
		pCalibrateReachRetracted = 1
		pCalibrateMatrixRelocateTip = Matrix.new()
		pCalibrateTwistAxes = Array.new()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateReachRotation = Vector.new()
		pCalibratePreRotateBone = ""
		pCalibrateBaseRotateRotation = Vector.new()
		pCalibrateBaseRotateBone = ""
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferIK transfer) super(transfer)
		pTipBone = transfer.pTipBone
		pBaseBone = transfer.pBaseBone
		pGuideBone = transfer.pGuideBone
		pTipTracker = MotionTransferTracker.new(transfer.pTipTracker)
		pGuideTracker = MotionTransferTracker.new(transfer.pGuideTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pActorReach = transfer.pActorReach
		pReachLimit = transfer.pReachLimit
		pReachScaling = transfer.pReachScaling
		pReachScalingBack = transfer.pReachScalingBack
		pAdjustPosition = transfer.pAdjustPosition
		pMoveBaseIK = transfer.pMoveBaseIK
		pMoveRetracted = transfer.pMoveRetracted
		pTwistPropagation = transfer.pTwistPropagation
		pTwistBoneCount = transfer.pTwistBoneCount
		pGuideTwistStrength = transfer.pGuideTwistStrength
		pRelocateTip = transfer.pRelocateTip
		pBaseRotateRangeCenter = transfer.pBaseRotateRangeCenter
		pBaseRotateRangeMinimum = transfer.pBaseRotateRangeMinimum
		pBaseRotateRangeMaximum = transfer.pBaseRotateRangeMaximum
		pBaseRotateAngleMinimum = transfer.pBaseRotateAngleMinimum
		pBaseRotateAngleMaximum = transfer.pBaseRotateAngleMaximum
		pTwistAxisRotation = transfer.pTwistAxisRotation
		pCalibrateBones = Array.new(transfer.pCalibrateBones)
		pCalibrateReach = transfer.pCalibrateReach
		pCalibrateReachScale = transfer.pCalibrateReachScale
		pCalibrateReachScaleDirection = transfer.pCalibrateReachScaleDirection
		pCalibrateReachScaleDirectionBack = transfer.pCalibrateReachScaleDirectionBack
		pCalibrateReachRange = transfer.pCalibrateReachRange
		pCalibrateReachRetracted = transfer.pCalibrateReachRetracted
		pCalibrateMatrixRelocateTip = transfer.pCalibrateMatrixRelocateTip
		pCalibrateTwistAxes = Array.new(transfer.pCalibrateTwistAxes)
		pCalibrateTwistBoneAxisRotation = transfer.pCalibrateTwistBoneAxisRotation
		pCalibrateReachRotation = transfer.pCalibrateReachRotation
		pCalibratePreRotateBone = transfer.pCalibratePreRotateBone
		pCalibrateBaseRotateBone = transfer.pCalibrateBaseRotateBone
		pCalibrateBaseRotateRotation = transfer.pCalibrateBaseRotateRotation
	end
	
	
	
	/** Tip bone name. */
	public func String getTipBone()
		return pTipBone
	end
	
	/** Set tip bone name. */
	public func void setTipBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTipBone = bone
	end
	
	/** Base bone name. */
	public func String getBaseBone()
		return pBaseBone
	end
	
	/** Set base bone name. */
	public func void setBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pBaseBone = bone
	end
	
	/** Guide bone name. */
	public func String getGuideBone()
		return pGuideBone
	end
	
	/** Set guide bone name. */
	public func void setGuideBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pGuideBone = bone
	end
	
	/** Tip tracker. */
	public func MotionTransferTracker getTipTracker()
		return pTipTracker
	end
	
	/** Guide tracker. */
	public func MotionTransferTracker getGuideTracker()
		return pGuideTracker
	end
	
	/** Reach tracker. */
	public func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Actor reach to use to scale reach length. */
	public func ActorReach getActorReach()
		return pActorReach
	end
	
	/** Set actor reach to use to scale reach length. */
	public func void setActorReach(ActorReach actorReach)
		if actorReach == null
			throw ENullPointer.new("actorReach")
		end
		pActorReach = actorReach
	end
	
	/** Limit reach to percentage of bone chain reach. */
	public func float getReachLimit()
		return pReachLimit
	end
	
	/** Set limit reach to percentage of bone chain reach. */
	public func void setReachLimit(float limit)
		pReachLimit = DEMath.max(limit, 0.1)
	end
	
	/** Reach scaling along axis for fine tune. */
	public func Vector getReachScaling()
		return pReachScaling
	end
	
	/** Set reach scaling along axis for fine tuning. */
	public func void setReachScaling(Vector scaling)
		if scaling == null
			throw ENullPointer.new("scaling")
		end
		pReachScaling = scaling
	end
	
	/** Reach scaling along negative axis for fine tune. */
	public func Vector getReachScalingBack()
		return pReachScalingBack
	end
	
	/** Set reach scaling along negative axis for fine tuning. */
	public func void setReachScalingBack(Vector scaling)
		if scaling == null
			throw ENullPointer.new("scaling")
		end
		pReachScalingBack = scaling
	end
	
	/** Adjust position if chain is of length 1. */
	public func bool getAdjustPosition()
		return pAdjustPosition
	end
	
	/** Set adjust position if chain is of length 1. */
	public func void setAdjustPosition(bool adjust)
		pAdjustPosition = adjust
	end
	
	/** Name of move to use to init base IK state for better results. */
	public func String getMoveBaseIK()
		return pMoveBaseIK
	end
	
	/** Set name of move to use to init base IK state for better results. */
	public func void setMoveBaseIK(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveBaseIK = move
	end
	
	/** Name of move to use to init retracted pose for better results. */
	public func String getMoveRetracted()
		return pMoveRetracted
	end
	
	/** Set name of move to use to init retracted pose for better results. */
	public func void setMoveRetracted(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveRetracted = move
	end
	
	/** Percentage of tip bone rotation to apply as twist down the chain. */
	public func float getTwistPropagation()
		return pTwistPropagation
	end
	
	/** Set percentage of tip bone rotation to apply as twist down the chain. */
	public func void setTwistPropagation(float percentage)
		pTwistPropagation = percentage
	end
	
	/** Count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func int getTwistBoneCount()
		return pTwistBoneCount
	end
	
	/** Set count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func void setTwistBoneCount(int count)
		if count < 0
			throw EInvalidParam.new("count < 0")
		end
		pTwistBoneCount = count
	end
	
	/** Rotation of twist axis relative to tip bone. */
	public func Vector getTwistAxisRotation()
		return pTwistAxisRotation
	end
	
	/** Set rotation of twist axis relative to tip bone. */
	public func void setTwistAxisRotation(Vector rotation)
		if rotation == null
			throw ENullPointer.new("rotation")
		end
		pTwistAxisRotation = rotation
	end
	
	/** Percentage of tip bone rotation to apply as twist to guide bone. */
	public func float getGuideTwistStrength()
		return pGuideTwistStrength
	end
	
	/** Set percentage of tip bone rotation to apply as twist to guide bone. */
	public func void setGuideTwistStrength(float percentage)
		pGuideTwistStrength = percentage
	end
	
	/** Relocate tip. */
	public func bool getRelocateTip()
		return pRelocateTip
	end
	
	/** Set to relocate tip. */
	public func void setRelocateTip(bool relocate)
		pRelocateTip = relocate
	end
	
	/** Base bone rotation range center along X and Y axis. */
	public func Vector2 getBaseRotateRangeCenter()
		return pBaseRotateRangeCenter
	end
	
	/** Set base bone rotation range center along X and Y axis. */
	public func void setBaseRotateRangeCenter(Vector2 range)
		if range == null
			throw ENullPointer.new("range")
		end
		pBaseRotateRangeCenter = range
	end
	
	/** Base bone rotation range minimum along X and Y axis. */
	public func Vector2 getBaseRotateRangeMinimum()
		return pBaseRotateRangeMinimum
	end
	
	/** Set base bone rotation range minimum along X and Y axis. */
	public func void setBaseRotateRangeMinimum(Vector2 range)
		if range == null
			throw ENullPointer.new("range")
		end
		pBaseRotateRangeMinimum = range
	end
	
	/** Base bone rotation range maximum along X and Y axis. */
	public func Vector2 getBaseRotateRangeMaximum()
		return pBaseRotateRangeMaximum
	end
	
	/** Set base bone rotation range maximum along X and Y axis. */
	public func void setBaseRotateRangeMaximum(Vector2 range)
		if range == null
			throw ENullPointer.new("range")
		end
		pBaseRotateRangeMaximum = range
	end
	
	/** Base bone rotation angle minimum along X and Y axis. */
	public func Vector2 getBaseRotateAngleMinimum()
		return pBaseRotateAngleMinimum
	end
	
	/** Set base bone rotation angle minimum along X and Y axis. */
	public func void setBaseRotateAngleMinimum(Vector2 angle)
		if angle == null
			throw ENullPointer.new("angle")
		end
		pBaseRotateAngleMinimum = angle
	end
	
	/** Base bone rotation angle maximum along X and Y axis. */
	public func Vector2 getBaseRotateAngleMaximum()
		return pBaseRotateAngleMaximum
	end
	
	/** Set base bone rotation angle maximum along X and Y axis. */
	public func void setBaseRotateAngleMaximum(Vector2 angle)
		if angle == null
			throw ENullPointer.new("angle")
		end
		pBaseRotateAngleMaximum = angle
	end
	
	
	
	/** Animator definition rule or null. */
	public func ADRuleInverseKinematic getADRuleIK()
		return pADRuleIK
	end
	
	public func ADRuleInverseKinematic getADRuleGuide()
		return pADRuleGuide
	end
	
	public func ADRuleAnimation getADRuleBaseIK()
		return pADRuleBaseIK
	end
	
	/** Calibrate reach. */
	public func float getCalibrateReach()
		return pCalibrateReach
	end
	
	/** Calibrate reach scale. */
	public func float getCalibrateReachScale()
		return pCalibrateReachScale
	end
	
	/** Calibrate reach scale per direction. */
	public func Vector getCalibrateReachScaleDirection()
		return pCalibrateReachScaleDirection
	end
	
	/** Calibrate negative reach scale per direction. */
	public func Vector getCalibrateReachScaleDirectionBack()
		return pCalibrateReachScaleDirectionBack
	end
	
	/** Calibrate reach range or 0 if disabled. */
	public func float getCalibrateReachRange()
		return pCalibrateReachRange
	end
	
	/** Calibrate matrix relocate tip. */
	public func Matrix getCalibrateMatrixRelocateTip()
		return pCalibrateMatrixRelocateTip
	end
	
	/** Calibrate twist bone axis rotation. */
	public func Vector getCalibrateTwistBoneAxisRotation()
		return pCalibrateTwistBoneAxisRotation
	end
	
	/** Calibrate reach rotation. */
	public func Vector getCalibrateReachRotation()
		return pCalibrateReachRotation
	end
	
	public func String getCalibratePreRotateBone()
		return pCalibratePreRotateBone
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass, ModifiedRig modifyRig)
		pADControllerTipPosition = null
		pADControllerTipOrientation = null
		pADControllerGuideRotation = null
		pADControllerRetracted = null
		pADControllerTwist = null
		pADControllerBlend = null
		pADRuleGuide = null
		pADRuleIK = null
		pADRuleBaseIK = null
		pADRuleRetracted = null

		var Array ignoreBones = Array.new()
		
		if pCalibrateBones.getCount() == 0
			return
		end
		
		// add behavior
		var ECBMotionTransferIK behavior = ECBMotionTransferIK.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTip, slotGuide, slotReach
		if not pTipTracker.getSlot().empty()
			slotTip = config.getTrackerSlots().getNamed(pTipTracker.getSlot())
		end
		if not pGuideTracker.getSlot().empty()
			slotGuide = config.getTrackerSlots().getNamed(pGuideTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotReach = config.getTrackerSlots().getNamed(pBaseTracker.getSlot())
		end
		
		var int boneCount = pCalibrateBones.getCount()
		if slotTip == null or boneCount < 1 or pTipBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		
		var String guideBone = pGuideBone.empty() if pBaseBone else pGuideBone
		
		
		
		// add base IK rules
		if not pMoveBaseIK.empty()
			pADRuleBaseIK = ADRuleAnimation.new()
			pADRuleBaseIK.setName(getName() + ".baseIK")
			pADRuleBaseIK.setMoveName(pMoveBaseIK)
			pCalibrateBones.forEach(block String each
				pADRuleBaseIK.addBone(each)
			end)
			adef.addRule(pADRuleBaseIK)
		end
		
		
		
		// add retracted rules
		if not pMoveRetracted.empty()
			pADControllerRetracted = ADController.new()
			pADControllerRetracted.setName(behavior.getControllerNameRetracted())
			pADControllerRetracted.setMinimum(pCalibrateReachRetracted)
			pADControllerRetracted.setMaximum(pCalibrateReach)
			adef.addController(pADControllerRetracted)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerRetracted)
			var CurveBezier curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0, 1) // retracted reach (x=0) => blend factor 1 (y=1)
			curve.addPoint(1, 0) // stretched reach (x=1) => blend factor 0 (y=0)
			link.setCurve(curve)
			adef.addLink(link)
			
			pADRuleRetracted = ADRuleAnimation.new()
			pADRuleRetracted.setName(getName() + ".retracted")
			pADRuleRetracted.setMoveName(pMoveRetracted)
			pCalibrateBones.forEach(block String each
				pADRuleRetracted.addBone(each)
			end)
			pADRuleRetracted.addTargetLink(ADRuleTargetLink.new(ARAnimationTarget.blendFactor, link))
			adef.addRule(pADRuleRetracted)
		end
		
		
		
		// shared controllers and links
		pADControllerBlend = ADController.new()
		pADControllerBlend.setName(behavior.getControllerNameBlend())
		pADControllerBlend.setMinimum(0)
		pADControllerBlend.setMaximum(1)
		adef.addController(pADControllerBlend)
		
		pADControllerTipPosition = ADController.new()
		pADControllerTipPosition.setName(behavior.getControllerNameTipPosition())
		adef.addController(pADControllerTipPosition)
		
		pADControllerTipOrientation = ADController.new()
		pADControllerTipOrientation.setName(behavior.getControllerNameTipOrientation())
		adef.addController(pADControllerTipOrientation)
		
		var ADLink linkBlend = ADLink.new()
		linkBlend.setController(pADControllerBlend)
		adef.addLink(linkBlend)
		
		var ADLink linkTipPosition = ADLink.new()
		linkTipPosition.setController(pADControllerTipPosition)
		adef.addLink(linkTipPosition)
		
		var ADLink linkTipOrientation = ADLink.new()
		linkTipOrientation.setController(pADControllerTipOrientation)
		adef.addLink(linkTipOrientation)
		
		
		
		// add base bone rotation rule
		var bool useBaseRotate = not pCalibrateBaseRotateBone.empty() and not guideBone.equals(pBaseBone)
		
		if useBaseRotate
			var Vector2 rc = pBaseRotateRangeCenter
			var Vector2 rmin = pBaseRotateRangeMinimum
			var Vector2 rmax = pBaseRotateRangeMaximum
			var Vector2 amin = pBaseRotateAngleMinimum
			var Vector2 amax = pBaseRotateAngleMaximum
			
			var ModifiedRig.Bone boneBaseRotate = modifyRig.addBone("baseRotate")
			ignoreBones.add(boneBaseRotate.name)
			
			// find bone to rotate back
			var String boneRotateBack = pGuideBone
			
			if boneRotateBack.empty()
				var int index = pCalibrateBones.indexOf(pBaseBone)
				if index > 0
					boneRotateBack = pCalibrateBones.getAt(index - 1) cast String
				end
			end
			
			// controllers
			var ADController controllerX = ADController.new()
			controllerX.setName(behavior.getControllerNameBaseRotateX())
			controllerX.setMinimum(pBaseRotateRangeMinimum.getX())
			controllerX.setMaximum(pBaseRotateRangeMaximum.getX())
			adef.addController(controllerX)
			
			var ADController controllerY = ADController.new()
			controllerY.setName(behavior.getControllerNameBaseRotateY())
			controllerY.setMinimum(pBaseRotateRangeMinimum.getY())
			controllerY.setMaximum(pBaseRotateRangeMaximum.getY())
			adef.addController(controllerY)
			
			// links
			var CurveBezier curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0, 0)
			curve.addPoint(DEMath.linearStep(rc.getX(), rmin.getX(), rmax.getX()),\
				DEMath.linearStep(0.0, amin.getX(), amax.getX()))
			curve.addPoint(1, 1)
			
			var ADLink linkX = ADLink.new()
			linkX.setController(controllerX)
			linkX.setCurve(curve)
			adef.addLink(linkX)
			
			curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0, 0)
			curve.addPoint(DEMath.linearStep(rc.getY(), rmin.getY(), rmax.getY()),\
				DEMath.linearStep(0.0, amin.getY(), amax.getY()))
			curve.addPoint(1, 1)
			
			var ADLink linkY = ADLink.new()
			linkY.setController(controllerY)
			linkY.setCurve(curve)
			adef.addLink(linkY)
			
			// add rules. rotate the base bone by the rotation angle and the guide bone by
			// the inverse rotation angle. this ensures the guide bone retains the orientation
			// it had before the base rotation
			var Matrix matrix = Matrix.newRotation(pCalibrateBaseRotateRotation)
			var ADRuleBoneTransformator rule
			
			if not boneRotateBack.empty()
				rule = ADRuleBoneTransformator.new()
				rule.setName(getName() + ".baseRotateXBack")
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setTargetBone(pCalibrateBaseRotateBone)
				rule.setUseAxis(true)
				rule.setAxis(matrix.getRightVector())
				rule.setMinimumAngle(-amin.getX())
				rule.setMaximumAngle(-amax.getX())
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkX))
				rule.addBone(boneRotateBack)
				adef.addRule(rule)
			end
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(getName() + ".baseRotateX")
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			rule.setTargetBone(pCalibrateBaseRotateBone)
			rule.setUseAxis(true)
			rule.setAxis(matrix.getRightVector())
			rule.setMinimumAngle(amin.getX())
			rule.setMaximumAngle(amax.getX())
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkX))
			rule.addBone(pBaseBone)
			adef.addRule(rule)
			
			if not boneRotateBack.empty()
				rule = ADRuleBoneTransformator.new()
				rule.setName(getName() + ".baseRotateYBack")
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setTargetBone(pCalibrateBaseRotateBone)
				rule.setUseAxis(true)
				rule.setAxis(matrix.getUpVector())
				rule.setMinimumAngle(-amin.getY())
				rule.setMaximumAngle(-amax.getY())
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkY))
				rule.addBone(boneRotateBack)
				adef.addRule(rule)
			end
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(getName() + ".baseRotateY")
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			rule.setTargetBone(pCalibrateBaseRotateBone)
			rule.setUseAxis(true)
			rule.setAxis(matrix.getUpVector())
			rule.setMinimumAngle(amin.getY())
			rule.setMaximumAngle(amax.getY())
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkY))
			rule.addBone(pBaseBone)
			adef.addRule(rule)
		end
		
		
		
		// add guide rule
		var bool useGuide = slotGuide != null and slotGuide.isDeviceAttached()
		
		if useGuide
			pADControllerGuideRotation = ADController.new()
			pADControllerGuideRotation.setName(behavior.getControllerNameGuideRotation())
			adef.addController(pADControllerGuideRotation)
			
			var ADLink linkGuideRotation = ADLink.new()
			linkGuideRotation.setController(pADControllerGuideRotation)
			adef.addLink(linkGuideRotation)
			
			pADRuleGuide = ADRuleInverseKinematic.new()
			pADRuleGuide.setName(getName())
			pADRuleGuide.setAdjustPosition(false)
			pADRuleGuide.setAdjustOrientation(true)
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.blendFactor, linkBlend))
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkGuideRotation))
			pADRuleGuide.addBone(pGuideBone)
			adef.addRule(pADRuleGuide)
		end
		
		
		
		// add pre-rotation rule
		if not pCalibratePreRotateBone.empty()
			var ModifiedRig.Bone bonePreRotate = modifyRig.addBone("preRotate")
			ignoreBones.add(bonePreRotate.name)
			
			var ADController controller = ADController.new()
			controller.setName(behavior.getControllerNamePreRotate())
			controller.setMinimum(-180)
			controller.setMaximum(180)
			adef.addController(controller)
			
			var ADLink link = ADLink.new()
			link.setController(controller)
			adef.addLink(link)
			
			// set rotator bone position to match guide bone position
			var ADRuleInverseKinematic ruleAlign = ADRuleInverseKinematic.new()
			ruleAlign.setName(getName() + ".preRotate")
			ruleAlign.setSolverBone(guideBone)
			ruleAlign.setUseSolverBone(true)
			ruleAlign.addBone(bonePreRotate.name)
			adef.addRule(ruleAlign)
			
			// set rotator bone orientation to match controller vector
			ruleAlign = ADRuleInverseKinematic.new()
			ruleAlign.setName(getName() + ".preRotate")
			ruleAlign.setAdjustPosition(false)
			ruleAlign.setAdjustOrientation(true)
			ruleAlign.addBone(bonePreRotate.name)
			ruleAlign.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, link))
			adef.addRule(ruleAlign)
			
			// rotate pre-rotate bone using rotator bone Z-axis and controller value as angle
			var ADRuleBoneTransformator ruleRotate = ADRuleBoneTransformator.new()
			ruleRotate.setName(getName() + ".preRotate")
			ruleRotate.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			ruleRotate.setTargetBone(bonePreRotate.name)
			ruleRotate.setMinimumRotation(Vector.new(0, 0, -180))
			ruleRotate.setMaximumRotation(Vector.new(0, 0, 180))
			ruleRotate.addBone(guideBone)
			ruleRotate.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
			adef.addRule(ruleRotate)
		end
		
		
		
		// add IK rule
		pADRuleIK = ADRuleInverseKinematic.new()
		pADRuleIK.setName(getName())
		pADRuleIK.setAdjustPosition(pAdjustPosition)
		pADRuleIK.setAdjustOrientation(true)
		
		pADRuleIK.setReachBone(pBaseBone)
		pADRuleIK.setReachRange(pCalibrateReachRange)
		
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.blendFactor, linkBlend))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTipPosition))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkTipOrientation))
		
		pADRuleIK.addBone(pTipBone)
		/*
		if useGuide and not pGuideBone.empty()
			var int index = pCalibrateBones.indexOf(pGuideBone)
			var String guideChainBase
			
			if index > 0
				guideChainBase = pCalibrateBones.getAt(index - 1) cast String
			end
			
			if guideChainBase != null and not guideChainBase.equals(pTipBone)
				pADRuleIK.addBone(guideChainBase)
			end
			
		else
		*/
			if useBaseRotate
				pADRuleIK.addBone(guideBone)
				
			elif not pBaseBone.equals(pTipBone)
				pADRuleIK.addBone(pBaseBone)
			end
// 		end
		
		adef.addRule(pADRuleIK)
		
		
		
		// add twist rules
		var bool useTwist = pTwistBoneCount > 0 and pTwistPropagation > 0.01 and boneCount >= 2
		var bool useGuideTwist = not pGuideBone.empty() and not pTipBone.empty() and pGuideTwistStrength > 0.01
		var float maxTwistAngle = 180
		var ADLink linkTwist
		
		if useTwist or useGuideTwist
			pADControllerTwist = ADController.new()
			pADControllerTwist.setName(behavior.getControllerNameTwist())
			pADControllerTwist.setMinimum(-maxTwistAngle)
			pADControllerTwist.setMaximum(maxTwistAngle)
			adef.addController(pADControllerTwist)
			
			linkTwist = ADLink.new()
			linkTwist.setController(pADControllerTwist)
			adef.addLink(linkTwist)
		end
		
		if useGuideTwist
			// add bone to be used as rotator bone
			var float angle = maxTwistAngle * pGuideTwistStrength
			var ModifiedRig.Bone boneTwistAxis = modifyRig.addBone("guideTwistAxis")
			ignoreBones.add(boneTwistAxis.name)
			
			var ADController controllerGuideTwistAxis = ADController.new()
			controllerGuideTwistAxis.setName(behavior.getControllerNameGuideTwistAxis())
			adef.addController(controllerGuideTwistAxis)
			
			var ADLink linkGuideTwistAxis = ADLink.new()
			linkGuideTwistAxis.setController(controllerGuideTwistAxis)
			adef.addLink(linkGuideTwistAxis)
			
			var ADRuleInverseKinematic ruleAlign = ADRuleInverseKinematic.new()
			ruleAlign.setName(getName() + ".guideTwist")
			ruleAlign.setSolverBone(pGuideBone)
			ruleAlign.setUseSolverBone(true)
			ruleAlign.addBone(boneTwistAxis.name)
			adef.addRule(ruleAlign)
			
			ruleAlign = ADRuleInverseKinematic.new()
			ruleAlign.setName(getName() + ".guideTwist")
			ruleAlign.setAdjustOrientation(true)
			ruleAlign.setAdjustPosition(false)
			ruleAlign.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkGuideTwistAxis))
			ruleAlign.addBone(boneTwistAxis.name)
			adef.addRule(ruleAlign)
			
			// apply rotation using the rotator bone
			var ADRuleBoneTransformator rule = ADRuleBoneTransformator.new()
			rule.setName(getName() + ".guideTwist")
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			rule.setTargetBone(boneTwistAxis.name)
			rule.setUseAxis(true)
			rule.setMinimumAngle(-angle)
			rule.setMaximumAngle(angle)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkTwist))
			rule.addBone(pGuideBone)
			adef.addRule(rule)
			
			// cancel rotation on tip bone
			rule = ADRuleBoneTransformator.new()
			rule.setName(getName() + ".guideTwist")
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			rule.setTargetBone(boneTwistAxis.name)
			rule.setUseAxis(true)
			rule.setMinimumAngle(angle)
			rule.setMaximumAngle(-angle)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkTwist))
			rule.addBone(pTipBone)
			adef.addRule(rule)
		end
		
		if useTwist
			var int count = DEMath.min(pTwistBoneCount, boneCount - 1)
			var String name = getName() + ".twist"
			var ADRuleBoneTransformator rule
			var int i
			
			var float angle = pTwistPropagation * maxTwistAngle / count
			var int baseIndex = count
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var Vector axis = pCalibrateTwistAxes.getAt(i) cast Vector
				var float realAngle = angle * (i + 1)
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setTargetBone(bone)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(realAngle)
				rule.setMaximumAngle(-realAngle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkTwist))
				rule.addBone(pCalibrateBones.getAt(baseIndex - i - 1) cast String)
				adef.addRule(rule)
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setTargetBone(bone)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(-realAngle)
				rule.setMaximumAngle(realAngle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkTwist))
				rule.addBone(bone)
				adef.addRule(rule)
			end
		end
		
		
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
			recordAnimation.addIgnoreBones(ignoreBones)
		end
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pADControllerTipPosition = null
		pADControllerTipOrientation = null
		pADControllerGuideRotation = null
		pADControllerTwist = null
		pADControllerRetracted = null
		pADControllerBlend = null
		
		pADRuleGuide = null
		pADRuleIK = null
		pADRuleBaseIK = null
		pADRuleRetracted = null
		
		pTipTracker.resetTransform()
		pGuideTracker.resetTransform()
		pBaseTracker.resetTransform()
		
		pCalibrateReach = 0.6
		pCalibrateReachScale = 1
		pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
		pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
		pCalibrateReachRange = 0
		pCalibrateReachRetracted = 1
		pCalibrateBones.removeAll()
		pCalibrateTwistAxes.removeAll()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateReachRotation = Vector.new()
		pCalibrateReachScaleFront = 0
		pCalibrateReachScaleDown = 0
		pCalibrateReachScaleUp = 0
		pCalibrateCanTweakReachScale = false
		pCalibrateMatrixRelocateTip = Matrix.new()
		pCalibratePreRotateBone = ""
		pCalibrateBaseRotateRotation = Vector.new()
		pCalibrateBaseRotateBone = ""
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		var Rig rig = component.getRig()
		findBoneChain(rig, pTipBone, pBaseBone, pCalibrateBones)
		if pCalibrateBones.getCount() == 0
			return
		end
		
		var String baseBone = "", guideBone = ""
		if pCalibrateBones.getCount() >= 2
			baseBone = pBaseBone
			guideBone = pGuideBone
		end
		
		if guideBone.empty()
			guideBone = baseBone
		end
		
		// prepare tracker slots
		pTipTracker.resolveRealSlot(config)
		pTipTracker.setTransform(config, component, pTipBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(config, component, guideBone)
		
		// get tracker slots. has to come after resolving tracker slots
		var CharacterTrackerSlot slotGuide
		if not pGuideTracker.getSlot().empty()
			slotGuide = config.getTrackerSlots().getNamed(pGuideTracker.getSlot())
		end
		
		var bool useGuide = slotGuide != null and slotGuide.isDeviceAttached()
		
		// pre-rotate bone is the guide bone if no tracker is attached to the guide slot or
		// the bone after the guide bone if a tracker is attached
		if useGuide
			if guideBone.equals(pTipBone)
				pCalibratePreRotateBone = ""
				
			else
				pCalibratePreRotateBone = pCalibrateBones.getAt(pCalibrateBones.indexOf(guideBone) - 1) cast String
			end
			
		else
			pCalibratePreRotateBone = guideBone
		end
		
		// find bone indices
		var int indexBase = -1, indexGuide = -1, indexTip = -1
		if not baseBone.empty() and not pTipBone.empty()
			indexBase = component.indexOfBoneNamed(baseBone)
			indexGuide = component.indexOfBoneNamed(guideBone)
			indexTip = component.indexOfBoneNamed(pTipBone)
		end
		
		// calculate reach of IK chain to avoid over stretching
		if indexBase != -1 and indexTip != -1
			var Matrix baseMatrix = component.boneGetMatrix(indexBase)
			var Matrix tipMatrix = component.boneGetMatrix(indexTip)
			
			var CharacterTrackerSlot slotBase = pBaseTracker.getRealSlot()
			var CharacterTrackerSlot slotTip = pTipTracker.getRealSlot()
			
			var Vector posBase = baseMatrix.getPosition()
			var Vector posTip = tipMatrix.getPosition()
			
			select pActorReach
			case ActorReach.arm
				// actor arm reach parameter matches tracker target not target bone
				if slotTip != null
					// matrix = bone * transform^-1 * (ref * slot^1) * (target * ref^-1)
					posTip = config.characterToComponent(\
						(pTipTracker.getOffsetMatrix() * slotTip.getTargetMatrix()).getPosition())
				end
				
				// along Z direction this is always 1.
				// along X and Y direction the scaling has to be adjusted. this is due
				// to the character shoulder joint usually not lining up with the actor
				// shoulder joint. here though the spine attachment point is usually used
				// as the base of the IK chain. this has the advantage that with the
				// actor the spine attachment point is pretty much at the center of the
				// actor. this way the location of the character spine attachment point
				// becomes the pivot point. the length from the pivot point to the
				// character center is fixed. the remaining length has to make a turn
				// to reach the IK point. this length has to be matched with the length
				// from the turned IK point to the spine attachment point.
				
				// the reach front can be calculate by using a shortening of the calibrate
				// reach. this can be done using a fudge factor but that can be wrong.
				// another solution is to consider the base bone as the shoulder bone
				// which does not full rotate. the length of all other bones indicates
				// the maximum reach if the shoulder bone does not rotate. using the
				// length of the shoulder bone and a maximum rotation range for
				// forward/backward and up/down the actual reach can be calculated.
				// we can use the guide bone for this
				
				var Vector posRotate = posBase.absolute()
				var Vector tipFront, tipDown
				
				if indexGuide != -1 and indexGuide != indexBase
					posRotate = component.boneGetMatrix(indexGuide).getPosition().absolute()
				end
				
				var float reachBasePos = posBase.absolute().getX()
				var float reachRotateTip = (posTip.absolute() - posRotate).getLength()
				var float reachBaseRotate = (posRotate - posBase.absolute()).getLength()  // can be 0
				var float tip, actorTip
				
				// reach scaling
				var float actorShoulderReach = config.actorToComponent(actorProfile.getShoulderWidth() / 2)
				var float actorArmReach = config.actorToComponent(actorProfile.getArmLength())
				var float actorReach = actorShoulderReach + actorArmReach
				
				if pTipTracker.getRealSlot() != null
					actorReach = config.characterToComponent((pTipTracker.getOffsetMatrix()\
						* pTipTracker.getRealSlot().getCalibrateMatrix()).getPosition()).absolute().getX()
					actorArmReach = actorReach - actorShoulderReach
				end
				
				pCalibrateReach = reachBaseRotate + reachRotateTip
				pCalibrateReachScale = pCalibrateReach / (actorReach - reachBasePos)
					GameApp.getGameApp().getConsole().addMessage("ActorReach ar=" + actorReach + " aar=" + actorArmReach\
						+ " cr=" + pCalibrateReach + " (rbr=" + reachBaseRotate + " rrt=" + reachRotateTip + " rbp=" + reachBasePos +")"\
						+ " rs=" + pCalibrateReachScale)
				
				// front, back
				tip = reachRotateTip + reachBaseRotate * DEMath.sin(DEMath.fabs(pBaseRotateAngleMaximum.getY()))
				actorTip = actorArmReach
				
				pCalibrateReachScaleFront = (tip / actorTip) / pCalibrateReachScale
// 				pCalibrateReachScaleFront = tip / pCalibrateReach
				
				// down
				tip = reachRotateTip + reachBaseRotate * DEMath.sin(DEMath.fabs(pBaseRotateAngleMinimum.getX()))
				actorTip = actorArmReach
				
				pCalibrateReachScaleDown = (tip / actorTip) / pCalibrateReachScale
// 				pCalibrateReachScaleDown = tip / pCalibrateReach
					GameApp.getGameApp().getConsole().addMessage("Down tip=" + tip + " atip="\
						+ actorTip + "(" + (actorTip * pCalibrateReachScale) + ")")
				
				// up
				tip = reachRotateTip + reachBaseRotate * DEMath.sin(DEMath.fabs(pBaseRotateAngleMaximum.getX()))
				actorTip = actorArmReach
				
				pCalibrateReachScaleUp = (tip / actorTip) / pCalibrateReachScale
// 				pCalibrateReachScaleUp = tip / pCalibrateReach
					GameApp.getGameApp().getConsole().addMessage("Up tip=" + tip + " atip="\
						+ actorTip + "(" + (actorTip * pCalibrateReachScale) + ")")
				
				// store direction specific scale
				pCalibrateReachScaleDirection = Vector.new(pCalibrateReachScaleFront,\
					pCalibrateReachScaleUp, 1).compMultiply(pReachScaling)
				
				pCalibrateReachScaleDirectionBack = Vector.new(pCalibrateReachScaleFront,\
					pCalibrateReachScaleDown, 1).compMultiply(pReachScalingBack)
				
				pCalibrateCanTweakReachScale = true
				
			case ActorReach.leg
				// reach scale is not working well with legs
//	 				pCalibrateReachScale = pCalibrateReach / (actorProfile.getLegLength() * config.getCalibrateScale())
				pCalibrateReach = (posTip - posBase).getLength()
				pCalibrateReachScale = 1
				pCalibrateReachScaleFront = 1
				pCalibrateReachScaleDown = 1
				pCalibrateReachScaleUp = 1
				pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
				pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
				
			else
				pCalibrateReach = (posTip - posBase).getLength()
				pCalibrateReachScale = 1
				pCalibrateReachScaleFront = 1
				pCalibrateReachScaleDown = 1
				pCalibrateReachScaleUp = 1
				pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
				pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
			end
			
			if slotTip != null and pRelocateTip
				var Matrix matrixBase = component.boneGetMatrix(indexBase)
				var Matrix matrixBaseInv = component.boneGetInverseMatrix(indexBase)
				var Vector positionTarget = config.characterToComponent(slotTip.getTargetPosition())
				var Vector positionReference = config.characterToComponent(slotTip.getCalibrateReferenceMatrix().getPosition())
				
				var Vector targetInBase = matrixBaseInv * positionTarget
				var Vector referenceInBase = matrixBaseInv * positionReference
				
				var Vector normalTargetInbase = targetInBase.normalize()
				var Vector projReferenceInBase = normalTargetInbase * (normalTargetInbase * referenceInBase)
				
				var Vector projReference = matrixBase.transformNormal(projReferenceInBase)
				
				var Vector pivot = positionReference - projReference
				
				pCalibrateMatrixRelocateTip = Matrix.newTranslation(-pivot) * matrixBaseInv.getRotation()
				
			else
				pCalibrateMatrixRelocateTip = Matrix.new()
				//pCalibrateReachScale = 1
				//pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
				//pCalibrateGuideUpAxis = ARTrackToAxis.posY
			end
			
			// reach range is only used if base tracker is set
			if slotBase != null
				pCalibrateReachRange = pCalibrateReach
				
			else
				pCalibrateReachRange = 0
			end
			
		else
			pCalibrateReach = 0.6
			pCalibrateReachScale = 1
			pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
			pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
			pCalibrateReachRange = 0
			pCalibrateReachRetracted = pCalibrateReach
			pCalibrateMatrixRelocateTip = Matrix.new()
		end
		
		// calibrate guide tracker. has to come after reach scaling since it uses this value
		pGuideTracker.resolveRealSlot(config)
		pGuideTracker.setTransform(config, component, guideBone)
		
		// calculate retracted reach if used
		if not pMoveRetracted.empty() and indexGuide != -1 and indexTip != -1
			// create a temporary component so we can apply the move and do some measuring
			var Component tcomponent = Component.new(component.getModel(), component.getSkin())
			tcomponent.setRig(rig)
			
			var CharacterAppearance appearance = config.getProfile().getAppearance()
			var Animator tanimator = Animator.new()
			tanimator.setRig(rig)
			tanimator.setAnimation(appearance.getAnimation())
			
			var ARAnimation rule = ARAnimation.new()
			rule.setMoveName(pMoveRetracted)
			tanimator.addRule(rule)
			
			var AnimatorInstance tainst = AnimatorInstance.new()
			tainst.setAnimator(tanimator)
			tainst.setComponent(tcomponent)
			tainst.applyDirect()
			tcomponent.updateBones()
			
			// measure the reach and store it
			var Vector posRoot = tcomponent.boneGetMatrix(indexGuide).getPosition()
			var Vector posTip = tcomponent.boneGetMatrix(indexTip).getPosition()
			
			pCalibrateReachRetracted = (posTip - posRoot).getLength()
		end
		
		// calculate twist axes
		if pTwistBoneCount > 0 and pTwistPropagation > 0.01
			var int count = DEMath.min(pTwistBoneCount, pCalibrateBones.getCount() - 1)
			var Vector axis = Matrix.newRotation(pTwistAxisRotation).getViewVector()
			var int i, baseIndex = count
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				if indexBone != -1
					pCalibrateTwistAxes.add(component.boneGetInverseMatrix(indexBone).normalize().transformNormal(axis))
					
				else
					pCalibrateTwistAxes.add(Vector.new(0, 0, 1))
				end
			end
		end
		
		if indexTip != -1
			pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pTwistAxisRotation) \
				* component.boneGetInverseMatrix(indexTip).normalize()).getEulerAngles()
		end
		
		if indexBase != -1
			pCalibrateReachRotation = (Matrix.newRotation(pTwistAxisRotation)\
				* component.boneGetInverseMatrix(indexBase).normalize()).getEulerAngles()
			
			var int indexBaseParent = rig.boneGetParent(indexBase)
			
			if indexBaseParent != -1
				pCalibrateBaseRotateBone = rig.boneGetName(indexBaseParent)
				pCalibrateBaseRotateRotation = (Matrix.newRotation(pTwistAxisRotation) \
					* component.boneGetInverseMatrix(indexBaseParent).normalize()).getEulerAngles()
				
			else
				pCalibrateBaseRotateBone = ""
				pCalibrateBaseRotateRotation = Vector.new()
			end
			
		else
			pCalibrateReachRotation = pTwistAxisRotation
		end
	end
	
	public func void tweaked()
		if pCalibrateCanTweakReachScale
			select pActorReach
			case ActorReach.arm
				pCalibrateReachScaleDirection = Vector.new(pCalibrateReachScaleFront,\
					pCalibrateReachScaleUp, 1).compMultiply(pReachScaling)
				
				pCalibrateReachScaleDirectionBack = Vector.new(pCalibrateReachScaleFront,\
					pCalibrateReachScaleDown, 1).compMultiply(pReachScalingBack)
			end
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferIK.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("tipBone")
				setTipBone(element.getFirstCData())
				
			elif tagName.equals("baseBone")
				setBaseBone(element.getFirstCData())
				
			elif tagName.equals("guideBone")
				setGuideBone(element.getFirstCData())
				
			elif tagName.equals("tipTracker")
				pTipTracker.load(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("actorReach")
				setActorReach(ActorReach.named(element.getFirstCData()))
				
			elif tagName.equals("reachLimit")
				setReachLimit(element.getFirstCDataFloat())
				
			elif tagName.equals("reachScaling")
				pReachScaling = loader.readVector(element)
				
			elif tagName.equals("reachScalingBack")
				pReachScalingBack = loader.readVector(element)
				
			elif tagName.equals("adjustPosition")
				setAdjustPosition(element.getFirstCDataBool())
				
			elif tagName.equals("moveBaseIK")
				setMoveBaseIK(element.getFirstCData())
				
			elif tagName.equals("moveRetracted")
				setMoveRetracted(element.getFirstCData())
				
			elif tagName.equals("twistPropagation")
				setTwistPropagation(element.getFirstCDataFloat())
				
			elif tagName.equals("twistBoneCount")
				setTwistBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("twistAxisRotation")
				setTwistAxisRotation(loader.readVector(element))
				
			elif tagName.equals("guideTwistStrength")
				setGuideTwistStrength(element.getFirstCDataFloat())
				
			elif tagName.equals("relocateTip")
				setRelocateTip(element.getFirstCDataBool())
				
			elif tagName.equals("baseRotateRangeCenter")
				setBaseRotateRangeCenter(loader.readVector2(element))
				
			elif tagName.equals("baseRotateRangeMinimum")
				setBaseRotateRangeMinimum(loader.readVector2(element))
				
			elif tagName.equals("baseRotateRangeMaximum")
				setBaseRotateRangeMaximum(loader.readVector2(element))
				
			elif tagName.equals("baseRotateAngleMinimum")
				setBaseRotateAngleMinimum(loader.readVector2(element))
				
			elif tagName.equals("baseRotateAngleMaximum")
				setBaseRotateAngleMaximum(loader.readVector2(element))
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	public func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("reach")
				pCalibrateReach = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScale")
				pCalibrateReachScale = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScaleDirection")
				pCalibrateReachScaleDirection = loader.readVector(element)
				
			elif tagName.equals("reachScaleDirectionBack")
				pCalibrateReachScaleDirectionBack = loader.readVector(element)
				
			elif tagName.equals("reachScaleFront")
				pCalibrateReachScaleFront = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScaleDown")
				pCalibrateReachScaleDown = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScaleUp")
				pCalibrateReachScaleUp = element.getFirstCDataFloat()
				
			elif tagName.equals("reachRange")
				pCalibrateReachRange = element.getFirstCDataFloat()
				
			elif tagName.equals("reachRotation")
				pCalibrateReachRotation = loader.readVector(element)
				
			elif tagName.equals("matrixRelocateTip")
				pCalibrateMatrixRelocateTip = GameApp.getGameApp().getLoadCharacterProfile().readMatrix(element)
				
			elif tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("tipTracker")
				pTipTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("reachRetracted")
				pCalibrateReachRetracted = element.getFirstCDataFloat()
				
			elif tagName.equals("twistAxis")
				pCalibrateTwistAxes.add(loader.readVector(element))
				
			elif tagName.equals("twistBoneAxisRotation")
				pCalibrateTwistBoneAxisRotation = loader.readVector(element)
				
			elif tagName.equals("canTweakReachScale")
				pCalibrateCanTweakReachScale = element.getFirstCDataBool()
				
			elif tagName.equals("preRotateBone")
				pCalibratePreRotateBone = element.getFirstCData()
				
			elif tagName.equals("baseRotateRotation")
				pCalibrateBaseRotateRotation = loader.readVector(element)
				
			elif tagName.equals("baseRotateBone")
				pCalibrateBaseRotateBone = element.getFirstCData()
			end
		end)
	end
	
	/** Post load initialize. */
	public func void postLoadInit(CharacterConfiguration config)
		pTipTracker.resolveRealSlot(config)
		pGuideTracker.resolveRealSlot(config)
		pBaseTracker.resolveRealSlot(config)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("tipBone", pTipBone)
		tag.addDataTag("baseBone", pBaseBone)
		tag.addDataTag("guideBone", pGuideBone)
		pTipTracker.save(loader, tag.addTag("tipTracker"))
		pGuideTracker.save(loader, tag.addTag("guideTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		tag.addDataTag("actorReach", pActorReach.name())
		tag.addDataTag("reachLimit", pReachLimit)
		loader.writeVector(tag, "reachScaling", pReachScaling)
		loader.writeVector(tag, "reachScalingBack", pReachScalingBack)
		tag.addDataTag("adjustPosition", pAdjustPosition)
		tag.addDataTag("moveBaseIK", pMoveBaseIK)
		tag.addDataTag("moveRetracted", pMoveRetracted)
		tag.addDataTag("twistPropagation", pTwistPropagation)
		tag.addDataTag("twistBoneCount", pTwistBoneCount)
		loader.writeVector(tag, "twistAxisRotation", pTwistAxisRotation)
		tag.addDataTag("guideTwistStrength", pGuideTwistStrength)
		tag.addDataTag("relocateTip", pRelocateTip)
		loader.writeVector2(tag, "baseRotateRangeCenter", pBaseRotateRangeCenter)
		loader.writeVector2(tag, "baseRotateRangeMinimum", pBaseRotateRangeMinimum)
		loader.writeVector2(tag, "baseRotateRangeMaximum", pBaseRotateRangeMaximum)
		loader.writeVector2(tag, "baseRotateAngleMinimum", pBaseRotateAngleMinimum)
		loader.writeVector2(tag, "baseRotateAngleMaximum", pBaseRotateAngleMaximum)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	public func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("reach", pCalibrateReach)
		tag.addDataTag("reachScale", pCalibrateReachScale)
		loader.writeVector(tag, "reachScaleDirection", pCalibrateReachScaleDirection)
		loader.writeVector(tag, "reachScaleDirectionBack", pCalibrateReachScaleDirectionBack)
		tag.addDataTag("reachScaleFront", pCalibrateReachScaleFront)
		tag.addDataTag("reachScaleDown", pCalibrateReachScaleDown)
		tag.addDataTag("reachScaleUp", pCalibrateReachScaleUp)
		tag.addDataTag("reachRange", pCalibrateReachRange)
		loader.writeVector(tag, "reachRotation", pCalibrateReachRotation)
		GameApp.getGameApp().getLoadCharacterProfile().writeMatrix(tag, "matrixRelocateTip", pCalibrateMatrixRelocateTip)
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTipTracker.saveCalibrated(loader, tag.addTag("tipTracker"))
		pGuideTracker.saveCalibrated(loader, tag.addTag("guideTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("baseTracker"))
		tag.addDataTag("reachRetracted", pCalibrateReachRetracted)
		pCalibrateTwistAxes.forEach(block Vector each
			loader.writeVector(tag, "twistAxis", each)
		end)
		loader.writeVector(tag, "twistBoneAxisRotation", pCalibrateTwistBoneAxisRotation)
		tag.addDataTag("canTweakReachScale", pCalibrateCanTweakReachScale)
		tag.addDataTag("preRotateBone", pCalibratePreRotateBone)
		loader.writeVector(tag, "baseRotateRotation", pCalibrateBaseRotateRotation)
		tag.addDataTag("baseRotateBone", pCalibrateBaseRotateBone)
	end
end
