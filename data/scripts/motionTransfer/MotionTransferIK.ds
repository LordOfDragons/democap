/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer using Inverse Kinematic.
 * 
 * Defines root bone and tip bone name. This defines the bone chain to manipulate.
 * The tip bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 2 or more bones.
 * 
 * Defines the tracker slot to be used to set the tip bone position before applying
 * inverse kinematic. During calibration the coordinate system of the tracker slot
 * relative to the tip bone coordinate system is stored. Custom position and rotation
 * offsets can be applied to fine tune the result if slightly off.
 * 
 * Optionally a guide tracker slot can be defined which is used to guide the orientation
 * of the root bone before applying inverse kinematics. This is used for example to guide
 * the elbow on an arm while shoulder and hand remain at equal position and orientation.
 */
class MotionTransferIK extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "ik"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferIK.new(factoryID())
		end
		
		public func String displayName()
			return "Inverse Kinematic"
		end
	end
	
	/** Actor reach type. */
	enum ActorReach
		none //<! No actor reach. Use unscaled reach
		arm //<! Use actor arm length as reach
		leg //<! Use actor leg length as reach
	end
	
	
	
	private var String pTipBone
	private var String pBaseBone
	private var String pGuideBone
	private var MotionTransferTracker pTipTracker
	private var MotionTransferTracker pGuideTracker
	private var MotionTransferTracker pBaseTracker
	private var ActorReach pActorReach
	private var float pReachLimit
	private var Vector pReachScaling
	private var bool pAdjustPosition
	private var String pMoveBaseIK
	private var String pMoveRetracted
	private var float pTwistPropagation
	private var int pTwistBoneCount
	private var Vector pTwistAxisRotation
	private var float pGuideZeroRotation
	private var float pGuideScaleRotation
	
	private var ADController pADControllerTipPosition
	private var ADController pADControllerTipOrientation
	private var ADController pADControllerGuidePosition
	private var ADController pADControllerGuideRotation
	private var ADController pADControllerTwist
	private var ADController pADControllerRetracted
	private var ADController pADControllerBlend
	
	private var ADRuleBoneTransformator pADRuleGuide
	private var ADRuleInverseKinematic pADRuleIK
	private var ADRuleInverseKinematic pADRuleIKForce
	private var ADRuleAnimation pADRuleBaseIK
	private var ADRuleAnimation pADRuleRetracted
	
	private var Array pCalibrateBones
	private var float pCalibrateReach
	private var float pCalibrateReachScale
	private var Vector pCalibrateReachScaleDirection
	private var float pCalibrateReachRange
	private var Vector pCalibrateTipOffset
	private var float pCalibrateReachRetracted
	private var Array pCalibrateTwistAxes
	private var Vector pCalibrateTwistBoneAxisRotation
	private var Vector pCalibrateGuideLocalPosition
	private var float pCalibrateGuideRotation
	private var ARTrackToUp pCalibrateGuideRotationAxis
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTipBone = ""
		pBaseBone = ""
		pGuideBone = ""
		pTipTracker = MotionTransferTracker.new()
		pGuideTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pActorReach = ActorReach.none
		pReachLimit = 1
		pReachScaling = Vector.new(1, 1, 1)
		pAdjustPosition = true
		pMoveBaseIK = ""
		pMoveRetracted = ""
		pTwistPropagation = 0
		pTwistBoneCount = 0
		pTwistAxisRotation = Vector.new()
		pGuideZeroRotation = 0
		pGuideScaleRotation = 1
		pCalibrateBones = Array.new()
		pCalibrateReach = 0.6
		pCalibrateReachScale = 1
		pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
		pCalibrateReachRange = 0
		pCalibrateReachRetracted = 1
		pCalibrateTipOffset = Vector.new()
		pCalibrateTwistAxes = Array.new()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateGuideLocalPosition = Vector.new()
		pCalibrateGuideRotation = 0
		pCalibrateGuideRotationAxis = ARTrackToUp.trackBoneZ
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferIK transfer) super(transfer)
		pTipBone = transfer.pTipBone
		pBaseBone = transfer.pBaseBone
		pGuideBone = transfer.pGuideBone
		pTipTracker = MotionTransferTracker.new(transfer.pTipTracker)
		pGuideTracker = MotionTransferTracker.new(transfer.pGuideTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pActorReach = transfer.pActorReach
		pReachLimit = transfer.pReachLimit
		pReachScaling = transfer.pReachScaling
		pAdjustPosition = transfer.pAdjustPosition
		pMoveBaseIK = transfer.pMoveBaseIK
		pMoveRetracted = transfer.pMoveRetracted
		pTwistPropagation = transfer.pTwistPropagation
		pTwistBoneCount = transfer.pTwistBoneCount
		pTwistAxisRotation = transfer.pTwistAxisRotation
		pGuideZeroRotation = transfer.pGuideZeroRotation
		pGuideScaleRotation = transfer.pGuideScaleRotation
		pCalibrateBones = Array.new(transfer.pCalibrateBones)
		pCalibrateReach = transfer.pCalibrateReach
		pCalibrateReachScale = transfer.pCalibrateReachScale
		pCalibrateReachScaleDirection = transfer.pCalibrateReachScaleDirection
		pCalibrateReachRange = transfer.pCalibrateReachRange
		pCalibrateReachRetracted = transfer.pCalibrateReachRetracted
		pCalibrateTipOffset = transfer.pCalibrateTipOffset
		pCalibrateTwistAxes = Array.new(transfer.pCalibrateTwistAxes)
		pCalibrateTwistBoneAxisRotation = transfer.pCalibrateTwistBoneAxisRotation
		pCalibrateGuideLocalPosition = transfer.pCalibrateGuideLocalPosition
		pCalibrateGuideRotation = transfer.pCalibrateGuideRotation
		pCalibrateGuideRotationAxis = transfer.pCalibrateGuideRotationAxis
	end
	
	
	
	/** Tip bone name. */
	public func String getTipBone()
		return pTipBone
	end
	
	/** Set tip bone name. */
	public func void setTipBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTipBone = bone
	end
	
	/** Base bone name. */
	public func String getBaseBone()
		return pBaseBone
	end
	
	/** Set base bone name. */
	public func void setBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pBaseBone = bone
	end
	
	/** Guide bone name. */
	public func String getGuideBone()
		return pGuideBone
	end
	
	/** Set guide bone name. */
	public func void setGuideBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pGuideBone = bone
	end
	
	/** Tip tracker. */
	public func MotionTransferTracker getTipTracker()
		return pTipTracker
	end
	
	/** Guide tracker. */
	public func MotionTransferTracker getGuideTracker()
		return pGuideTracker
	end
	
	/** Reach tracker. */
	public func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Actor reach to use to scale reach length. */
	public func ActorReach getActorReach()
		return pActorReach
	end
	
	/** Set actor reach to use to scale reach length. */
	public func void setActorReach(ActorReach actorReach)
		if actorReach == null
			throw ENullPointer.new("actorReach")
		end
		pActorReach = actorReach
	end
	
	/** Limit reach to percentage of bone chain reach. */
	public func float getReachLimit()
		return pReachLimit
	end
	
	/** Set limit reach to percentage of bone chain reach. */
	public func void setReachLimit(float limit)
		pReachLimit = DEMath.max(limit, 0.1)
	end
	
	/** Reach scaling along axis for fine tune. */
	public func Vector getReachScaling()
		return pReachScaling
	end
	
	/** Set reach scaling along axis for fine tuning. */
	public func void setReachScaling(Vector scaling)
		if scaling == null
			throw ENullPointer.new("scaling")
		end
		pReachScaling = scaling
	end
	
	/** Adjust position if chain is of length 1. */
	public func bool getAdjustPosition()
		return pAdjustPosition
	end
	
	/** Set adjust position if chain is of length 1. */
	public func void setAdjustPosition(bool adjust)
		pAdjustPosition = adjust
	end
	
	/** Name of move to use to init base IK state for better results. */
	public func String getMoveBaseIK()
		return pMoveBaseIK
	end
	
	/** Set name of move to use to init base IK state for better results. */
	public func void setMoveBaseIK(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveBaseIK = move
	end
	
	/** Name of move to use to init retracted pose for better results. */
	public func String getMoveRetracted()
		return pMoveRetracted
	end
	
	/** Set name of move to use to init retracted pose for better results. */
	public func void setMoveRetracted(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveRetracted = move
	end
	
	/** Percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func float getTwistPropagation()
		return pTwistPropagation
	end
	
	/** Set percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func void setTwistPropagation(float amount)
		pTwistPropagation = DEMath.max(amount, 0.0)
	end
	
	/** Count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func int getTwistBoneCount()
		return pTwistBoneCount
	end
	
	/** Set count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func void setTwistBoneCount(int count)
		if count < 0
			throw EInvalidParam.new("count < 0")
		end
		pTwistBoneCount = count
	end
	
	/** Rotation of twist axis relative to tip bone. */
	public func Vector getTwistAxisRotation()
		return pTwistAxisRotation
	end
	
	/** Set rotation of twist axis relative to tip bone. */
	public func void setTwistAxisRotation(Vector rotation)
		if rotation == null
			throw ENullPointer.new("rotation")
		end
		pTwistAxisRotation = rotation
	end
	
	/** Guide zero rotation. */
	public func float getGuideZeroRotation()
		return pGuideZeroRotation
	end
	
	/** Set guide zero rotation. */
	public func void setGuideZeroRotation(float rotation)
		pGuideZeroRotation = rotation
	end
	
	/** Guide scale rotation. */
	public func float getGuideScaleRotation()
		return pGuideScaleRotation
	end
	
	/** Set guide scale rotation. */
	public func void setGuideScaleRotation(float scale)
		pGuideScaleRotation = scale
	end
	
	
	
	/** Animator definition rule or null. */
	public func ADRuleInverseKinematic getADRuleIK()
		return pADRuleIK
	end
	
	public func ADRuleBoneTransformator getADRuleGuide()
		return pADRuleGuide
	end
	
	public func ADRuleAnimation getADRuleBaseIK()
		return pADRuleBaseIK
	end
	
	/** Calibrate reach. */
	public func float getCalibrateReach()
		return pCalibrateReach
	end
	
	/** Calibrate reach scale. */
	public func float getCalibrateReachScale()
		return pCalibrateReachScale
	end
	
	/** Calibrate reach scale per direction. */
	public func Vector getCalibrateReachScaleDirection()
		return pCalibrateReachScaleDirection
	end
	
	/** Calibrate reach range or 0 if disabled. */
	public func float getCalibrateReachRange()
		return pCalibrateReachRange
	end
	
	/** Calibrate tip offset. */
	public func Vector getCalibrateTipOffset()
		return pCalibrateTipOffset
	end
	
	/** Calibrate twist bone axis rotation. */
	public func Vector getCalibrateTwistBoneAxisRotation()
		return pCalibrateTwistBoneAxisRotation
	end
	
	/** Calibrate guide local position. */
	public func Vector getCalibrateGuideLocalPosition()
		return pCalibrateGuideLocalPosition
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass, ModifiedRig modifyRig)
		pADControllerTipPosition = null
		pADControllerTipOrientation = null
		pADControllerGuidePosition = null
		pADControllerGuideRotation = null
		pADControllerRetracted = null
		pADControllerTwist = null
		pADControllerBlend = null
		pADRuleIK = null
		pADRuleIKForce = null
		pADRuleGuide = null
		pADRuleBaseIK = null
		pADRuleRetracted = null
		
		// add behavior
		var ECBMotionTransferIK behavior = ECBMotionTransferIK.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTip, slotGuide, slotReach
		if not pTipTracker.getSlot().empty()
			slotTip = config.getTrackerSlots().getNamed(pTipTracker.getSlot())
		end
		if not pGuideTracker.getSlot().empty()
			slotGuide = config.getTrackerSlots().getNamed(pGuideTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotReach = config.getTrackerSlots().getNamed(pBaseTracker.getSlot())
		end
		
		var int boneCount = pCalibrateBones.getCount()
		if slotTip == null or boneCount < 1 or pTipBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		
		var String guideBone = pGuideBone.empty() if pBaseBone else pGuideBone
		
		// add base IK rules
		if not pMoveBaseIK.empty()
			pADRuleBaseIK = ADRuleAnimation.new()
			pADRuleBaseIK.setName(getName() + ".baseIK")
			pADRuleBaseIK.setMoveName(pMoveBaseIK)
			pCalibrateBones.forEach(block String each
				pADRuleBaseIK.addBone(each)
			end)
			adef.addRule(pADRuleBaseIK)
		end
		
		// add retracted rules
		if not pMoveRetracted.empty()
			pADControllerRetracted = ADController.new()
			pADControllerRetracted.setName(behavior.getControllerNameRetracted())
			pADControllerRetracted.setMinimum(pCalibrateReachRetracted)
			pADControllerRetracted.setMaximum(pCalibrateReach)
			adef.addController(pADControllerRetracted)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerRetracted)
			var CurveBezier curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0, 1) // retracted reach (x=0) => blend factor 1 (y=1)
			curve.addPoint(1, 0) // stretched reach (x=1) => blend factor 0 (y=0)
			link.setCurve(curve)
			adef.addLink(link)
			
			pADRuleRetracted = ADRuleAnimation.new()
			pADRuleRetracted.setName(getName() + ".retracted")
			pADRuleRetracted.setMoveName(pMoveRetracted)
			pCalibrateBones.forEach(block String each
				pADRuleRetracted.addBone(each)
			end)
			pADRuleRetracted.addTargetLink(ADRuleTargetLink.new(ARAnimationTarget.blendFactor, link))
			adef.addRule(pADRuleRetracted)
		end
		
		// shared IK objects
		pADControllerBlend = ADController.new()
		pADControllerBlend.setName(behavior.getControllerNameBlend())
		pADControllerBlend.setMinimum(0)
		pADControllerBlend.setMaximum(1)
		adef.addController(pADControllerBlend)
		
		var ADLink linkBlend = ADLink.new()
		linkBlend.setController(pADControllerBlend)
		adef.addLink(linkBlend)
		
		pADControllerTipPosition = ADController.new()
		pADControllerTipPosition.setName(behavior.getControllerNameTipPosition())
		adef.addController(pADControllerTipPosition)
		
		var ADLink linkTipPosition = ADLink.new()
		linkTipPosition.setController(pADControllerTipPosition)
		adef.addLink(linkTipPosition)
		
		// add guide rule
		var ModifiedRig.Bone mrboneGuide1, mrboneGuide2, mrboneGuide3
		
		if slotGuide != null and slotGuide.isDeviceAttached() and not pGuideBone.empty() and false
			// add bones
			mrboneGuide1 = modifyRig.addBone(getName() + ".guide1")
			
			mrboneGuide2 = modifyRig.addBone(getName() + ".guide2")
			mrboneGuide2.rotation = Vector.new(0, 0, pCalibrateGuideRotation)
			mrboneGuide2.parent = mrboneGuide1
			
			mrboneGuide3 = modifyRig.addBone(getName() + ".guide3")
			
			// add controllers and links
			pADControllerGuidePosition = ADController.new()
			pADControllerGuidePosition.setName(behavior.getControllerNameGuidePosition())
			adef.addController(pADControllerGuidePosition)
			
			var ADLink linkGuidePosition = ADLink.new()
			linkGuidePosition.setController(pADControllerGuidePosition)
			adef.addLink(linkGuidePosition)
			
			var ADLink linkGuideRotation = ADLink.new()
			linkGuideRotation.setBone(mrboneGuide2.name)
			linkGuideRotation.setBoneParameter(AnimatorLinkBoneParameter.rotationZ)
			linkGuideRotation.setBoneMinimum(-180)
			linkGuideRotation.setBoneMaximum(180)
			adef.addLink(linkGuideRotation)
			
			// add rules
			var ADRuleInverseKinematic ruleIK
			var ADRuleTrackTo ruleTrackTo
			var ADRuleForeignState ruleForeign
			var ADRuleBoneTransformator ruleBTrans
			var ADController controller
			var ADLink link
			
			// track guide1 to tip position with guide bone as up
			ruleIK = ADRuleInverseKinematic.new()
			ruleIK.setName(getName())
			ruleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTipPosition))
			ruleIK.addBone(mrboneGuide3.name)
			adef.addRule(ruleIK)
			
			ruleForeign = ADRuleForeignState.new()
			ruleForeign.setName(getName())
			ruleForeign.setEnablePosition(false)
			ruleForeign.setForeignBone(pGuideBone)
			ruleForeign.setSourceCoordinateFrame(ARForeignStateCFrame.component)
			ruleForeign.setDestinationCoordinateFrame(ARForeignStateCFrame.component)
			ruleForeign.addBone(mrboneGuide3.name)
			adef.addRule(ruleForeign)
			
			ruleIK = ADRuleInverseKinematic.new()
			ruleIK.setName(getName())
			ruleIK.setSolverBone(pGuideBone)
			ruleIK.setUseSolverBone(true)
			ruleIK.addBone(mrboneGuide1.name)
			adef.addRule(ruleIK)
			
			ruleTrackTo = ADRuleTrackTo.new()
			ruleTrackTo.setName(getName())
			ruleTrackTo.setTrackBone(mrboneGuide3.name)
			ruleTrackTo.setUpTarget(pCalibrateGuideRotationAxis)
			ruleTrackTo.addBone(mrboneGuide1.name)
			adef.addRule(ruleTrackTo)
			
			// track guide2 to guide goal
			ruleTrackTo = ADRuleTrackTo.new()
			ruleTrackTo.setName(getName())
			ruleTrackTo.setTrackAxis(ARTrackToAxis.posY)
			ruleTrackTo.setLockedAxis(ARTrackToLocked.z)
			ruleTrackTo.addTargetLink(ADRuleTargetLink.new(ARTrackToTarget.position, linkGuidePosition))
			ruleTrackTo.addBone(mrboneGuide2.name)
			adef.addRule(ruleTrackTo)
			
			// rotate guide bone. this can not be done around the view direction used
			// to calculate the rotation angle. instead the view direction has to match
			// the goal position is it would be if the current pose has to stay unchanged.
			// for this we can reuse the guide3 and guide1 as long as guide2 is not touched
			ruleIK = ADRuleInverseKinematic.new()
			ruleIK.setName(getName())
			ruleIK.setSolverBone(pTipBone)
			ruleIK.setUseSolverBone(true)
			ruleIK.addBone(mrboneGuide3.name)
			adef.addRule(ruleIK)
			
			ruleForeign = ADRuleForeignState.new()
			ruleForeign.setName(getName())
			ruleForeign.setEnablePosition(false)
			ruleForeign.setForeignBone(pGuideBone)
			ruleForeign.setSourceCoordinateFrame(ARForeignStateCFrame.component)
			ruleForeign.setDestinationCoordinateFrame(ARForeignStateCFrame.component)
			ruleForeign.addBone(mrboneGuide3.name)
			adef.addRule(ruleForeign)
			
			ruleTrackTo = ADRuleTrackTo.new()
			ruleTrackTo.setName(getName())
			ruleTrackTo.setTrackBone(mrboneGuide3.name)
			ruleTrackTo.setUpTarget(pCalibrateGuideRotationAxis)
			ruleTrackTo.addBone(mrboneGuide1.name)
			adef.addRule(ruleTrackTo)
			
			ruleBTrans = ADRuleBoneTransformator.new()
			ruleBTrans.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			ruleBTrans.setMinimumRotation(Vector.new(0, 0, -180))
			ruleBTrans.setMaximumRotation(Vector.new(0, 0, 180))
			ruleBTrans.setTargetBone(mrboneGuide1.name)
			ruleBTrans.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkGuideRotation))
			ruleBTrans.addBone(pGuideBone)
			adef.addRule(ruleBTrans)
			
		/*
			pADControllerGuideRotation = ADController.new()
			pADControllerGuideRotation.setName(behavior.getControllerNameGuideRotation())
			pADControllerGuideRotation.setMinimum(-180)
			pADControllerGuideRotation.setMaximum(180)
			pADControllerGuideRotation.setClamp(false)
			adef.addController(pADControllerGuideRotation)
			
			var ADLink linkGuideRotation = ADLink.new()
			linkGuideRotation.setController(pADControllerGuideRotation)
			adef.addLink(linkGuideRotation)
			
			pADRuleGuide = ADRuleBoneTransformator.new()
			pADRuleGuide.setName(getName())
			pADRuleGuide.setCoordinateFrame(ARBoneTransformatorCFrame.local)
			pADRuleGuide.setEnableOrientation(true)
			pADRuleGuide.setEnablePosition(false)
			pADRuleGuide.setEnableSize(false)
			pADRuleGuide.setMinimumAngle(-180)
			pADRuleGuide.setMaximumAngle(180)
			pADRuleGuide.setUseAxis(true)
			pADRuleGuide.setAxis(pCalibrateGuideAxis)
			
			pADRuleGuide.addBone(pGuideBone)
			
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.blendFactor, linkBlend))
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkGuideRotation))
			
			adef.addRule(pADRuleGuide)
		*/
		end
		
		// add IK rule
		pADControllerTipOrientation = ADController.new()
		pADControllerTipOrientation.setName(behavior.getControllerNameTipOrientation())
		adef.addController(pADControllerTipOrientation)
		
		var ADLink linkTipOrientation = ADLink.new()
		linkTipOrientation.setController(pADControllerTipOrientation)
		adef.addLink(linkTipOrientation)
		
		pADRuleIK = ADRuleInverseKinematic.new()
		pADRuleIK.setName(getName())
		pADRuleIK.setAdjustPosition(pAdjustPosition)
		pADRuleIK.setAdjustOrientation(true)
		
		pADRuleIK.setReachBone(guideBone)
		pADRuleIK.setReachRange(pCalibrateReachRange)
		
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.blendFactor, linkBlend))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTipPosition))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkTipOrientation))
		
		pADRuleIK.addBone(pTipBone)
		if not pBaseBone.equals(pTipBone)
			pADRuleIK.addBone(pBaseBone)
		end
		
		/*
		if slotGuide != null and slotGuide.isDeviceAttached()
			pADControllerGuidePosition = ADController.new()
			pADControllerGuidePosition.setName(behavior.getControllerNameGuidePosition())
			adef.addController(pADControllerGuidePosition)
			
			var ADLink linkGuidePosition = ADLink.new()
			linkGuidePosition.setController(pADControllerGuidePosition)
			adef.addLink(linkGuidePosition)
			
			pADRuleIK.setGuideBone(guideBone)
			pADRuleIK.setGuideLocalPosition(pCalibrateGuideLocalPosition)
			pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.guideGoalPosition, linkGuidePosition))
		end
		*/
		
		adef.addRule(pADRuleIK)
		
		if false
			pADRuleIKForce = ADRuleInverseKinematic.new()
			pADRuleIKForce.setName(getName() + ".force")
			pADRuleIKForce.setAdjustPosition(false)
			pADRuleIKForce.setAdjustOrientation(true)
			pADRuleIKForce.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTipPosition))
			pADRuleIKForce.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkTipOrientation))
			pADRuleIKForce.addBone(pTipBone)
			adef.addRule(pADRuleIKForce)
		end
		
		// add guide rule
		if slotGuide != null and slotGuide.isDeviceAttached() and not pGuideBone.empty()
			// add bones
			mrboneGuide1 = modifyRig.addBone(getName() + ".guide1")
			
			mrboneGuide2 = modifyRig.addBone(getName() + ".guide2")
			mrboneGuide2.rotation = Vector.new(0, 0, pCalibrateGuideRotation)
			mrboneGuide2.parent = mrboneGuide1
			
			mrboneGuide3 = modifyRig.addBone(getName() + ".guide3")
			
			// add controllers and links
			pADControllerGuidePosition = ADController.new()
			pADControllerGuidePosition.setName(behavior.getControllerNameGuidePosition())
			adef.addController(pADControllerGuidePosition)
			
			var ADLink linkGuidePosition = ADLink.new()
			linkGuidePosition.setController(pADControllerGuidePosition)
			adef.addLink(linkGuidePosition)
			
			var ADLink linkGuideRotation = ADLink.new()
			linkGuideRotation.setBone(mrboneGuide2.name)
			linkGuideRotation.setBoneParameter(AnimatorLinkBoneParameter.rotationZ)
			linkGuideRotation.setBoneMinimum(-180)
			linkGuideRotation.setBoneMaximum(180)
			adef.addLink(linkGuideRotation)
			
			// add rules
			var ADRuleInverseKinematic ruleIK
			var ADRuleTrackTo ruleTrackTo
			var ADRuleForeignState ruleForeign
			var ADRuleBoneTransformator ruleBTrans
			var ADRuleStateManipulator ruleStaManip
			var ADController controller
			var ADLink link
			
			// track guide1 to tip position with guide bone as up
			ruleIK = ADRuleInverseKinematic.new()
			ruleIK.setName(getName())
			ruleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTipPosition))
			ruleIK.addBone(mrboneGuide3.name)
			adef.addRule(ruleIK)
			
			ruleForeign = ADRuleForeignState.new()
			ruleForeign.setName(getName())
			ruleForeign.setEnablePosition(false)
			ruleForeign.setForeignBone(pGuideBone)
			ruleForeign.setSourceCoordinateFrame(ARForeignStateCFrame.component)
			ruleForeign.setDestinationCoordinateFrame(ARForeignStateCFrame.component)
			ruleForeign.addBone(mrboneGuide3.name)
			adef.addRule(ruleForeign)
			
			ruleIK = ADRuleInverseKinematic.new()
			ruleIK.setName(getName())
			ruleIK.setSolverBone(pGuideBone)
			ruleIK.setUseSolverBone(true)
			ruleIK.addBone(mrboneGuide1.name)
			adef.addRule(ruleIK)
			
			ruleTrackTo = ADRuleTrackTo.new()
			ruleTrackTo.setName(getName())
			ruleTrackTo.setTrackBone(mrboneGuide3.name)
			ruleTrackTo.setUpTarget(pCalibrateGuideRotationAxis)
			ruleTrackTo.addBone(mrboneGuide1.name)
			adef.addRule(ruleTrackTo)
			
			// track guide2 to guide goal
			ruleTrackTo = ADRuleTrackTo.new()
			ruleTrackTo.setName(getName())
			ruleTrackTo.setTrackAxis(ARTrackToAxis.posY)
			ruleTrackTo.setLockedAxis(ARTrackToLocked.z)
			ruleTrackTo.addTargetLink(ADRuleTargetLink.new(ARTrackToTarget.position, linkGuidePosition))
			ruleTrackTo.addBone(mrboneGuide2.name)
			adef.addRule(ruleTrackTo)
			
			// rotate guide bone
			ruleBTrans = ADRuleBoneTransformator.new()
			ruleBTrans.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			ruleBTrans.setMinimumRotation(Vector.new(0, 0, pGuideScaleRotation * -180))
			ruleBTrans.setMaximumRotation(Vector.new(0, 0, pGuideScaleRotation * 180))
			ruleBTrans.setTargetBone(mrboneGuide1.name)
			ruleBTrans.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkGuideRotation))
			ruleBTrans.addBone(pGuideBone)
			adef.addRule(ruleBTrans)
			
			// cancel rotation on tip bone
			ruleBTrans = ADRuleBoneTransformator.new()
			ruleBTrans.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			ruleBTrans.setMinimumRotation(Vector.new(0, 0, pGuideScaleRotation * 180))
			ruleBTrans.setMaximumRotation(Vector.new(0, 0, pGuideScaleRotation * -180))
			ruleBTrans.setTargetBone(mrboneGuide1.name)
			ruleBTrans.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkGuideRotation))
			ruleBTrans.addBone(pTipBone)
			adef.addRule(ruleBTrans)
		end
		
		// add twist rules
		if pTwistBoneCount > 0 and pTwistPropagation > 0.01 and boneCount >= 2
			var int count = DEMath.min(pTwistBoneCount, boneCount - 1)
			var ADRuleBoneTransformator rule
			var String name = getName() + ".twist"
			var float maxAngle = 180
			var int i
			
			pADControllerTwist = ADController.new()
			pADControllerTwist.setName(behavior.getControllerNameTwist())
			pADControllerTwist.setMinimum(-maxAngle)
			pADControllerTwist.setMaximum(maxAngle)
			adef.addController(pADControllerTwist)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerTwist)
			adef.addLink(link)
			
			var float angle = pTwistPropagation * maxAngle / count
			var int baseIndex = count
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var Vector axis = pCalibrateTwistAxes.getAt(i) cast Vector
				var float realAngle = angle * (i + 1)
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setTargetBone(bone)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(realAngle)
				rule.setMaximumAngle(-realAngle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
				rule.addBone(pCalibrateBones.getAt(baseIndex - i - 1) cast String)
				adef.addRule(rule)
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setTargetBone(bone)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(-realAngle)
				rule.setMaximumAngle(realAngle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
				rule.addBone(bone)
				adef.addRule(rule)
			end
		end
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
			
			if mrboneGuide1 != null
				recordAnimation.addIgnoreBone(mrboneGuide1.name)
			end
			if mrboneGuide2 != null
				recordAnimation.addIgnoreBone(mrboneGuide2.name)
			end
			if mrboneGuide3 != null
				recordAnimation.addIgnoreBone(mrboneGuide3.name)
			end
		end
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pCalibrateReach = 0.6
		pCalibrateReachScale = 1
		pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
		pCalibrateReachRange = 0
		pCalibrateReachRetracted = 1
		pCalibrateBones.removeAll()
		pTipTracker.resetTransform()
		pGuideTracker.resetTransform()
		pBaseTracker.resetTransform()
		pCalibrateTwistAxes.removeAll()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateGuideLocalPosition = Vector.new()
		pCalibrateGuideRotation = 0
		pCalibrateGuideRotationAxis = ARTrackToUp.trackBoneZ
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		findBoneChain(component.getRig(), pTipBone, pBaseBone, pCalibrateBones)
		var String baseBone = "", guideBone = ""
		if pCalibrateBones.getCount() >= 2
			baseBone = pBaseBone
			guideBone = pGuideBone
		end
		
		if guideBone.empty()
			guideBone = baseBone
		end
		
		pTipTracker.resolveRealSlot(config)
		pTipTracker.setTransform(component, pTipBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(component, guideBone)
		
		// calculate reach of IK chain to avoid over stretching
		var int indexBase = -1, indexGuide = -1, indexTip = -1
		if not baseBone.empty() and not pTipBone.empty()
			indexBase = component.indexOfBoneNamed(baseBone)
			indexGuide = component.indexOfBoneNamed(guideBone)
			indexTip = component.indexOfBoneNamed(pTipBone)
		end
		
		if indexBase != -1 and indexTip != -1
			var Matrix baseMatrix = component.boneGetMatrix(indexBase)
			var Matrix tipMatrix = component.boneGetMatrix(indexTip)
			
			var CharacterTrackerSlot slotBase = pBaseTracker.getRealSlot()
			var CharacterTrackerSlot slotTip = pTipTracker.getRealSlot()
			
			var Vector posBase = baseMatrix.getPosition()
			var Vector posTip = tipMatrix.getPosition()
			
			select pActorReach
			case ActorReach.arm
				// actor arm reach parameter matches tracker target not target bone
				if slotTip != null
					// matrix = bone * transform^-1 * (ref * slot^1) * (target * ref^-1)
					posTip = (pTipTracker.getOffsetMatrix() * slotTip.getTargetMatrix()).getPosition()
				end
				
				// along Z direction this is always 1.
				// along X and Y direction the scaling has to be adjusted. this is due
				// to the character shoulder joint usually not lining up with the actor
				// shoulder joint. here though the spine attachment point is usually used
				// as the base of the IK chain. this has the advantage that with the
				// actor the spine attachment point is pretty much at the center of the
				// actor. this way the location of the character spine attachment point
				// becomes the pivot point. the length from the pivot point to the
				// character center is fixed. the remaining length has to make a turn
				// to reach the IK point. this length has to be matched with the length
				// from the turned IK point to the spine attachment point.
				
				// the reach front can be calculate by using a shortening of the calibrate
				// reach. this can be done using a fudge factor but that can be wrong.
				// another solution is to consider the base bone as the shoulder bone
				// which does not full rotate. the length of all other bones indicates
				// the maximum reach if the shoulder bone does not rotate. using the
				// length of the shoulder bone and a maximum rotation range for
				// forward/backward and up/down the actual reach can be calculated.
				// we can use the guide bone for this
				
				var Vector posRotate = posBase.absolute()
				var Vector tipFront, tipDown
				var float rotateFront = 40
				var float rotateDown = 40
				
				if indexGuide != -1 and indexGuide != indexBase
					posRotate = component.boneGetMatrix(indexGuide).getPosition().absolute()
				end
				
				var float reachRotateTip = (posTip.absolute() - posRotate).getLength()
				var float reachBaseRotate = (posRotate - posBase.absolute()).getLength() // can be 0
				var float scaleFront, scaleDown
				var Vector tip, actorTip
				
				// reach scaling
				var float actorShoulderReach = (actorProfile.getShoulderWidth() / 2) * config.getCalibrateScale()
				var float actorArmReach = actorProfile.getArmLength() * config.getCalibrateScale()
				var float actorReach = actorShoulderReach + actorArmReach
				
				pCalibrateReach = reachBaseRotate + reachRotateTip
				pCalibrateReachScale = posTip.absolute().getX() / actorReach
				
				// front
				tip = Vector.new(reachBaseRotate * DEMath.cos(rotateFront),\
					0, reachRotateTip + reachBaseRotate * DEMath.sin(rotateFront))
				
				scaleFront = tip.getLength() / pCalibrateReach
				
				// down
				tip = Vector.new(reachBaseRotate * DEMath.cos(rotateDown),\
					-(reachRotateTip + reachBaseRotate * DEMath.sin(rotateDown)), 0)
				
				scaleDown = tip.getLength() / pCalibrateReach
				
				// store direction specific scale
				pCalibrateReachScaleDirection = Vector.new(1, scaleDown, scaleFront).compMultiply(pReachScaling)
				
			case ActorReach.leg
				// reach scale is not working well with legs
//	 				pCalibrateReachScale = pCalibrateReach / (actorProfile.getLegLength() * config.getCalibrateScale())
				pCalibrateReach = (posTip - posBase).getLength()
				pCalibrateReachScale = 1
				pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
				
			else
				pCalibrateReach = (posTip - posBase).getLength()
				pCalibrateReachScale = 1
				pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
			end
			
			if slotTip != null and pTipTracker.getAutoTransform() == MotionTransferTracker.AutoTransform.orientationTarget
				var Vector displacement = slotTip.getTargetPosition()\
					- slotTip.getCalibrateReferenceMatrix().getPosition()
				
				if displacement.getLength() > 0.01
					pCalibrateTipOffset = component.boneGetInverseMatrix(indexBase)\
						.transformNormal(displacement)
					
				else
					pCalibrateTipOffset = Vector.new()
				end
				
// 				pCalibrateTipOffset = posTip - slotTip.getCalibratePosition()
				//var Vector slotPos = slotTip.getCalibratePosition()
				//var float realReach = (slotPos - posGuide).getLength()
				//pCalibrateReachScale = pCalibrateReach / realReach
				
			else
				pCalibrateTipOffset = Vector.new()
				//pCalibrateReachScale = 1
				//pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
				//pCalibrateGuideUpAxis = ARTrackToAxis.posY
			end
			
			// reach range is only used if base tracker is set
			if slotBase != null
				pCalibrateReachRange = pCalibrateReach
				
			else
				pCalibrateReachRange = 0
			end
			
		else
			pCalibrateReach = 0.6
			pCalibrateReachScale = 1
			pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
			pCalibrateReachRange = 0
			pCalibrateReachRetracted = pCalibrateReach
			pCalibrateTipOffset = Vector.new()
		end
		
		// calibrate guide tracker. has to come after reach scaling since it uses this value
		pGuideTracker.resolveRealSlot(config)
		pGuideTracker.setTransform(component, "")
		
		// calculate retracted reach if used
		var Component tcomponent = component
		
		if not pMoveRetracted.empty() and indexGuide != -1 and indexTip != -1
			// create a temporary component so we can apply the move and do some measuring
			tcomponent = Component.new(component.getModel(), component.getSkin())
			tcomponent.setRig(component.getRig())
			
			var CharacterAppearance appearance = config.getProfile().getAppearance()
			var Animator tanimator = Animator.new()
			tanimator.setRig(component.getRig())
			tanimator.setAnimation(appearance.getAnimation())
			
			var ARAnimation rule = ARAnimation.new()
			rule.setMoveName(pMoveRetracted)
			tanimator.addRule(rule)
			
			var AnimatorInstance tainst = AnimatorInstance.new()
			tainst.setAnimator(tanimator)
			tainst.setComponent(tcomponent)
			tainst.applyDirect()
			tcomponent.updateBones()
			
			// measure the reach and store it
			var Vector posRoot = tcomponent.boneGetMatrix(indexGuide).getPosition()
			var Vector posTip = tcomponent.boneGetMatrix(indexTip).getPosition()
			
			pCalibrateReachRetracted = (posTip - posRoot).getLength()
		end
		
		// calculate twist axes
		if pTwistBoneCount > 0 and pTwistPropagation > 0.01
			var int count = DEMath.min(pTwistBoneCount, pCalibrateBones.getCount() - 1)
			var Vector axis = Matrix.newRotation(pTwistAxisRotation).getViewVector()
			var int i, baseIndex = count
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				if indexBone != -1
					pCalibrateTwistAxes.add(component.boneGetInverseMatrix(indexBone).transformNormal(axis))
					
				else
					pCalibrateTwistAxes.add(Vector.new(0, 0, 1))
				end
			end
			
			if indexTip != -1
				pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pTwistAxisRotation) \
					* component.boneGetInverseMatrix(indexTip)).getEulerAngles()
			end
		end
		
		// guiding
		if indexGuide != -1 and indexBase != -1 and indexTip != -1
			var CharacterTrackerSlot slotBase = pBaseTracker.getRealSlot()
			var CharacterTrackerSlot slotTip = pTipTracker.getRealSlot()
			var CharacterTrackerSlot slotGuide = pGuideTracker.getRealSlot()
			
			if slotGuide != null and slotBase != null and slotTip != null
				var Vector posBase = (pBaseTracker.getTransformMatrix() * slotBase.getCalibrateMatrix()).getPosition()
				var Vector posTip = (pTipTracker.getTransformMatrix() * slotTip.getCalibrateMatrix()).getPosition()
				var Vector view = posTip - posBase
				
				if not view.isZero()
					view = view.normalize()
					
					// calculate base matrix
					var Matrix boneMatrix = component.boneGetMatrix(indexGuide).normalize()
					
					var float x = view * boneMatrix.getRightVector()
					var float y = view * boneMatrix.getUpVector()
					var float z = view * boneMatrix.getViewVector()
					
					var Vector up
					
					if z > x and z > y
						up = boneMatrix.getUpVector()
						pCalibrateGuideRotationAxis = ARTrackToUp.trackBoneY
						
					else
						up = boneMatrix.getViewVector()
						pCalibrateGuideRotationAxis = ARTrackToUp.trackBoneZ
					end
					up = (up - view * (view * up))
					
					if not (view % up).isZero()
						var Matrix baseMatrix = Matrix.newWorld(boneMatrix.getPosition(), view, up)
						
						// track rotation. transform guide position into base matrix then
						// calculate the rotation against the Z axis
						var Vector posGuide = (pGuideTracker.getTransformMatrix()\
							* slotGuide.getCalibrateMatrix() * baseMatrix.getInverse()).getPosition()
						
						up = posGuide.compSelect(true, true, false)
						
						if not up.isZero()
							pCalibrateGuideRotation = DEMath.atan2(up.getX(), up.getY()) + pGuideZeroRotation
						end
					end
				end
				
				
				
				pCalibrateGuideLocalPosition = (pGuideTracker.getTransformMatrix()\
					* slotGuide.getCalibrateMatrix()\
					* component.boneGetInverseMatrix(indexGuide)).getPosition()
			end
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferIK.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("tipBone")
				setTipBone(element.getFirstCData())
				
			elif tagName.equals("baseBone")
				setBaseBone(element.getFirstCData())
				
			elif tagName.equals("guideBone")
				setGuideBone(element.getFirstCData())
				
			elif tagName.equals("tipTracker")
				pTipTracker.load(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("actorReach")
				setActorReach(ActorReach.named(element.getFirstCData()))
				
			elif tagName.equals("reachLimit")
				setReachLimit(element.getFirstCDataFloat())
				
			elif tagName.equals("reachScaling")
				pReachScaling = loader.readVector(element)
				
			elif tagName.equals("adjustPosition")
				setAdjustPosition(element.getFirstCDataBool())
				
			elif tagName.equals("moveBaseIK")
				setMoveBaseIK(element.getFirstCData())
				
			elif tagName.equals("moveRetracted")
				setMoveRetracted(element.getFirstCData())
				
			elif tagName.equals("twistPropagation")
				setTwistPropagation(element.getFirstCDataFloat())
				
			elif tagName.equals("twistBoneCount")
				setTwistBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("twistAxisRotation")
				setTwistAxisRotation(loader.readVector(element))
				
			elif tagName.equals("guideZeroRotation")
				setGuideZeroRotation(element.getFirstCDataFloat())
				
			elif tagName.equals("guideScaleRotation")
				setGuideScaleRotation(element.getFirstCDataFloat())
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	public func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("reach")
				pCalibrateReach = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScale")
				pCalibrateReachScale = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScaleDirection")
				pCalibrateReachScaleDirection = loader.readVector(element)
				
			elif tagName.equals("reachRange")
				pCalibrateReachRange = element.getFirstCDataFloat()
				
			elif tagName.equals("tipOffset")
				pCalibrateTipOffset = loader.readVector(element)
				
			elif tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("tipTracker")
				pTipTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("reachRetracted")
				pCalibrateReachRetracted = element.getFirstCDataFloat()
				
			elif tagName.equals("twistAxis")
				pCalibrateTwistAxes.add(loader.readVector(element))
				
			elif tagName.equals("twistBoneAxisRotation")
				pCalibrateTwistBoneAxisRotation = loader.readVector(element)
				
			elif tagName.equals("guideRotationBase")
				pCalibrateGuideRotation = element.getFirstCDataFloat()
				
			elif tagName.equals("guideRotationBaseAxis")
				pCalibrateGuideRotationAxis = ARTrackToUp.named(element.getFirstCData())
				
			elif tagName.equals("guideLocalPosition")
				pCalibrateGuideLocalPosition = loader.readVector(element)
			end
		end)
	end
	
	/** Post load initialize. */
	public func void postLoadInit(CharacterConfiguration config)
		pTipTracker.resolveRealSlot(config)
		pGuideTracker.resolveRealSlot(config)
		pBaseTracker.resolveRealSlot(config)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("tipBone", pTipBone)
		tag.addDataTag("baseBone", pBaseBone)
		tag.addDataTag("guideBone", pGuideBone)
		pTipTracker.save(loader, tag.addTag("tipTracker"))
		pGuideTracker.save(loader, tag.addTag("guideTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		tag.addDataTag("actorReach", pActorReach.name())
		tag.addDataTag("reachLimit", pReachLimit)
		loader.writeVector(tag, "reachScaling", pReachScaling)
		tag.addDataTag("adjustPosition", pAdjustPosition)
		tag.addDataTag("moveBaseIK", pMoveBaseIK)
		tag.addDataTag("moveRetracted", pMoveRetracted)
		tag.addDataTag("twistPropagation", pTwistPropagation)
		tag.addDataTag("twistBoneCount", pTwistBoneCount)
		loader.writeVector(tag, "twistAxisRotation", pTwistAxisRotation)
		tag.addDataTag("guideZeroRotation", pGuideZeroRotation)
		tag.addDataTag("guideScaleRotation", pGuideScaleRotation)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	public func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("reach", pCalibrateReach)
		tag.addDataTag("reachScale", pCalibrateReachScale)
		loader.writeVector(tag, "reachScaleDirection", pCalibrateReachScaleDirection)
		tag.addDataTag("reachRange", pCalibrateReachRange)
		loader.writeVector(tag, "tipOffset", pCalibrateTipOffset)
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTipTracker.saveCalibrated(loader, tag.addTag("tipTracker"))
		pGuideTracker.saveCalibrated(loader, tag.addTag("guideTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("baseTracker"))
		tag.addDataTag("reachRetracted", pCalibrateReachRetracted)
		pCalibrateTwistAxes.forEach(block Vector each
			loader.writeVector(tag, "twistAxis", each)
		end)
		loader.writeVector(tag, "twistBoneAxisRotation", pCalibrateTwistBoneAxisRotation)
		tag.addDataTag("guideRotation", pCalibrateGuideRotation)
		tag.addDataTag("guideRotationAxis", pCalibrateGuideRotationAxis.name())
		loader.writeVector(tag, "guideLocalPosition", pCalibrateGuideLocalPosition)
	end
end
