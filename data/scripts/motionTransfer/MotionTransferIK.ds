/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer using Inverse Kinematic.
 * 
 * Defines root bone and tip bone name. This defines the bone chain to manipulate.
 * The tip bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 2 or more bones.
 * 
 * Defines the tracker slot to be used to set the tip bone position before applying
 * inverse kinematic. During calibration the coordinate system of the tracker slot
 * relative to the tip bone coordinate system is stored. Custom position and rotation
 * offsets can be applied to fine tune the result if slightly off.
 * 
 * Optionally a guide tracker slot can be defined which is used to guide the orientation
 * of the root bone before applying inverse kinematics. This is used for example to guide
 * the elbow on an arm while shoulder and hand remain at equal position and orientation.
 */
class MotionTransferIK extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "ik"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferIK.new(factoryID())
		end
		
		public func String displayName()
			return "Inverse Kinematic"
		end
	end
	
	/** Actor reach type. */
	enum ActorReach
		none //<! No actor reach. Use unscaled reach
		arm //<! Use actor arm length as reach
		leg //<! Use actor leg length as reach
	end
	
	
	
	private var String pTipBone
	private var String pBaseBone
	private var String pGuideBone
	private var MotionTransferTracker pTipTracker
	private var MotionTransferTracker pGuideTracker
	private var MotionTransferTracker pBaseTracker
	private var ActorReach pActorReach
	private var float pReachLimit
	private var bool pAdjustPosition
	private var String pMoveBaseIK
	private var String pMoveRetracted
	private var float pTwistPropagation
	private var int pTwistBoneCount
	private var Vector pTwistAxisRotation
	
	private var ADController pADControllerTipPosition
	private var ADController pADControllerTipOrientation
	private var ADController pADControllerGuidePosition
	private var ADController pADControllerGuideUp
	private var ADController pADControllerTwist
	private var ADController pADControllerRetracted
	
	private var ADRuleTrackTo pADRuleGuide
	private var ADRuleInverseKinematic pADRuleIK
	private var ADRuleInverseKinematic pADRuleIKForce
	private var ADRuleAnimation pADRuleBaseIK
	private var ADRuleAnimation pADRuleRetracted
	
	private var Array pCalibrateBones
	private var float pCalibrateReach
	private var float pCalibrateReachScale
	private var ARTrackToAxis pCalibrateGuideTrackAxis
	private var ARTrackToAxis pCalibrateGuideUpAxis
	private var Vector pCalibrateTipOffset
	private var float pCalibrateReachRetracted
	private var Vector pCalibrateTwistRotation
	private var Array pCalibrateTwistAxes
	private var Vector pCalibrateTwistBoneAxisRotation
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTipBone = ""
		pBaseBone = ""
		pGuideBone = ""
		pTipTracker = MotionTransferTracker.new()
		pGuideTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pActorReach = ActorReach.none
		pReachLimit = 1
		pAdjustPosition = true
		pMoveBaseIK = ""
		pMoveRetracted = ""
		pTwistPropagation = 0
		pTwistBoneCount = 0
		pTwistAxisRotation = Vector.new()
		pCalibrateBones = Array.new()
		pCalibrateReach = 0.6
		pCalibrateReachScale  = 1
		pCalibrateReachRetracted = 1
		pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
		pCalibrateGuideUpAxis = ARTrackToAxis.posY
		pCalibrateTipOffset = Vector.new()
		pCalibrateTwistRotation = Vector.new()
		pCalibrateTwistAxes = Array.new()
		pCalibrateTwistBoneAxisRotation = Vector.new()
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferIK transfer) super(transfer)
		pTipBone = transfer.pTipBone
		pBaseBone = transfer.pBaseBone
		pGuideBone = transfer.pGuideBone
		pTipTracker = MotionTransferTracker.new(transfer.pTipTracker)
		pGuideTracker = MotionTransferTracker.new(transfer.pGuideTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pActorReach = transfer.pActorReach
		pReachLimit = transfer.pReachLimit
		pAdjustPosition = transfer.pAdjustPosition
		pMoveBaseIK = transfer.pMoveBaseIK
		pMoveRetracted = transfer.pMoveRetracted
		pTwistPropagation = transfer.pTwistPropagation
		pTwistBoneCount = transfer.pTwistBoneCount
		pTwistAxisRotation = transfer.pTwistAxisRotation
		pCalibrateBones = Array.new(transfer.pCalibrateBones)
		pCalibrateReach = transfer.pCalibrateReach
		pCalibrateReachScale = transfer.pCalibrateReachScale
		pCalibrateReachRetracted = transfer.pCalibrateReachRetracted
		pCalibrateGuideTrackAxis = transfer.pCalibrateGuideTrackAxis
		pCalibrateGuideUpAxis = transfer.pCalibrateGuideUpAxis
		pCalibrateTipOffset = transfer.pCalibrateTipOffset
		pCalibrateTwistRotation = transfer.pCalibrateTwistRotation
		pCalibrateTwistAxes = Array.new(transfer.pCalibrateTwistAxes)
		pCalibrateTwistBoneAxisRotation = transfer.pCalibrateTwistBoneAxisRotation
	end
	
	
	
	/** Tip bone name. */
	public func String getTipBone()
		return pTipBone
	end
	
	/** Set tip bone name. */
	public func void setTipBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTipBone = bone
	end
	
	/** Base bone name. */
	public func String getBaseBone()
		return pBaseBone
	end
	
	/** Set base bone name. */
	public func void setBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pBaseBone = bone
	end
	
	/** Guide bone name. */
	public func String getGuideBone()
		return pGuideBone
	end
	
	/** Set guide bone name. */
	public func void setGuideBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pGuideBone = bone
	end
	
	/** Tip tracker. */
	public func MotionTransferTracker getTipTracker()
		return pTipTracker
	end
	
	/** Guide tracker. */
	public func MotionTransferTracker getGuideTracker()
		return pGuideTracker
	end
	
	/** Reach tracker. */
	public func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Actor reach to use to scale reach length. */
	public func ActorReach getActorReach()
		return pActorReach
	end
	
	/** Set actor reach to use to scale reach length. */
	public func void setActorReach(ActorReach actorReach)
		if actorReach == null
			throw ENullPointer.new("actorReach")
		end
		pActorReach = actorReach
	end
	
	/** Limit reach to percentage of bone chain reach. */
	public func float getReachLimit()
		return pReachLimit
	end
	
	/** Set limit reach to percentage of bone chain reach. */
	public func void setReachLimit(float limit)
		pReachLimit = DEMath.max(limit, 0.1)
	end
	
	/** Adjust position if chain is of length 1. */
	public func bool getAdjustPosition()
		return pAdjustPosition
	end
	
	/** Set adjust position if chain is of length 1. */
	public func void setAdjustPosition(bool adjust)
		pAdjustPosition = adjust
	end
	
	/** Name of move to use to init base IK state for better results. */
	public func String getMoveBaseIK()
		return pMoveBaseIK
	end
	
	/** Set name of move to use to init base IK state for better results. */
	public func void setMoveBaseIK(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveBaseIK = move
	end
	
	/** Name of move to use to init retracted pose for better results. */
	public func String getMoveRetracted()
		return pMoveRetracted
	end
	
	/** Set name of move to use to init retracted pose for better results. */
	public func void setMoveRetracted(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveRetracted = move
	end
	
	/** Percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func float getTwistPropagation()
		return pTwistPropagation
	end
	
	/** Set percentage amount of twist propagated from tip bone to first bone after root bone. */
	public func void setTwistPropagation(float amount)
		pTwistPropagation = DEMath.max(amount, 0.0)
	end
	
	/** Count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func int getTwistBoneCount()
		return pTwistBoneCount
	end
	
	/** Set count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func void setTwistBoneCount(int count)
		if count < 0
			throw EInvalidParam.new("count < 0")
		end
		pTwistBoneCount = count
	end
	
	/** Rotation of twist axis relative to tip bone. */
	public func Vector getTwistAxisRotation()
		return pTwistAxisRotation
	end
	
	/** Set rotation of twist axis relative to tip bone. */
	public func void setTwistAxisRotation(Vector rotation)
		if rotation == null
			throw ENullPointer.new("rotation")
		end
		pTwistAxisRotation = rotation
	end
	
	
	
	/** Animator definition rule or null. */
	public func ADRuleInverseKinematic getADRuleIK()
		return pADRuleIK
	end
	
	public func ADRuleTrackTo getADRuleGuide()
		return pADRuleGuide
	end
	
	public func ADRuleAnimation getADRuleBaseIK()
		return pADRuleBaseIK
	end
	
	/** Calibrate reach. */
	public func float getCalibrateReach()
		return pCalibrateReach
	end
	
	/** Calibrate reach scale. */
	public func float getCalibrateReachScale()
		return pCalibrateReachScale
	end
	
	/** Calibrate tip offset. */
	public func Vector getCalibrateTipOffset()
		return pCalibrateTipOffset
	end
	
	/** Calibrate guide track axis. */
	public func ARTrackToAxis getCalibrateGuideTrackAxis()
		return pCalibrateGuideTrackAxis
	end
	
	/** Calibrate guide up axis. */
	public func ARTrackToAxis getCalibrateGuideUpAxis()
		return pCalibrateGuideUpAxis
	end
	
	/** Calibrate twist rotation. */
	public func Vector getCalibrateTwistRotation()
		return pCalibrateTwistRotation
	end
	
	/** Calibrate twist bone axis rotation. */
	public func Vector getCalibrateTwistBoneAxisRotation()
		return pCalibrateTwistBoneAxisRotation
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass)
		pADControllerTipPosition = null
		pADControllerTipOrientation = null
		pADControllerGuidePosition = null
		pADControllerRetracted = null
		pADControllerGuideUp = null
		pADControllerTwist = null
		pADRuleIK = null
		pADRuleIKForce = null
		pADRuleGuide = null
		pADRuleBaseIK = null
		pADRuleRetracted = null
		
		// add behavior
		var ECBMotionTransferIK behavior = ECBMotionTransferIK.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTip, slotGuide, slotReach
		if not pTipTracker.getSlot().empty()
			slotTip = config.getTrackerSlots().getNamed(pTipTracker.getSlot())
		end
		if not pGuideTracker.getSlot().empty()
			slotGuide = config.getTrackerSlots().getNamed(pGuideTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotReach = config.getTrackerSlots().getNamed(pBaseTracker.getSlot())
		end
		
		if slotTip == null or pCalibrateBones.getCount() < 2 or pTipBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		
// 		if false
// 			var ADRuleBoneTransformator rule = ADRuleBoneTransformator.new()
// 			rule.setName(getName() + ".baseBend1")
// 		end
		
		var String guideBone = pGuideBone.empty() if pBaseBone else pGuideBone
		
		if not pMoveBaseIK.empty()
			pADRuleBaseIK = ADRuleAnimation.new()
			pADRuleBaseIK.setName(getName() + ".baseIK")
			pADRuleBaseIK.setMoveName(pMoveBaseIK)
			pCalibrateBones.forEach(block String each
				pADRuleBaseIK.addBone(each)
			end)
			adef.addRule(pADRuleBaseIK)
		end
		
		if not pMoveRetracted.empty()
			pADControllerRetracted = ADController.new()
			pADControllerRetracted.setName(behavior.getControllerNameRetracted())
			pADControllerRetracted.setMinimum(pCalibrateReachRetracted)
			pADControllerRetracted.setMaximum(pCalibrateReach)
			adef.addController(pADControllerRetracted)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerRetracted)
			var CurveBezier curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0, 1) // retracted reach (x=0) => blend factor 1 (y=1)
			curve.addPoint(1, 0) // stretched reach (x=1) => blend factor 0 (y=0)
			link.setCurve(curve)
			adef.addLink(link)
			
			pADRuleRetracted = ADRuleAnimation.new()
			pADRuleRetracted.setName(getName() + ".retracted")
			pADRuleRetracted.setMoveName(pMoveRetracted)
			pCalibrateBones.forEach(block String each
				pADRuleRetracted.addBone(each)
			end)
			pADRuleRetracted.addTargetLink(ADRuleTargetLink.new(ARAnimationTarget.blendFactor, link))
			adef.addRule(pADRuleRetracted)
		end
		
		if pTwistBoneCount > 0 and pTwistPropagation > 0.01
			var int count = DEMath.min(pTwistBoneCount, pCalibrateBones.getCount() - 1)
			var ADRuleBoneTransformator rule
			var String name = getName() + ".twist"
			var float maxAngle = 180
			var int i
			
			pADControllerTwist = ADController.new()
			pADControllerTwist.setName(behavior.getControllerNameTwist())
			pADControllerTwist.setMinimum(-maxAngle)
			pADControllerTwist.setMaximum(maxAngle)
			adef.addController(pADControllerTwist)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerTwist)
			adef.addLink(link)
			
			var float angle = pTwistPropagation * maxAngle / count
			var int baseIndex = count
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var Vector axis = pCalibrateTwistAxes.getAt(i) cast Vector
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(-angle)
				rule.setMaximumAngle(angle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
				rule.addBone(bone)
				adef.addRule(rule)
			end
			
			rule = ADRuleBoneTransformator.new()
			rule.setName(name)
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.local)
			rule.setUseAxis(true)
			rule.setAxis(pCalibrateTwistAxes.getAt(-1) cast Vector)
			rule.setMinimumAngle(pTwistPropagation * maxAngle)
			rule.setMaximumAngle(-pTwistPropagation * maxAngle)
			rule.setTargetBone(pCalibrateBones.getAt(1) cast String)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, link))
			rule.addBone(pTipBone)
			adef.addRule(rule)
		end
		
		if slotGuide != null and slotGuide.isDeviceAttached()
			pADControllerGuidePosition = ADController.new()
			pADControllerGuidePosition.setName(behavior.getControllerNameGuidePosition())
			adef.addController(pADControllerGuidePosition)
			
			pADControllerGuideUp = ADController.new()
			pADControllerGuideUp.setName(behavior.getControllerNameGuideUp())
			adef.addController(pADControllerGuideUp)
			
			pADRuleGuide = ADRuleTrackTo.new()
			pADRuleGuide.setName(getName() + ".guide")
			pADRuleGuide.setTrackAxis(pCalibrateGuideTrackAxis)
			pADRuleGuide.setUpAxis(pCalibrateGuideUpAxis)
			pADRuleGuide.setUpTarget(ARTrackToUp.controller)
			pADRuleGuide.addBone(guideBone)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerGuidePosition)
			adef.addLink(link)
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARTrackToTarget.position, link))
			
			link = ADLink.new()
			link.setController(pADControllerGuideUp)
			adef.addLink(link)
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARTrackToTarget.up, link))
			
			adef.addRule(pADRuleGuide)
		end
		
		pADControllerTipPosition = ADController.new()
		pADControllerTipPosition.setName(behavior.getControllerNameTipPosition())
		adef.addController(pADControllerTipPosition)
		
		pADControllerTipOrientation = ADController.new()
		pADControllerTipOrientation.setName(behavior.getControllerNameTipOrientation())
		adef.addController(pADControllerTipOrientation)
		
		var ADLink linkTipPosition = ADLink.new()
		linkTipPosition.setController(pADControllerTipPosition)
		adef.addLink(linkTipPosition)
		
		var ADLink linkTipOrientation = ADLink.new()
		linkTipOrientation.setController(pADControllerTipOrientation)
		adef.addLink(linkTipOrientation)
		
		pADRuleIK = ADRuleInverseKinematic.new()
		pADRuleIK.setName(getName())
		pADRuleIK.setAdjustPosition(pAdjustPosition)
		pADRuleIK.setAdjustOrientation(true)
		pADRuleIK.setReachBone(guideBone)
		pADRuleIK.setReachRange(pCalibrateReach)
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTipPosition))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkTipOrientation))
		pADRuleIK.addBone(pBaseBone)
		pADRuleIK.addBone(pTipBone)
		adef.addRule(pADRuleIK)
		
		if false
			pADRuleIKForce = ADRuleInverseKinematic.new()
			pADRuleIKForce.setName(getName() + ".force")
			pADRuleIKForce.setAdjustPosition(false)
			pADRuleIKForce.setAdjustOrientation(true)
			pADRuleIKForce.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTipPosition))
			pADRuleIKForce.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkTipOrientation))
			pADRuleIKForce.addBone(pTipBone)
			adef.addRule(pADRuleIKForce)
		end
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
		end
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pCalibrateReachScale = 1
		pCalibrateReachRetracted = 1
		pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
		pCalibrateGuideUpAxis = ARTrackToAxis.posY
		pCalibrateBones.removeAll()
		pCalibrateTwistRotation = Vector.new()
		pTipTracker.resetTransform()
		pGuideTracker.resetTransform()
		pBaseTracker.resetTransform()
		pCalibrateTwistAxes.removeAll()
		pCalibrateTwistBoneAxisRotation = Vector.new()
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		findBoneChain(component.getRig(), pTipBone, pBaseBone, pCalibrateBones)
		var String baseBone = "", guideBone = ""
		if pCalibrateBones.getCount() >= 2
			baseBone = pBaseBone
			guideBone = pGuideBone
		end
		
		if guideBone.empty()
			guideBone = baseBone
		end
		
		pCalibrateGuideTrackAxis = findGuideTrackAxis(component.getRig(), pTipBone, pBaseBone, pGuideBone)
		pCalibrateGuideUpAxis = guideUpFromGuideTrack(pCalibrateGuideTrackAxis)
		
		pTipTracker.resolveRealSlot(config)
		pTipTracker.setTransform(component, pTipBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(component, guideBone)
		
		// calculate reach of IK chain to avoid over stretching
		var int indexBase = -1, indexGuide = -1, indexTip = -1
		if not baseBone.empty() and not pTipBone.empty()
			indexBase = component.indexOfBoneNamed(baseBone)
			indexGuide = component.indexOfBoneNamed(guideBone)
			indexTip = component.indexOfBoneNamed(pTipBone)
		end
		
		if indexBase != -1 and indexGuide != -1 and indexTip != -1
			var Matrix guideMatrix = component.boneGetMatrix(indexGuide)
			var Matrix tipMatrix = component.boneGetMatrix(indexTip)
			
			var Vector posGuide = guideMatrix.getPosition()
			var Vector posTip = tipMatrix * pTipTracker.getReverseTransformPosition()
			pCalibrateReach = (posTip - posGuide).getLength()
			
			select pActorReach
			case ActorReach.arm
				pCalibrateReachScale = pCalibrateReach / (actorProfile.getArmLength() * config.getCalibrateScale())
				
			case ActorReach.leg
				// reach scale is not working well with legs
// 				pCalibrateReachScale = pCalibrateReach / (actorProfile.getLegLength() * config.getCalibrateScale())
				pCalibrateReachScale = 1
				
			else
				pCalibrateReachScale = 1
			end
			
			var CharacterTrackerSlot slotTip = pTipTracker.getRealSlot()
			if slotTip != null
// 				pCalibrateTipOffset = posTip - slotTip.getCalibratePosition()
				pCalibrateTipOffset = Vector.new()
				//var Vector slotPos = slotTip.getCalibratePosition()
				//var float realReach = (slotPos - posGuide).getLength()
				//pCalibrateReachScale = pCalibrateReach / realReach
				
			else
				pCalibrateTipOffset = Vector.new()
				//pCalibrateReachScale = 1
				//pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
				//pCalibrateGuideUpAxis = ARTrackToAxis.posY
			end
			
			// twist rotation. the rotation angle is unimportant since we only examine
			// relative rotation
			var Matrix twistTransform = (guideMatrix * tipMatrix.getInverse()).normalize()
			var Vector twistAxis = twistTransform.transformNormal(trackToVectorFromAxis(pCalibrateGuideTrackAxis))
			var Vector twistUp = twistTransform.transformNormal(trackToVectorFromAxis(pCalibrateGuideUpAxis))
			
			twistTransform = Matrix.newVU(twistAxis, twistUp).getInverse()
			pCalibrateTwistRotation = twistTransform.getEulerAngles()
			
		else
			pCalibrateReach = 0.6
			pCalibrateReachScale = 1
			pCalibrateReachRetracted = pCalibrateReach
			pCalibrateTipOffset = Vector.new()
			pCalibrateTwistRotation = Vector.new()
		end
		
		// calibrate guide tracker. has to come after reach scaling since it uses this value
		pGuideTracker.resolveRealSlot(config)
		pGuideTracker.setTransformTrackTo(component, pGuideBone, trackToVectorFromAxis(pCalibrateGuideTrackAxis))
		
		// calculate retracted reach if used
		if not pMoveRetracted.empty() and indexGuide != -1 and indexTip != -1
			// create a temporary component so we can apply the move and do some measuring
			var Component tcomponent = Component.new(component.getModel(), component.getSkin())
			tcomponent.setRig(component.getRig())
			
			var CharacterAppearance appearance = config.getProfile().getAppearance()
			var Animator tanimator = Animator.new()
			tanimator.setRig(component.getRig())
			tanimator.setAnimation(appearance.getAnimation())
			
			var ARAnimation rule = ARAnimation.new()
			rule.setMoveName(pMoveRetracted)
			tanimator.addRule(rule)
			
			var AnimatorInstance tainst = AnimatorInstance.new()
			tainst.setAnimator(tanimator)
			tainst.setComponent(tcomponent)
			tainst.applyDirect()
			tcomponent.updateBones()
			
			// measure the reach and store it
			var Vector posRoot = tcomponent.boneGetMatrix(indexGuide).getPosition()
			
			var Vector posTip = tcomponent.boneGetMatrix(indexTip) \
				* pTipTracker.getReverseTransformPosition()
			
			pCalibrateReachRetracted = (posTip - posRoot).getLength()
		end
		
		// calculate twist axes
		if pTwistBoneCount > 0 and pTwistPropagation > 0.01
			var int count = DEMath.min(pTwistBoneCount, pCalibrateBones.getCount() - 1)
			var Vector axis = Matrix.newRotation(pTwistAxisRotation).getViewVector()
			var int i, baseIndex = count
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				if indexBone != -1
					pCalibrateTwistAxes.add(component.boneGetInverseMatrix(indexBone).transformNormal(axis))
					
				else
					pCalibrateTwistAxes.add(Vector.new(0, 0, 1))
				end
			end
			
			pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pTwistAxisRotation) \
				* component.boneGetInverseMatrix(indexTip)).getEulerAngles()
		end
	end
	
	/** Find guide track axis. */
	protected func ARTrackToAxis findGuideTrackAxis(Rig rig, String tipBone, String baseBone, String guideBone)
		if tipBone.empty() or baseBone.empty() // bone count less than 2
			return ARTrackToAxis.posZ
		end
		
		var int guide = rig.indexOfBoneNamed(guideBone)
		if guide == -1
			return ARTrackToAxis.posZ
		end
		
		var Vector position = rig.boneGetPosition(guide)
		var Vector absPosition = position.absolute()
		
		if absPosition.getZ() > absPosition.getX() and absPosition.getZ() > absPosition.getY()
			return position.getZ() > 0 if ARTrackToAxis.posZ else ARTrackToAxis.negZ
			
		elif absPosition.getX() > absPosition.getY()
			return position.getX() > 0 if ARTrackToAxis.posX else ARTrackToAxis.negX
			
		else
			return position.getY() > 0 if ARTrackToAxis.posY else ARTrackToAxis.negY
		end
	end
	
	/** Get guide up axis from guide track axis. */
	protected func ARTrackToAxis guideUpFromGuideTrack(ARTrackToAxis axis)
		select pCalibrateGuideTrackAxis
		case ARTrackToAxis.posY, ARTrackToAxis.negY
			return ARTrackToAxis.posZ
			
		else
			return ARTrackToAxis.posY
		end
	end
	
	/** Get track to vector from trackto axis. */
	static public func Vector trackToVectorFromAxis(ARTrackToAxis axis)
		select axis
		case ARTrackToAxis.posZ
			return Vector.new(0, 0, 1)
			
		case ARTrackToAxis.negZ
			return Vector.new(0, 0, -1)
			
		case ARTrackToAxis.posX
			return Vector.new(1, 0, 0)
			
		case ARTrackToAxis.negX
			return Vector.new(-1, 0, 0)
			
		case ARTrackToAxis.posY
			return Vector.new(0, 1, 0)
			
		case ARTrackToAxis.negY
			return Vector.new(0, -1, 0)
			
		else
			throw EInvalidParam.new()
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferIK.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("tipBone")
				setTipBone(element.getFirstCData())
				
			elif tagName.equals("baseBone")
				setBaseBone(element.getFirstCData())
				
			elif tagName.equals("guideBone")
				setGuideBone(element.getFirstCData())
				
			elif tagName.equals("tipTracker")
				pTipTracker.load(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("actorReach")
				setActorReach(ActorReach.named(element.getFirstCData()))
				
			elif tagName.equals("reachLimit")
				setReachLimit(element.getFirstCDataFloat())
				
			elif tagName.equals("adjustPosition")
				setAdjustPosition(element.getFirstCDataBool())
				
			elif tagName.equals("moveBaseIK")
				setMoveBaseIK(element.getFirstCData())
				
			elif tagName.equals("moveRetracted")
				setMoveRetracted(element.getFirstCData())
				
			elif tagName.equals("twistPropagation")
				setTwistPropagation(element.getFirstCDataFloat())
				
			elif tagName.equals("twistBoneCount")
				setTwistBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("twistAxisRotation")
				setTwistAxisRotation(loader.readVector(element))
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	public func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("reach")
				pCalibrateReach = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScale")
				pCalibrateReachScale = element.getFirstCDataFloat()
				
			elif tagName.equals("tipOffset")
				pCalibrateTipOffset = loader.readVector(element)
				
			elif tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("tipTracker")
				pTipTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTrackAxis")
				pCalibrateGuideTrackAxis = ARTrackToAxis.named(element.getFirstCData())
				pCalibrateGuideUpAxis = guideUpFromGuideTrack(pCalibrateGuideTrackAxis)
				
			elif tagName.equals("reachRetracted")
				pCalibrateReachRetracted = element.getFirstCDataFloat()
				
			elif tagName.equals("twistRotation")
				pCalibrateTwistRotation = loader.readVector(element)
				
			elif tagName.equals("twistAxis")
				pCalibrateTwistAxes.add(loader.readVector(element))
				
			elif tagName.equals("twistBoneAxisRotation")
				pCalibrateTwistBoneAxisRotation = loader.readVector(element)
			end
		end)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("tipBone", pTipBone)
		tag.addDataTag("baseBone", pBaseBone)
		tag.addDataTag("guideBone", pGuideBone)
		pTipTracker.save(loader, tag.addTag("tipTracker"))
		pGuideTracker.save(loader, tag.addTag("guideTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		tag.addDataTag("actorReach", pActorReach.name())
		tag.addDataTag("reachLimit", pReachLimit)
		tag.addDataTag("adjustPosition", pAdjustPosition)
		tag.addDataTag("moveBaseIK", pMoveBaseIK)
		tag.addDataTag("moveRetracted", pMoveRetracted)
		tag.addDataTag("twistPropagation", pTwistPropagation)
		tag.addDataTag("twistBoneCount", pTwistBoneCount)
		loader.writeVector(tag, "twistAxisRotation", pTwistAxisRotation)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	public func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("reach", pCalibrateReach)
		tag.addDataTag("reachScale", pCalibrateReachScale)
		loader.writeVector(tag, "tipOffset", pCalibrateTipOffset)
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTipTracker.saveCalibrated(loader, tag.addTag("tipTracker"))
		pGuideTracker.saveCalibrated(loader, tag.addTag("guideTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("baseTracker"))
		tag.addDataTag("guideTrackAxis", pCalibrateGuideTrackAxis.name())
		tag.addDataTag("reachRetracted", pCalibrateReachRetracted)
		loader.writeVector(tag, "twistRotation", pCalibrateTwistRotation)
		pCalibrateTwistAxes.forEach(block Vector each
			loader.writeVector(tag, "twistAxis", each)
		end)
		loader.writeVector(tag, "twistBoneAxisRotation", pCalibrateTwistBoneAxisRotation)
	end
end
