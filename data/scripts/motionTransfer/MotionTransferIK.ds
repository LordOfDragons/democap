/* 
 * Drag[en]gine Motion Capture
 *
 * Copyright (C) 2021, DragonDreams (info@dragondreams.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Democap.MotionTransferSystem

pin Democap.Actors
pin Democap.Behaviors
pin Democap.Characters

pin Dragengine.Animators
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.XML


/**
 * Motion transfer using Inverse Kinematic.
 * 
 * Defines root bone and tip bone name. This defines the bone chain to manipulate.
 * The tip bone is required to be indirect child of the root bone. The length of
 * the bone chain can be 2 or more bones.
 * 
 * Defines the tracker slot to be used to set the tip bone position before applying
 * inverse kinematic. During calibration the coordinate system of the tracker slot
 * relative to the tip bone coordinate system is stored. Custom position and rotation
 * offsets can be applied to fine tune the result if slightly off.
 * 
 * Optionally a guide tracker slot can be defined which is used to guide the orientation
 * of the root bone before applying inverse kinematics. This is used for example to guide
 * the elbow on an arm while shoulder and hand remain at equal position and orientation.
 */
class MotionTransferIK extends DefaultMotionTransfer
	/** Factory. */
	class Factory implements MotionTransferFactory
		public func new()
		end
		
		public func String factoryID()
			return "ik"
		end
		
		public func MotionTransfer createMotionTransfer()
			return MotionTransferIK.new(factoryID())
		end
		
		public func String displayName()
			return "Inverse Kinematic"
		end
	end
	
	/** Actor reach type. */
	enum ActorReach
		none //<! No actor reach. Use unscaled reach
		arm //<! Use actor arm length as reach
		leg //<! Use actor leg length as reach
	end
	
	
	
	private var String pTipBone
	private var String pBaseBone
	private var String pGuideBone
	private var MotionTransferTracker pTipTracker
	private var MotionTransferTracker pGuideTracker
	private var MotionTransferTracker pBaseTracker
	private var ActorReach pActorReach
	private var float pReachLimit
	private var Vector pReachScaling
	private var Vector pReachScalingBack
	private var bool pAdjustPosition
	private var String pMoveBaseIK
	private var String pMoveRetracted
	private var float pTwistPropagation
	private var int pTwistBoneCount
	private var Vector pTwistAxisRotation
	private var float pGuideTwistStrength
	
	private var ADController pADControllerTipPosition
	private var ADController pADControllerTipOrientation
	private var ADController pADControllerGuideRotation
	private var ADController pADControllerTwist
	private var ADController pADControllerRetracted
	private var ADController pADControllerBlend
	
	private var ADRuleInverseKinematic pADRuleGuide
	private var ADRuleInverseKinematic pADRuleIK
	private var ADRuleAnimation pADRuleBaseIK
	private var ADRuleAnimation pADRuleRetracted
	
	private var Array pCalibrateBones
	private var float pCalibrateReach
	private var float pCalibrateReachScale
	private var Vector pCalibrateReachScaleDirection
	private var Vector pCalibrateReachScaleDirectionBack
	private var Vector pCalibrateReachRotation
	private var float pCalibrateReachRange
	private var Vector pCalibrateTipOffset
	private var float pCalibrateReachRetracted
	private var Array pCalibrateTwistAxes
	private var Vector pCalibrateTwistBoneAxisRotation
	private var float pCalibrateReachScaleFront
	private var float pCalibrateReachScaleDown
	private var bool pCalibrateCanTweakReachScale
	
	
	
	/** Create motion transfer. */
	public func new(String factoryID) super(factoryID)
		pTipBone = ""
		pBaseBone = ""
		pGuideBone = ""
		pTipTracker = MotionTransferTracker.new()
		pGuideTracker = MotionTransferTracker.new()
		pBaseTracker = MotionTransferTracker.new()
		pActorReach = ActorReach.none
		pReachLimit = 1
		pReachScaling = Vector.new(1, 1, 1)
		pReachScalingBack = Vector.new(1, 1, 1)
		pAdjustPosition = true
		pMoveBaseIK = ""
		pMoveRetracted = ""
		pTwistPropagation = 0
		pTwistBoneCount = 0
		pTwistAxisRotation = Vector.new()
		pGuideTwistStrength = 0
		pCalibrateBones = Array.new()
		pCalibrateReach = 0.6
		pCalibrateReachScale = 1
		pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
		pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
		pCalibrateReachRange = 0
		pCalibrateReachRetracted = 1
		pCalibrateTipOffset = Vector.new()
		pCalibrateTwistAxes = Array.new()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateReachRotation = Vector.new()
	end
	
	/** Create copy of motion transfer. */
	public func new(MotionTransferIK transfer) super(transfer)
		pTipBone = transfer.pTipBone
		pBaseBone = transfer.pBaseBone
		pGuideBone = transfer.pGuideBone
		pTipTracker = MotionTransferTracker.new(transfer.pTipTracker)
		pGuideTracker = MotionTransferTracker.new(transfer.pGuideTracker)
		pBaseTracker = MotionTransferTracker.new(transfer.pBaseTracker)
		pActorReach = transfer.pActorReach
		pReachLimit = transfer.pReachLimit
		pReachScaling = transfer.pReachScaling
		pReachScalingBack = transfer.pReachScalingBack
		pAdjustPosition = transfer.pAdjustPosition
		pMoveBaseIK = transfer.pMoveBaseIK
		pMoveRetracted = transfer.pMoveRetracted
		pTwistPropagation = transfer.pTwistPropagation
		pTwistBoneCount = transfer.pTwistBoneCount
		pGuideTwistStrength = transfer.pGuideTwistStrength
		pTwistAxisRotation = transfer.pTwistAxisRotation
		pCalibrateBones = Array.new(transfer.pCalibrateBones)
		pCalibrateReach = transfer.pCalibrateReach
		pCalibrateReachScale = transfer.pCalibrateReachScale
		pCalibrateReachScaleDirection = transfer.pCalibrateReachScaleDirection
		pCalibrateReachScaleDirectionBack = transfer.pCalibrateReachScaleDirectionBack
		pCalibrateReachRange = transfer.pCalibrateReachRange
		pCalibrateReachRetracted = transfer.pCalibrateReachRetracted
		pCalibrateTipOffset = transfer.pCalibrateTipOffset
		pCalibrateTwistAxes = Array.new(transfer.pCalibrateTwistAxes)
		pCalibrateTwistBoneAxisRotation = transfer.pCalibrateTwistBoneAxisRotation
		pCalibrateReachRotation = transfer.pCalibrateReachRotation
	end
	
	
	
	/** Tip bone name. */
	public func String getTipBone()
		return pTipBone
	end
	
	/** Set tip bone name. */
	public func void setTipBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pTipBone = bone
	end
	
	/** Base bone name. */
	public func String getBaseBone()
		return pBaseBone
	end
	
	/** Set base bone name. */
	public func void setBaseBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pBaseBone = bone
	end
	
	/** Guide bone name. */
	public func String getGuideBone()
		return pGuideBone
	end
	
	/** Set guide bone name. */
	public func void setGuideBone(String bone)
		if bone == null
			throw ENullPointer.new("bone")
		end
		pGuideBone = bone
	end
	
	/** Tip tracker. */
	public func MotionTransferTracker getTipTracker()
		return pTipTracker
	end
	
	/** Guide tracker. */
	public func MotionTransferTracker getGuideTracker()
		return pGuideTracker
	end
	
	/** Reach tracker. */
	public func MotionTransferTracker getBaseTracker()
		return pBaseTracker
	end
	
	/** Actor reach to use to scale reach length. */
	public func ActorReach getActorReach()
		return pActorReach
	end
	
	/** Set actor reach to use to scale reach length. */
	public func void setActorReach(ActorReach actorReach)
		if actorReach == null
			throw ENullPointer.new("actorReach")
		end
		pActorReach = actorReach
	end
	
	/** Limit reach to percentage of bone chain reach. */
	public func float getReachLimit()
		return pReachLimit
	end
	
	/** Set limit reach to percentage of bone chain reach. */
	public func void setReachLimit(float limit)
		pReachLimit = DEMath.max(limit, 0.1)
	end
	
	/** Reach scaling along axis for fine tune. */
	public func Vector getReachScaling()
		return pReachScaling
	end
	
	/** Set reach scaling along axis for fine tuning. */
	public func void setReachScaling(Vector scaling)
		if scaling == null
			throw ENullPointer.new("scaling")
		end
		pReachScaling = scaling
	end
	
	/** Reach scaling along negative axis for fine tune. */
	public func Vector getReachScalingBack()
		return pReachScalingBack
	end
	
	/** Set reach scaling along negative axis for fine tuning. */
	public func void setReachScalingBack(Vector scaling)
		if scaling == null
			throw ENullPointer.new("scaling")
		end
		pReachScalingBack = scaling
	end
	
	/** Adjust position if chain is of length 1. */
	public func bool getAdjustPosition()
		return pAdjustPosition
	end
	
	/** Set adjust position if chain is of length 1. */
	public func void setAdjustPosition(bool adjust)
		pAdjustPosition = adjust
	end
	
	/** Name of move to use to init base IK state for better results. */
	public func String getMoveBaseIK()
		return pMoveBaseIK
	end
	
	/** Set name of move to use to init base IK state for better results. */
	public func void setMoveBaseIK(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveBaseIK = move
	end
	
	/** Name of move to use to init retracted pose for better results. */
	public func String getMoveRetracted()
		return pMoveRetracted
	end
	
	/** Set name of move to use to init retracted pose for better results. */
	public func void setMoveRetracted(String move)
		if move == null
			throw ENullPointer.new("move")
		end
		pMoveRetracted = move
	end
	
	/** Percentage of tip bone rotation to apply as twist down the chain. */
	public func float getTwistPropagation()
		return pTwistPropagation
	end
	
	/** Set percentage of tip bone rotation to apply as twist down the chain. */
	public func void setTwistPropagation(float percentage)
		pTwistPropagation = percentage
	end
	
	/** Count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func int getTwistBoneCount()
		return pTwistBoneCount
	end
	
	/** Set count of bones along chain to apply twist to starting at first bone after tip bone. */
	public func void setTwistBoneCount(int count)
		if count < 0
			throw EInvalidParam.new("count < 0")
		end
		pTwistBoneCount = count
	end
	
	/** Rotation of twist axis relative to tip bone. */
	public func Vector getTwistAxisRotation()
		return pTwistAxisRotation
	end
	
	/** Set rotation of twist axis relative to tip bone. */
	public func void setTwistAxisRotation(Vector rotation)
		if rotation == null
			throw ENullPointer.new("rotation")
		end
		pTwistAxisRotation = rotation
	end
	
	/** Percentage of tip bone rotation to apply as twist to guide bone. */
	public func float getGuideTwistStrength()
		return pGuideTwistStrength
	end
	
	/** Set percentage of tip bone rotation to apply as twist to guide bone. */
	public func void setGuideTwistStrength(float percentage)
		pGuideTwistStrength = percentage
	end
	
	
	
	/** Animator definition rule or null. */
	public func ADRuleInverseKinematic getADRuleIK()
		return pADRuleIK
	end
	
	public func ADRuleInverseKinematic getADRuleGuide()
		return pADRuleGuide
	end
	
	public func ADRuleAnimation getADRuleBaseIK()
		return pADRuleBaseIK
	end
	
	/** Calibrate reach. */
	public func float getCalibrateReach()
		return pCalibrateReach
	end
	
	/** Calibrate reach scale. */
	public func float getCalibrateReachScale()
		return pCalibrateReachScale
	end
	
	/** Calibrate reach scale per direction. */
	public func Vector getCalibrateReachScaleDirection()
		return pCalibrateReachScaleDirection
	end
	
	/** Calibrate negative reach scale per direction. */
	public func Vector getCalibrateReachScaleDirectionBack()
		return pCalibrateReachScaleDirectionBack
	end
	
	/** Calibrate reach range or 0 if disabled. */
	public func float getCalibrateReachRange()
		return pCalibrateReachRange
	end
	
	/** Calibrate tip offset. */
	public func Vector getCalibrateTipOffset()
		return pCalibrateTipOffset
	end
	
	/** Calibrate twist bone axis rotation. */
	public func Vector getCalibrateTwistBoneAxisRotation()
		return pCalibrateTwistBoneAxisRotation
	end
	
	/** Calibrate reach rotation. */
	public func Vector getCalibrateReachRotation()
		return pCalibrateReachRotation
	end
	
	
	
	/** Init element clas. */
	public func void initElementClass(CharacterConfiguration config, BaseVRActorClass eclass, ModifiedRig modifyRig)
		pADControllerTipPosition = null
		pADControllerTipOrientation = null
		pADControllerGuideRotation = null
		pADControllerRetracted = null
		pADControllerTwist = null
		pADControllerBlend = null
		pADRuleGuide = null
		pADRuleIK = null
		pADRuleBaseIK = null
		pADRuleRetracted = null
		
		// add behavior
		var ECBMotionTransferIK behavior = ECBMotionTransferIK.new(eclass, this)
		
		// add rules
		var CharacterTrackerSlot slotTip, slotGuide, slotReach
		if not pTipTracker.getSlot().empty()
			slotTip = config.getTrackerSlots().getNamed(pTipTracker.getSlot())
		end
		if not pGuideTracker.getSlot().empty()
			slotGuide = config.getTrackerSlots().getNamed(pGuideTracker.getSlot())
		end
		if not pBaseTracker.getSlot().empty()
			slotReach = config.getTrackerSlots().getNamed(pBaseTracker.getSlot())
		end
		
		var int boneCount = pCalibrateBones.getCount()
		if slotTip == null or boneCount < 1 or pTipBone.empty()
			return
		end
		
		var AnimatorDefinition adef = config.getAnimatorDefinition()
		
		var String guideBone = pGuideBone.empty() if pBaseBone else pGuideBone
		
		
		
		// add base IK rules
		if not pMoveBaseIK.empty()
			pADRuleBaseIK = ADRuleAnimation.new()
			pADRuleBaseIK.setName(getName() + ".baseIK")
			pADRuleBaseIK.setMoveName(pMoveBaseIK)
			pCalibrateBones.forEach(block String each
				pADRuleBaseIK.addBone(each)
			end)
			adef.addRule(pADRuleBaseIK)
		end
		
		
		
		// add retracted rules
		if not pMoveRetracted.empty()
			pADControllerRetracted = ADController.new()
			pADControllerRetracted.setName(behavior.getControllerNameRetracted())
			pADControllerRetracted.setMinimum(pCalibrateReachRetracted)
			pADControllerRetracted.setMaximum(pCalibrateReach)
			adef.addController(pADControllerRetracted)
			
			var ADLink link = ADLink.new()
			link.setController(pADControllerRetracted)
			var CurveBezier curve = CurveBezier.new()
			curve.setInterpolationMode(CurveBezierInterpolation.linear)
			curve.addPoint(0, 1) // retracted reach (x=0) => blend factor 1 (y=1)
			curve.addPoint(1, 0) // stretched reach (x=1) => blend factor 0 (y=0)
			link.setCurve(curve)
			adef.addLink(link)
			
			pADRuleRetracted = ADRuleAnimation.new()
			pADRuleRetracted.setName(getName() + ".retracted")
			pADRuleRetracted.setMoveName(pMoveRetracted)
			pCalibrateBones.forEach(block String each
				pADRuleRetracted.addBone(each)
			end)
			pADRuleRetracted.addTargetLink(ADRuleTargetLink.new(ARAnimationTarget.blendFactor, link))
			adef.addRule(pADRuleRetracted)
		end
		
		
		
		// shared controllers and links
		pADControllerBlend = ADController.new()
		pADControllerBlend.setName(behavior.getControllerNameBlend())
		pADControllerBlend.setMinimum(0)
		pADControllerBlend.setMaximum(1)
		adef.addController(pADControllerBlend)
		
		pADControllerTipPosition = ADController.new()
		pADControllerTipPosition.setName(behavior.getControllerNameTipPosition())
		adef.addController(pADControllerTipPosition)
		
		pADControllerTipOrientation = ADController.new()
		pADControllerTipOrientation.setName(behavior.getControllerNameTipOrientation())
		adef.addController(pADControllerTipOrientation)
		
		var ADLink linkBlend = ADLink.new()
		linkBlend.setController(pADControllerBlend)
		adef.addLink(linkBlend)
		
		var ADLink linkTipPosition = ADLink.new()
		linkTipPosition.setController(pADControllerTipPosition)
		adef.addLink(linkTipPosition)
		
		var ADLink linkTipOrientation = ADLink.new()
		linkTipOrientation.setController(pADControllerTipOrientation)
		adef.addLink(linkTipOrientation)
		
		
		
		// add guide rule
		if slotGuide != null and slotGuide.isDeviceAttached()
			pADControllerGuideRotation = ADController.new()
			pADControllerGuideRotation.setName(behavior.getControllerNameGuideRotation())
			adef.addController(pADControllerGuideRotation)
			
			var ADLink linkGuideRotation = ADLink.new()
			linkGuideRotation.setController(pADControllerGuideRotation)
			adef.addLink(linkGuideRotation)
			
			pADRuleGuide = ADRuleInverseKinematic.new()
			pADRuleGuide.setName(getName())
			pADRuleGuide.setAdjustPosition(false)
			pADRuleGuide.setAdjustOrientation(true)
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.blendFactor, linkBlend))
			pADRuleGuide.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkGuideRotation))
			pADRuleGuide.addBone(pGuideBone)
			adef.addRule(pADRuleGuide)
		end
		
		
		
		// add IK rule
		pADRuleIK = ADRuleInverseKinematic.new()
		pADRuleIK.setName(getName())
		pADRuleIK.setAdjustPosition(pAdjustPosition)
		pADRuleIK.setAdjustOrientation(true)
		
		pADRuleIK.setReachBone(pBaseBone)
		pADRuleIK.setReachRange(pCalibrateReachRange)
		
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.blendFactor, linkBlend))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalPosition, linkTipPosition))
		pADRuleIK.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkTipOrientation))
		
		pADRuleIK.addBone(pTipBone)
		if not pBaseBone.equals(pTipBone)
			pADRuleIK.addBone(pBaseBone)
		end
		
		adef.addRule(pADRuleIK)
		
		
		
		// add twist rules
		var bool useTwist = pTwistBoneCount > 0 and pTwistPropagation > 0.01 and boneCount >= 2
		var bool useGuideTwist = not pGuideBone.empty() and not pTipBone.empty() and pGuideTwistStrength > 0.01
		var float maxTwistAngle = 180
		var ADLink linkTwist
		
		if useTwist or useGuideTwist
			pADControllerTwist = ADController.new()
			pADControllerTwist.setName(behavior.getControllerNameTwist())
			pADControllerTwist.setMinimum(-maxTwistAngle)
			pADControllerTwist.setMaximum(maxTwistAngle)
			adef.addController(pADControllerTwist)
			
			linkTwist = ADLink.new()
			linkTwist.setController(pADControllerTwist)
			adef.addLink(linkTwist)
		end
		
		if useGuideTwist
			// add bone to be used as rotator bone
			var float angle = maxTwistAngle * pGuideTwistStrength
			var ModifiedRig.Bone boneTwistAxis = modifyRig.addBone("guideTwistAxis")
			
			var ADController controllerGuideTwistAxis = ADController.new()
			controllerGuideTwistAxis.setName(behavior.getControllerNameGuideTwistAxis())
			adef.addController(controllerGuideTwistAxis)
			
			var ADLink linkGuideTwistAxis = ADLink.new()
			linkGuideTwistAxis.setController(controllerGuideTwistAxis)
			adef.addLink(linkGuideTwistAxis)
			
			var ADRuleInverseKinematic ruleAlign = ADRuleInverseKinematic.new()
			ruleAlign.setName(getName() + ".guideTwist")
			ruleAlign.setSolverBone(pGuideBone)
			ruleAlign.setUseSolverBone(true)
			ruleAlign.addBone(boneTwistAxis.name)
			adef.addRule(ruleAlign)
			
			ruleAlign = ADRuleInverseKinematic.new()
			ruleAlign.setName(getName() + ".guideTwist")
			ruleAlign.setAdjustOrientation(true)
			ruleAlign.setAdjustPosition(false)
			ruleAlign.addTargetLink(ADRuleTargetLink.new(ARInverseKinematicTarget.goalOrientation, linkGuideTwistAxis))
			ruleAlign.addBone(boneTwistAxis.name)
			adef.addRule(ruleAlign)
			
			// apply rotation using the rotator bone
			var ADRuleBoneTransformator rule = ADRuleBoneTransformator.new()
			rule.setName(getName() + ".guideTwist")
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			rule.setTargetBone(boneTwistAxis.name)
			rule.setUseAxis(true)
			rule.setMinimumAngle(-angle)
			rule.setMaximumAngle(angle)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkTwist))
			rule.addBone(pGuideBone)
			adef.addRule(rule)
			
			// cancel rotation on tip bone
			rule = ADRuleBoneTransformator.new()
			rule.setName(getName() + ".guideTwist")
			rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
			rule.setTargetBone(boneTwistAxis.name)
			rule.setUseAxis(true)
			rule.setMinimumAngle(angle)
			rule.setMaximumAngle(-angle)
			rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkTwist))
			rule.addBone(pTipBone)
			adef.addRule(rule)
		end
		
		if useTwist
			var int count = DEMath.min(pTwistBoneCount, boneCount - 1)
			var String name = getName() + ".twist"
			var ADRuleBoneTransformator rule
			var int i
			
			var float angle = pTwistPropagation * maxTwistAngle / count
			var int baseIndex = count
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var Vector axis = pCalibrateTwistAxes.getAt(i) cast Vector
				var float realAngle = angle * (i + 1)
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setTargetBone(bone)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(realAngle)
				rule.setMaximumAngle(-realAngle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkTwist))
				rule.addBone(pCalibrateBones.getAt(baseIndex - i - 1) cast String)
				adef.addRule(rule)
				
				rule = ADRuleBoneTransformator.new()
				rule.setName(name)
				rule.setCoordinateFrame(ARBoneTransformatorCFrame.target)
				rule.setTargetBone(bone)
				rule.setUseAxis(true)
				rule.setAxis(axis)
				rule.setMinimumAngle(-realAngle)
				rule.setMaximumAngle(realAngle)
				rule.addTargetLink(ADRuleTargetLink.new(ARBoneTransformatorTarget.rotation, linkTwist))
				rule.addBone(bone)
				adef.addRule(rule)
			end
		end
		
		
		
		// register bones to record
		var ECBRecordAnimation recordAnimation = ECBRecordAnimation.getBehaviorIn(eclass)
		if recordAnimation != null
			recordAnimation.addBones(pCalibrateBones)
		end
	end
	
	/** Reset calibration. */
	public func void resetCalibration()
		pCalibrateReach = 0.6
		pCalibrateReachScale = 1
		pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
		pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
		pCalibrateReachRange = 0
		pCalibrateReachRetracted = 1
		pCalibrateBones.removeAll()
		pTipTracker.resetTransform()
		pGuideTracker.resetTransform()
		pBaseTracker.resetTransform()
		pCalibrateTwistAxes.removeAll()
		pCalibrateTwistBoneAxisRotation = Vector.new()
		pCalibrateReachRotation = Vector.new()
		pCalibrateReachScaleFront = 0
		pCalibrateReachScaleDown = 0
		pCalibrateCanTweakReachScale = false
	end
	
	/** Calibrate character. */
	public func void calibrate(CharacterConfiguration config, ActorProfile actorProfile, \
	BaseVRActor actor, Component component)
		findBoneChain(component.getRig(), pTipBone, pBaseBone, pCalibrateBones)
		var String baseBone = "", guideBone = ""
		if pCalibrateBones.getCount() >= 2
			baseBone = pBaseBone
			guideBone = pGuideBone
		end
		
		if guideBone.empty()
			guideBone = baseBone
		end
		
		pTipTracker.resolveRealSlot(config)
		pTipTracker.setTransform(component, pTipBone)
		
		pBaseTracker.resolveRealSlot(config)
		pBaseTracker.setTransform(component, guideBone)
		
		// calculate reach of IK chain to avoid over stretching
		var int indexBase = -1, indexGuide = -1, indexTip = -1
		if not baseBone.empty() and not pTipBone.empty()
			indexBase = component.indexOfBoneNamed(baseBone)
			indexGuide = component.indexOfBoneNamed(guideBone)
			indexTip = component.indexOfBoneNamed(pTipBone)
		end
		
		if indexBase != -1 and indexTip != -1
			var Matrix baseMatrix = component.boneGetMatrix(indexBase)
			var Matrix tipMatrix = component.boneGetMatrix(indexTip)
			
			var CharacterTrackerSlot slotBase = pBaseTracker.getRealSlot()
			var CharacterTrackerSlot slotTip = pTipTracker.getRealSlot()
			
			var Vector posBase = baseMatrix.getPosition()
			var Vector posTip = tipMatrix.getPosition()
			
			select pActorReach
			case ActorReach.arm
				// actor arm reach parameter matches tracker target not target bone
				if slotTip != null
					// matrix = bone * transform^-1 * (ref * slot^1) * (target * ref^-1)
					posTip = (pTipTracker.getOffsetMatrix() * slotTip.getTargetMatrix()).getPosition()
				end
				
				// along Z direction this is always 1.
				// along X and Y direction the scaling has to be adjusted. this is due
				// to the character shoulder joint usually not lining up with the actor
				// shoulder joint. here though the spine attachment point is usually used
				// as the base of the IK chain. this has the advantage that with the
				// actor the spine attachment point is pretty much at the center of the
				// actor. this way the location of the character spine attachment point
				// becomes the pivot point. the length from the pivot point to the
				// character center is fixed. the remaining length has to make a turn
				// to reach the IK point. this length has to be matched with the length
				// from the turned IK point to the spine attachment point.
				
				// the reach front can be calculate by using a shortening of the calibrate
				// reach. this can be done using a fudge factor but that can be wrong.
				// another solution is to consider the base bone as the shoulder bone
				// which does not full rotate. the length of all other bones indicates
				// the maximum reach if the shoulder bone does not rotate. using the
				// length of the shoulder bone and a maximum rotation range for
				// forward/backward and up/down the actual reach can be calculated.
				// we can use the guide bone for this
				
				var Vector posRotate = posBase.absolute()
				var Vector tipFront, tipDown
				var float rotateFront = 40
				var float rotateDown = 40
				
				if indexGuide != -1 and indexGuide != indexBase
					posRotate = component.boneGetMatrix(indexGuide).getPosition().absolute()
				end
				
				var float reachRotateTip = (posTip.absolute() - posRotate).getLength()
				var float reachBaseRotate = (posRotate - posBase.absolute()).getLength() // can be 0
				//var float offsetBase = posBase.absolute().getX()
				var Vector tip, actorTip
				
				// reach scaling
				var float actorScale = config.getCalibrateScale()
				var float actorShoulderReach = (actorProfile.getShoulderWidth() / 2) * actorScale
				var float actorArmReach = actorProfile.getArmLength() * actorScale
				var float actorReach = actorShoulderReach + actorArmReach
				
				if pTipTracker.getRealSlot() != null
					actorReach = (pTipTracker.getTransformMatrix()\
						* pTipTracker.getRealSlot().getCalibrateMatrix())\
							.getPosition().absolute().getX()
					actorArmReach = actorReach - actorShoulderReach
				end
				
				pCalibrateReach = reachBaseRotate + reachRotateTip
				pCalibrateReachScale = pCalibrateReach / actorReach
				
				// front, back
				tip = Vector.new(reachBaseRotate * DEMath.cos(rotateFront),\
					0, reachRotateTip + reachBaseRotate * DEMath.sin(rotateFront))
				
				pCalibrateReachScaleFront = tip.getLength() / pCalibrateReach
				
				// down, up
				tip = Vector.new(reachBaseRotate * DEMath.cos(rotateDown),\
					-(reachRotateTip + reachBaseRotate * DEMath.sin(rotateDown)), 0)
				
				pCalibrateReachScaleDown = tip.getLength() / pCalibrateReach
				
				// store direction specific scale
				pCalibrateReachScaleDirection = Vector.new(1, pCalibrateReachScaleDown,\
					pCalibrateReachScaleFront).compMultiply(pReachScaling)
				
				pCalibrateReachScaleDirectionBack = Vector.new(1, pCalibrateReachScaleDown,\
					pCalibrateReachScaleFront).compMultiply(pReachScalingBack)
				
				pCalibrateCanTweakReachScale = true
				
			case ActorReach.leg
				// reach scale is not working well with legs
//	 				pCalibrateReachScale = pCalibrateReach / (actorProfile.getLegLength() * config.getCalibrateScale())
				pCalibrateReach = (posTip - posBase).getLength()
				pCalibrateReachScale = 1
				pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
				pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
				
			else
				pCalibrateReach = (posTip - posBase).getLength()
				pCalibrateReachScale = 1
				pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
				pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
			end
			
			if slotTip != null and pTipTracker.getAutoTransform() == MotionTransferTracker.AutoTransform.orientationTarget
				var Vector displacement = slotTip.getTargetPosition()\
					- slotTip.getCalibrateReferenceMatrix().getPosition()
				
				if displacement.getLength() > 0.01
					pCalibrateTipOffset = component.boneGetInverseMatrix(indexBase)\
						.transformNormal(displacement)
					
				else
					pCalibrateTipOffset = Vector.new()
				end
				
// 				pCalibrateTipOffset = posTip - slotTip.getCalibratePosition()
				//var Vector slotPos = slotTip.getCalibratePosition()
				//var float realReach = (slotPos - posGuide).getLength()
				//pCalibrateReachScale = pCalibrateReach / realReach
				
			else
				pCalibrateTipOffset = Vector.new()
				//pCalibrateReachScale = 1
				//pCalibrateGuideTrackAxis = ARTrackToAxis.posZ
				//pCalibrateGuideUpAxis = ARTrackToAxis.posY
			end
			
			// reach range is only used if base tracker is set
			if slotBase != null
				pCalibrateReachRange = pCalibrateReach
				
			else
				pCalibrateReachRange = 0
			end
			
		else
			pCalibrateReach = 0.6
			pCalibrateReachScale = 1
			pCalibrateReachScaleDirection = Vector.new(1, 1, 1)
			pCalibrateReachScaleDirectionBack = Vector.new(1, 1, 1)
			pCalibrateReachRange = 0
			pCalibrateReachRetracted = pCalibrateReach
			pCalibrateTipOffset = Vector.new()
		end
		
		// calibrate guide tracker. has to come after reach scaling since it uses this value
		pGuideTracker.resolveRealSlot(config)
		pGuideTracker.setTransform(component, guideBone)
		
		// calculate retracted reach if used
		if not pMoveRetracted.empty() and indexGuide != -1 and indexTip != -1
			// create a temporary component so we can apply the move and do some measuring
			var Component tcomponent = Component.new(component.getModel(), component.getSkin())
			tcomponent.setRig(component.getRig())
			
			var CharacterAppearance appearance = config.getProfile().getAppearance()
			var Animator tanimator = Animator.new()
			tanimator.setRig(component.getRig())
			tanimator.setAnimation(appearance.getAnimation())
			
			var ARAnimation rule = ARAnimation.new()
			rule.setMoveName(pMoveRetracted)
			tanimator.addRule(rule)
			
			var AnimatorInstance tainst = AnimatorInstance.new()
			tainst.setAnimator(tanimator)
			tainst.setComponent(tcomponent)
			tainst.applyDirect()
			tcomponent.updateBones()
			
			// measure the reach and store it
			var Vector posRoot = tcomponent.boneGetMatrix(indexGuide).getPosition()
			var Vector posTip = tcomponent.boneGetMatrix(indexTip).getPosition()
			
			pCalibrateReachRetracted = (posTip - posRoot).getLength()
		end
		
		// calculate twist axes
		if pTwistBoneCount > 0 and pTwistPropagation > 0.01
			var int count = DEMath.min(pTwistBoneCount, pCalibrateBones.getCount() - 1)
			var Vector axis = Matrix.newRotation(pTwistAxisRotation).getViewVector()
			var int i, baseIndex = count
			
			for i = 0 to count
				var String bone = pCalibrateBones.getAt(baseIndex - i) cast String
				var int indexBone = component.indexOfBoneNamed(bone)
				if indexBone != -1
					pCalibrateTwistAxes.add(component.boneGetInverseMatrix(indexBone).transformNormal(axis))
					
				else
					pCalibrateTwistAxes.add(Vector.new(0, 0, 1))
				end
			end
		end
		
		if indexTip != -1
			pCalibrateTwistBoneAxisRotation = (Matrix.newRotation(pTwistAxisRotation) \
				* component.boneGetInverseMatrix(indexTip)).getEulerAngles()
		end
		
		if indexBase != -1
			pCalibrateReachRotation = (Matrix.newRotation(pTwistAxisRotation) \
				* component.boneGetInverseMatrix(indexBase)).getEulerAngles()
		end
	end
	
	public func void tweaked()
		if pCalibrateCanTweakReachScale
			select pActorReach
			case ActorReach.arm
				pCalibrateReachScaleDirection = Vector.new(1, pCalibrateReachScaleDown,\
					pCalibrateReachScaleFront).compMultiply(pReachScaling)
				pCalibrateReachScaleDirectionBack = Vector.new(1, pCalibrateReachScaleDown,\
					pCalibrateReachScaleFront).compMultiply(pReachScalingBack)
			end
		end
	end
	
	/** Create copy of motion transfer. */
	public func MotionTransfer createCopy()
		return MotionTransferIK.new(this)
	end
	
	/** Load from XML. */
	public func void load(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("name")
				setName(element.getFirstCData())
				
			elif tagName.equals("tipBone")
				setTipBone(element.getFirstCData())
				
			elif tagName.equals("baseBone")
				setBaseBone(element.getFirstCData())
				
			elif tagName.equals("guideBone")
				setGuideBone(element.getFirstCData())
				
			elif tagName.equals("tipTracker")
				pTipTracker.load(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.load(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.load(loader, element)
				
			elif tagName.equals("actorReach")
				setActorReach(ActorReach.named(element.getFirstCData()))
				
			elif tagName.equals("reachLimit")
				setReachLimit(element.getFirstCDataFloat())
				
			elif tagName.equals("reachScaling")
				pReachScaling = loader.readVector(element)
				
			elif tagName.equals("reachScalingBack")
				pReachScalingBack = loader.readVector(element)
				
			elif tagName.equals("adjustPosition")
				setAdjustPosition(element.getFirstCDataBool())
				
			elif tagName.equals("moveBaseIK")
				setMoveBaseIK(element.getFirstCData())
				
			elif tagName.equals("moveRetracted")
				setMoveRetracted(element.getFirstCData())
				
			elif tagName.equals("twistPropagation")
				setTwistPropagation(element.getFirstCDataFloat())
				
			elif tagName.equals("twistBoneCount")
				setTwistBoneCount(element.getFirstCDataInt())
				
			elif tagName.equals("twistAxisRotation")
				setTwistAxisRotation(loader.readVector(element))
				
			elif tagName.equals("guideTwistStrength")
				setGuideTwistStrength(element.getFirstCDataFloat())
				
			elif tagName.equals("calibrated")
				loadCalibrated(loader, element)
			end
		end)
	end
	
	public func void loadCalibrated(BaseXmlLoader loader, EasyXMLElement root)
		root.forEachTag(block EasyXMLElement element, String tagName
			if tagName.equals("reach")
				pCalibrateReach = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScale")
				pCalibrateReachScale = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScaleDirection")
				pCalibrateReachScaleDirection = loader.readVector(element)
				
			elif tagName.equals("reachScaleDirectionBack")
				pCalibrateReachScaleDirectionBack = loader.readVector(element)
				
			elif tagName.equals("reachScaleFront")
				pCalibrateReachScaleFront = element.getFirstCDataFloat()
				
			elif tagName.equals("reachScaleDown")
				pCalibrateReachScaleDown = element.getFirstCDataFloat()
				
			elif tagName.equals("reachRange")
				pCalibrateReachRange = element.getFirstCDataFloat()
				
			elif tagName.equals("reachRotation")
				pCalibrateReachRotation = loader.readVector(element)
				
			elif tagName.equals("tipOffset")
				pCalibrateTipOffset = loader.readVector(element)
				
			elif tagName.equals("bone")
				pCalibrateBones.add(element.getFirstCData())
				
			elif tagName.equals("tipTracker")
				pTipTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("guideTracker")
				pGuideTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("baseTracker")
				pBaseTracker.loadCalibrated(loader, element)
				
			elif tagName.equals("reachRetracted")
				pCalibrateReachRetracted = element.getFirstCDataFloat()
				
			elif tagName.equals("twistAxis")
				pCalibrateTwistAxes.add(loader.readVector(element))
				
			elif tagName.equals("twistBoneAxisRotation")
				pCalibrateTwistBoneAxisRotation = loader.readVector(element)
				
			elif tagName.equals("canTweakReachScale")
				pCalibrateCanTweakReachScale = element.getFirstCDataBool()
			end
		end)
	end
	
	/** Post load initialize. */
	public func void postLoadInit(CharacterConfiguration config)
		pTipTracker.resolveRealSlot(config)
		pGuideTracker.resolveRealSlot(config)
		pBaseTracker.resolveRealSlot(config)
	end
	
	/** Save to XML. */
	public func void save(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("name", getName())
		tag.addDataTag("tipBone", pTipBone)
		tag.addDataTag("baseBone", pBaseBone)
		tag.addDataTag("guideBone", pGuideBone)
		pTipTracker.save(loader, tag.addTag("tipTracker"))
		pGuideTracker.save(loader, tag.addTag("guideTracker"))
		pBaseTracker.save(loader, tag.addTag("baseTracker"))
		tag.addDataTag("actorReach", pActorReach.name())
		tag.addDataTag("reachLimit", pReachLimit)
		loader.writeVector(tag, "reachScaling", pReachScaling)
		loader.writeVector(tag, "reachScalingBack", pReachScalingBack)
		tag.addDataTag("adjustPosition", pAdjustPosition)
		tag.addDataTag("moveBaseIK", pMoveBaseIK)
		tag.addDataTag("moveRetracted", pMoveRetracted)
		tag.addDataTag("twistPropagation", pTwistPropagation)
		tag.addDataTag("twistBoneCount", pTwistBoneCount)
		loader.writeVector(tag, "twistAxisRotation", pTwistAxisRotation)
		tag.addDataTag("guideTwistStrength", pGuideTwistStrength)
		saveCalibrated(loader, tag.addTag("calibrated"))
	end
	
	public func void saveCalibrated(BaseXmlLoader loader, EasyXMLElement tag)
		tag.addDataTag("reach", pCalibrateReach)
		tag.addDataTag("reachScale", pCalibrateReachScale)
		loader.writeVector(tag, "reachScaleDirection", pCalibrateReachScaleDirection)
		loader.writeVector(tag, "reachScaleDirectionBack", pCalibrateReachScaleDirectionBack)
		tag.addDataTag("reachScaleFront", pCalibrateReachScaleFront)
		tag.addDataTag("reachScaleDown", pCalibrateReachScaleDown)
		tag.addDataTag("reachRange", pCalibrateReachRange)
		loader.writeVector(tag, "reachRotation", pCalibrateReachRotation)
		loader.writeVector(tag, "tipOffset", pCalibrateTipOffset)
		pCalibrateBones.forEach(block String each
			tag.addDataTag("bone", each)
		end)
		pTipTracker.saveCalibrated(loader, tag.addTag("tipTracker"))
		pGuideTracker.saveCalibrated(loader, tag.addTag("guideTracker"))
		pBaseTracker.saveCalibrated(loader, tag.addTag("baseTracker"))
		tag.addDataTag("reachRetracted", pCalibrateReachRetracted)
		pCalibrateTwistAxes.forEach(block Vector each
			loader.writeVector(tag, "twistAxis", each)
		end)
		loader.writeVector(tag, "twistBoneAxisRotation", pCalibrateTwistBoneAxisRotation)
		tag.addDataTag("canTweakReachScale", pCalibrateCanTweakReachScale)
	end
end
